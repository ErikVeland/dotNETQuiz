{
  "moduleSlug": "node-fundamentals",
  "title": "Node Fundamentals Assessment",
  "description": "Comprehensive assessment covering key concepts from the node-fundamentals module",
  "totalQuestions": 20,
  "passingScore": 70,
  "timeLimit": 23,
  "questions": [
    {
      "id": "node-fundamentals-q1",
      "question": "What is Node.js?",
      "topic": "Basics",
      "difficulty": "Beginner",
      "choices": [
        "A JavaScript runtime built on Chrome's V8 JavaScript engine",
        "A CSS framework",
        "A database management system",
        "A front-end framework"
      ],
      "correctIndex": 0,
      "explanation": "Node.js is a JavaScript runtime that allows you to run JavaScript on the server-side, built on Chrome's V8 JavaScript engine.",
      "industryContext": "Node.js is essential for modern backend development and tooling.",
      "tags": [
        "Basics",
        "beginner",
        "node"
      ],
      "questionType": "multiple-choice",
      "estimatedTime": 90,
      "legacy": {
        "originalId": 1,
        "originalType": "multiple-choice",
        "migrated": "2025-10-01T06:41:13.484Z"
      }
    },
    {
      "id": "node-fundamentals-q2",
      "question": "How do you import a module in Node.js?",
      "topic": "Basics",
      "difficulty": "Beginner",
      "choices": [
        "require()",
        "import",
        "include",
        "load"
      ],
      "correctIndex": 0,
      "explanation": "In Node.js, modules are imported using the require() function. The import statement is used in ES6 modules.",
      "industryContext": "Node.js is essential for modern backend development and tooling.",
      "tags": [
        "Basics",
        "beginner",
        "node"
      ],
      "questionType": "multiple-choice",
      "estimatedTime": 90,
      "legacy": {
        "originalId": 2,
        "originalType": "multiple-choice",
        "migrated": "2025-10-01T06:41:13.484Z"
      }
    },
    {
      "id": "node-fundamentals-q3",
      "question": "What is Express.js and why is it used?",
      "topic": "Express",
      "difficulty": "Beginner",
      "choices": [
        "Open-ended question - no multiple choice",
        "This is a conceptual question",
        "Answer requires explanation",
        "Multiple approaches possible"
      ],
      "correctIndex": 0,
      "explanation": "Express.js is a minimal and flexible Node.js web application framework that provides a robust set of features for web and mobile applications. It simplifies the process of building web servers and APIs by providing helpful utilities and middleware.",
      "industryContext": "Node.js is essential for modern backend development and tooling.",
      "tags": [
        "Express",
        "beginner",
        "node"
      ],
      "questionType": "open-ended",
      "estimatedTime": 180,
      "legacy": {
        "originalId": 3,
        "originalType": "open-ended",
        "migrated": "2025-10-01T06:41:13.484Z"
      }
    },
    {
      "id": "node-fundamentals-q4",
      "question": "Which method is used to handle GET requests in Express?",
      "topic": "Express",
      "difficulty": "Intermediate",
      "choices": [
        "app.get()",
        "app.post()",
        "app.put()",
        "app.delete()"
      ],
      "correctIndex": 0,
      "explanation": "In Express.js, app.get() is used to define a route handler for GET requests.",
      "industryContext": "Node.js is essential for modern backend development and tooling.",
      "tags": [
        "Express",
        "intermediate",
        "node"
      ],
      "questionType": "multiple-choice",
      "estimatedTime": 90,
      "legacy": {
        "originalId": 4,
        "originalType": "multiple-choice",
        "migrated": "2025-10-01T06:41:13.484Z"
      }
    },
    {
      "id": "node-fundamentals-q5",
      "question": "What is middleware in Express.js?",
      "topic": "Middleware",
      "difficulty": "Beginner",
      "choices": [
        "Functions that have access to the request and response objects",
        "Database connection utilities",
        "Template engines",
        "Routing functions"
      ],
      "correctIndex": 0,
      "explanation": "Middleware functions in Express.js are functions that have access to the request object, the response object, and the next middleware function in the application's request-response cycle.",
      "industryContext": "Node.js is essential for modern backend development and tooling.",
      "tags": [
        "Middleware",
        "beginner",
        "node"
      ],
      "questionType": "multiple-choice",
      "estimatedTime": 90,
      "legacy": {
        "originalId": 5,
        "originalType": "multiple-choice",
        "migrated": "2025-10-01T06:41:13.484Z"
      }
    },
    {
      "id": "node-fundamentals-q6",
      "question": "How do you handle asynchronous operations in Node.js?",
      "topic": "Async",
      "difficulty": "Beginner",
      "choices": [
        "Using callbacks, promises, or async/await",
        "Using synchronous functions only",
        "Using threads",
        "Using global variables"
      ],
      "correctIndex": 0,
      "explanation": "Node.js handles asynchronous operations using callbacks, promises, or the more modern async/await syntax.",
      "industryContext": "Node.js is essential for modern backend development and tooling.",
      "tags": [
        "Async",
        "beginner",
        "node"
      ],
      "questionType": "multiple-choice",
      "estimatedTime": 90,
      "legacy": {
        "originalId": 6,
        "originalType": "multiple-choice",
        "migrated": "2025-10-01T06:41:13.484Z"
      }
    },
    {
      "id": "node-fundamentals-q7",
      "question": "What is NPM and what is it used for?",
      "topic": "NPM",
      "difficulty": "Beginner",
      "choices": [
        "Open-ended question - no multiple choice",
        "This is a conceptual question",
        "Answer requires explanation",
        "Multiple approaches possible"
      ],
      "correctIndex": 0,
      "explanation": "NPM (Node Package Manager) is the default package manager for Node.js. It is used to install, share, and manage packages (libraries and tools) in Node.js projects. It also helps with dependency management and script execution.",
      "industryContext": "Node.js is essential for modern backend development and tooling.",
      "tags": [
        "NPM",
        "beginner",
        "node"
      ],
      "questionType": "open-ended",
      "estimatedTime": 180,
      "legacy": {
        "originalId": 7,
        "originalType": "open-ended",
        "migrated": "2025-10-01T06:41:13.484Z"
      }
    },
    {
      "id": "node-fundamentals-q8",
      "question": "What is the event loop in Node.js?",
      "topic": "Event Loop",
      "difficulty": "Beginner",
      "choices": [
        "A mechanism that handles asynchronous operations",
        "A loop that executes synchronous code",
        "A database query optimizer",
        "A memory management system"
      ],
      "correctIndex": 0,
      "explanation": "The event loop in Node.js is a mechanism that handles asynchronous operations by continuously checking the call stack and callback queue to execute callbacks when the call stack is empty.",
      "industryContext": "Node.js is essential for modern backend development and tooling.",
      "tags": [
        "Event Loop",
        "beginner",
        "node"
      ],
      "questionType": "multiple-choice",
      "estimatedTime": 90,
      "legacy": {
        "originalId": 8,
        "originalType": "multiple-choice",
        "migrated": "2025-10-01T06:41:13.484Z"
      }
    },
    {
      "id": "node-fundamentals-q9",
      "question": "What is the main advantage of using async/await over Promises in Node.js?",
      "topic": "Async Programming",
      "difficulty": "Beginner",
      "choices": [
        "More readable and easier to debug synchronous-looking code",
        "Better performance than Promises",
        "Automatic error handling without try-catch",
        "Faster execution than callback functions"
      ],
      "correctIndex": 0,
      "explanation": "Async/await provides more readable, synchronous-looking code that's easier to debug and maintain. While it doesn't improve performance over Promises (it's syntactic sugar over them), it makes error handling with try-catch more natural and reduces callback hell and Promise chaining complexity.",
      "industryContext": "Node.js is essential for modern backend development and tooling.",
      "tags": [
        "Async Programming",
        "beginner",
        "node"
      ],
      "questionType": "multiple-choice",
      "estimatedTime": 90,
      "legacy": {
        "originalId": 9,
        "originalType": "multiple-choice",
        "migrated": "2025-10-01T06:41:13.484Z"
      }
    },
    {
      "id": "node-fundamentals-q10",
      "question": "What is clustering in Node.js and why is it useful?",
      "topic": "Performance",
      "difficulty": "Beginner",
      "choices": [
        "Running multiple Node.js processes to utilize all CPU cores",
        "Grouping related modules together",
        "Connecting multiple databases",
        "Organizing code into clusters of functions"
      ],
      "correctIndex": 0,
      "explanation": "Clustering in Node.js allows you to create multiple worker processes that share the same server port, enabling utilization of all CPU cores. Since Node.js is single-threaded, clustering helps improve performance for CPU-intensive applications by distributing the workload across multiple processes.",
      "industryContext": "Node.js is essential for modern backend development and tooling.",
      "tags": [
        "Performance",
        "beginner",
        "node"
      ],
      "questionType": "multiple-choice",
      "estimatedTime": 90,
      "legacy": {
        "originalId": 10,
        "originalType": "multiple-choice",
        "migrated": "2025-10-01T06:41:13.484Z"
      }
    },
    {
      "id": "node-fundamentals-q11",
      "question": "What are some essential security practices for Node.js applications?",
      "topic": "Security",
      "difficulty": "Intermediate",
      "choices": [
        "Open-ended question - no multiple choice",
        "This is a conceptual question",
        "Answer requires explanation",
        "Multiple approaches possible"
      ],
      "correctIndex": 0,
      "explanation": "Essential security practices include: using HTTPS everywhere, validating and sanitizing all input, implementing proper authentication and authorization, using helmet.js for security headers, rate limiting, keeping dependencies updated, using environment variables for secrets, implementing CSRF protection, using secure session management, and regular security audits with tools like npm audit.",
      "industryContext": "Node.js is essential for modern backend development and tooling.",
      "tags": [
        "Security",
        "intermediate",
        "node"
      ],
      "questionType": "open-ended",
      "estimatedTime": 180,
      "legacy": {
        "originalId": 11,
        "originalType": "open-ended",
        "migrated": "2025-10-01T06:41:13.484Z"
      }
    },
    {
      "id": "node-fundamentals-q12",
      "question": "Which testing framework is most commonly used for Node.js applications?",
      "topic": "Testing",
      "difficulty": "Intermediate",
      "choices": [
        "Jest",
        "JUnit",
        "PHPUnit",
        "NUnit"
      ],
      "correctIndex": 0,
      "explanation": "Jest is the most popular testing framework for Node.js applications. It provides a comprehensive testing solution with built-in test runner, assertion library, mocking capabilities, and code coverage reporting. Other popular options include Mocha and Chai, but Jest has gained widespread adoption due to its simplicity and feature completeness.",
      "industryContext": "Node.js is essential for modern backend development and tooling.",
      "tags": [
        "Testing",
        "intermediate",
        "node"
      ],
      "questionType": "multiple-choice",
      "estimatedTime": 90,
      "legacy": {
        "originalId": 12,
        "originalType": "multiple-choice",
        "migrated": "2025-10-01T06:41:13.484Z"
      }
    },
    {
      "id": "node-fundamentals-q13",
      "question": "What is the difference between fs.readFile() and fs.readFileSync() in Node.js?",
      "topic": "File System",
      "difficulty": "Beginner",
      "choices": [
        "readFile() is asynchronous and non-blocking, readFileSync() is synchronous and blocking",
        "readFile() is faster than readFileSync()",
        "readFileSync() supports more file formats",
        "readFile() requires more memory than readFileSync()"
      ],
      "correctIndex": 0,
      "explanation": "fs.readFile() is asynchronous and non-blocking, allowing other operations to continue while the file is being read. fs.readFileSync() is synchronous and blocks the event loop until the file reading is complete. The async version is preferred in production applications to maintain performance and responsiveness.",
      "industryContext": "Node.js is essential for modern backend development and tooling.",
      "tags": [
        "File System",
        "beginner",
        "node"
      ],
      "questionType": "multiple-choice",
      "estimatedTime": 90,
      "legacy": {
        "originalId": 13,
        "originalType": "multiple-choice",
        "migrated": "2025-10-01T06:41:13.484Z"
      }
    },
    {
      "id": "node-fundamentals-q14",
      "question": "How should you handle uncaught exceptions in Node.js applications?",
      "topic": "Error Handling",
      "difficulty": "Intermediate",
      "choices": [
        "Open-ended question - no multiple choice",
        "This is a conceptual question",
        "Answer requires explanation",
        "Multiple approaches possible"
      ],
      "correctIndex": 0,
      "explanation": "Handle uncaught exceptions by: 1) Using process.on('uncaughtException') to log errors and gracefully shut down, 2) Using process.on('unhandledRejection') for unhandled Promise rejections, 3) Implementing proper error handling in all async operations, 4) Using try-catch blocks around critical code, 5) Using process managers like PM2 for automatic restarts, 6) Logging all errors for debugging. Never ignore uncaught exceptions as they can lead to memory leaks and unstable applications.",
      "industryContext": "Node.js is essential for modern backend development and tooling.",
      "tags": [
        "Error Handling",
        "intermediate",
        "node"
      ],
      "questionType": "open-ended",
      "estimatedTime": 180,
      "legacy": {
        "originalId": 14,
        "originalType": "open-ended",
        "migrated": "2025-10-01T06:41:13.484Z"
      }
    },
    {
      "id": "node-fundamentals-q15",
      "question": "What is the main advantage of using streams for processing large files in Node.js?",
      "topic": "Streams",
      "difficulty": "Beginner",
      "choices": [
        "Memory efficient processing of data in chunks",
        "Faster file compression",
        "Better error handling",
        "Automatic file backup"
      ],
      "correctIndex": 0,
      "explanation": "Streams allow memory-efficient processing of large files by reading and processing data in small chunks rather than loading the entire file into memory. This prevents memory overflow issues and enables processing of files larger than available RAM, making applications more scalable and efficient.",
      "industryContext": "Node.js is essential for modern backend development and tooling.",
      "tags": [
        "Streams",
        "beginner",
        "node"
      ],
      "questionType": "multiple-choice",
      "estimatedTime": 90,
      "legacy": {
        "originalId": 15,
        "originalType": "multiple-choice",
        "migrated": "2025-10-01T06:41:13.484Z"
      }
    },
    {
      "id": "node-fundamentals-q16",
      "question": "What are the key security considerations when developing Node.js applications?",
      "topic": "Security",
      "difficulty": "Advanced",
      "choices": [
        "Open-ended question - no multiple choice",
        "This is a conceptual question",
        "Answer requires explanation",
        "Multiple approaches possible"
      ],
      "correctIndex": 0,
      "explanation": "Key security considerations include: input validation and sanitization to prevent XSS and injection attacks, secure password hashing with bcrypt, proper authentication and authorization, rate limiting to prevent DoS attacks, using HTTPS and security headers (helmet), keeping dependencies updated, implementing proper error handling without exposing sensitive information, and using environment variables for secrets.",
      "industryContext": "Security is critical for production Node.js applications, especially in enterprise environments handling sensitive data.",
      "tags": [
        "Security",
        "advanced",
        "node"
      ],
      "questionType": "open-ended",
      "estimatedTime": 180
    },
    {
      "id": "node-fundamentals-q17",
      "question": "What is the difference between process.nextTick() and setImmediate() in Node.js?",
      "topic": "Event Loop",
      "difficulty": "Advanced",
      "choices": [
        "process.nextTick() executes before I/O events, setImmediate() executes after",
        "setImmediate() executes before I/O events, process.nextTick() executes after",
        "Both execute at the same time",
        "They are identical functions"
      ],
      "correctIndex": 0,
      "explanation": "process.nextTick() has higher priority and executes callbacks before I/O events in the same phase, while setImmediate() executes callbacks after I/O events. process.nextTick() can potentially starve I/O if overused.",
      "industryContext": "Understanding event loop mechanics is crucial for writing performant Node.js applications.",
      "tags": [
        "Event Loop",
        "advanced",
        "node"
      ],
      "questionType": "multiple-choice",
      "estimatedTime": 120
    },
    {
      "id": "node-fundamentals-q18",
      "question": "How do you implement clustering in Node.js and why is it important?",
      "topic": "Performance",
      "difficulty": "Advanced",
      "choices": [
        "Using the cluster module to fork worker processes",
        "Using threads with the worker_threads module",
        "Using external load balancers only",
        "Node.js automatically handles clustering"
      ],
      "correctIndex": 0,
      "explanation": "Clustering in Node.js is implemented using the cluster module, which allows you to fork multiple worker processes that share the same server port. This is important because Node.js is single-threaded by default, so clustering allows utilization of multiple CPU cores for better performance.",
      "industryContext": "Clustering is essential for production Node.js applications to maximize server resource utilization.",
      "tags": [
        "Performance",
        "advanced",
        "node"
      ],
      "questionType": "multiple-choice",
      "estimatedTime": 120
    },
    {
      "id": "node-fundamentals-q19",
      "question": "What are the benefits and challenges of microservices architecture with Node.js?",
      "topic": "Architecture",
      "difficulty": "Advanced",
      "choices": [
        "Open-ended question - no multiple choice",
        "This is a conceptual question",
        "Answer requires explanation",
        "Multiple approaches possible"
      ],
      "correctIndex": 0,
      "explanation": "Benefits include: independent deployment and scaling, technology diversity, fault isolation, and team autonomy. Challenges include: increased complexity in service communication, distributed system challenges (consistency, monitoring), network latency, data consistency across services, and operational overhead. Node.js is well-suited for microservices due to its lightweight nature and excellent I/O handling.",
      "industryContext": "Microservices architecture is widely adopted in enterprise environments for scalable, maintainable applications.",
      "tags": [
        "Architecture",
        "advanced",
        "node"
      ],
      "questionType": "open-ended",
      "estimatedTime": 180
    },
    {
      "id": "node-fundamentals-q20",
      "question": "What tools and practices are essential for production deployment of Node.js applications?",
      "topic": "DevOps",
      "difficulty": "Advanced",
      "choices": [
        "Process managers, monitoring, logging, and containerization",
        "Only Docker containers",
        "Just environment variables",
        "Basic server setup is sufficient"
      ],
      "correctIndex": 0,
      "explanation": "Essential tools and practices include: process managers (PM2, cluster), comprehensive monitoring (Prometheus, New Relic), structured logging (Winston), containerization (Docker), CI/CD pipelines, health checks, graceful shutdowns, security headers, and load balancing. These ensure reliability, scalability, and maintainability in production.",
      "industryContext": "Production deployment requires robust DevOps practices to ensure application reliability and performance.",
      "tags": [
        "DevOps",
        "advanced",
        "node"
      ],
      "questionType": "multiple-choice",
      "estimatedTime": 120
    }
  ],
  "metadata": {
    "migrated": true,
    "originalQuestionCount": 15,
    "migrationDate": "2025-10-01T06:41:13.484Z",
    "lastUpdated": "2025-10-01T06:41:13.484Z",
    "version": "1.0.0"
  }
}