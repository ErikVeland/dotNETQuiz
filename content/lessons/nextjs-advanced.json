[
  {
    "id": "nextjs-advanced-lesson-1",
    "moduleSlug": "nextjs-advanced",
    "title": "Next.js Fundamentals and Setup",
    "order": 1,
    "objectives": [
      "Understand Next.js architecture and benefits",
      "Set up a Next.js development environment",
      "Create your first Next.js application"
    ],
    "intro": "Welcome to Next.js Full-Stack Framework - the most powerful React framework for production.\n\nNext.js is a React framework that gives you building blocks to create web applications. By framework, we mean Next.js handles the tooling and configuration needed for React, and provides additional structure, features, and optimizations for your application.\n\nThroughout this lesson, you'll gain hands-on experience with setting up Next.js projects and understanding its core concepts. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to introduce you to the Next.js ecosystem while showing you practical techniques that will enhance your development skills. By the end, you'll have a solid understanding of Next.js fundamentals and be ready to tackle more advanced topics.",
    "code": {
      "example": "// Creating a Next.js app\nnpx create-next-app@latest my-nextjs-app\ncd my-nextjs-app\nnpm run dev\n\n// Basic page structure\n// pages/index.js\nimport Head from 'next/head'\n\nexport default function Home() {\n  return (\n    <div>\n      <Head>\n        <title>My Next.js App</title>\n        <meta name=\"description\" content=\"Generated by create next app\" />\n      </Head>\n      <main>\n        <h1>Welcome to Next.js!</h1>\n        <p>The React Framework for Production</p>\n      </main>\n    </div>\n  )\n}",
      "explanation": "This example creates a basic Next.js application with proper SEO setup using the Head component. The create-next-app command sets up a complete development environment with all necessary configurations.\n\nKey features demonstrated:\n- Zero-config setup with create-next-app\n- Built-in Head component for SEO\n- File-based routing system\n- Hot reloading in development",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Not using the Head component for SEO",
        "solution": "Always include proper meta tags using next/head",
        "severity": "medium"
      },
      {
        "mistake": "Placing components in the wrong directory",
        "solution": "Use pages/ for routes, components/ for reusable components",
        "severity": "low"
      }
    ],
    "exercises": [
      {
        "title": "Practice: Create Your First Next.js App",
        "description": "Set up a new Next.js project and create a custom homepage",
        "checkpoints": [
          "Install Next.js using create-next-app",
          "Modify the homepage with custom content",
          "Add proper SEO meta tags"
        ]
      }
    ],
    "next": ["nextjs-advanced-lesson-2"],
    "estimatedMinutes": 30,
    "difficulty": "Beginner",
    "tags": ["Next.js", "Setup", "React", "SSR"],
    "lastUpdated": "2025-10-01T12:00:00.000Z",
    "version": "1.0.0"
  },
  {
    "id": "nextjs-advanced-lesson-2",
    "moduleSlug": "nextjs-advanced",
    "title": "File-based Routing System",
    "order": 2,
    "objectives": [
      "Master Next.js file-based routing",
      "Implement dynamic routes and nested routing",
      "Use programmatic navigation"
    ],
    "intro": "Next.js has a file-system based router built on the concept of pages. When a file is added to the pages directory, it's automatically available as a route.\n\nThis powerful routing system eliminates the need for complex routing configurations while providing advanced features like dynamic routes, nested routing, and automatic code splitting.\n\nIn this lesson, you'll learn how to leverage Next.js routing to build scalable application structures with clean URLs and optimized performance.",
    "code": {
      "example": "// Static routes\n// pages/about.js -> /about\n// pages/blog/index.js -> /blog\n// pages/blog/first-post.js -> /blog/first-post\n\n// Dynamic routes\n// pages/posts/[id].js -> /posts/1, /posts/abc, etc.\nexport default function Post({ post }) {\n  return (\n    <div>\n      <h1>{post.title}</h1>\n      <p>{post.content}</p>\n    </div>\n  )\n}\n\nexport async function getStaticPaths() {\n  return {\n    paths: [\n      { params: { id: '1' } },\n      { params: { id: '2' } }\n    ],\n    fallback: false\n  }\n}\n\nexport async function getStaticProps({ params }) {\n  const post = await fetchPost(params.id)\n  return {\n    props: { post }\n  }\n}\n\n// Programmatic navigation\nimport { useRouter } from 'next/router'\n\nfunction HomePage() {\n  const router = useRouter()\n  \n  const handleClick = () => {\n    router.push('/about')\n  }\n  \n  return <button onClick={handleClick}>Go to About</button>\n}",
      "explanation": "This example demonstrates Next.js routing patterns:\n\n1. Static routes: Simple file-to-route mapping\n2. Dynamic routes: Using [id].js for variable segments\n3. Data fetching: getStaticPaths and getStaticProps for static generation\n4. Programmatic navigation: useRouter hook for navigation\n\nNext.js automatically code-splits each page, loading only what's needed.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Not handling fallback cases in dynamic routes",
        "solution": "Always configure fallback behavior in getStaticPaths",
        "severity": "high"
      },
      {
        "mistake": "Using client-side only navigation for SEO-critical pages",
        "solution": "Use Link component for SEO-friendly navigation",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "Practice: Build a Blog with Dynamic Routes",
        "description": "Create a blog structure with dynamic post routes",
        "checkpoints": [
          "Create static pages (about, contact)",
          "Implement dynamic post routes [slug].js",
          "Add navigation between pages"
        ]
      }
    ],
    "next": ["nextjs-advanced-lesson-3"],
    "estimatedMinutes": 35,
    "difficulty": "Intermediate",
    "tags": ["Routing", "Dynamic Routes", "Navigation"],
    "lastUpdated": "2025-10-01T12:00:00.000Z",
    "version": "1.0.0"
  },
  {
    "id": "nextjs-advanced-lesson-3",
    "moduleSlug": "nextjs-advanced",
    "title": "Server-Side Rendering (SSR)",
    "order": 3,
    "objectives": [
      "Understand SSR concepts and benefits",
      "Implement getServerSideProps for dynamic data",
      "Optimize SSR performance"
    ],
    "intro": "Server-Side Rendering (SSR) is one of Next.js's most powerful features, allowing you to render pages on the server for each request.\n\nSSR provides excellent SEO, faster initial page loads, and better user experience, especially for content that changes frequently or requires authentication.\n\nIn this lesson, you'll learn when and how to use SSR effectively in your Next.js applications.",
    "code": {
      "example": "// SSR with getServerSideProps\n// pages/products/[id].js\nimport { GetServerSideProps } from 'next'\n\ninterface Product {\n  id: string\n  name: string\n  price: number\n  description: string\n}\n\ninterface Props {\n  product: Product\n  userAgent: string\n}\n\nexport default function ProductPage({ product, userAgent }: Props) {\n  return (\n    <div>\n      <h1>{product.name}</h1>\n      <p>Price: ${product.price}</p>\n      <p>{product.description}</p>\n      <small>Viewed on: {userAgent}</small>\n    </div>\n  )\n}\n\nexport const getServerSideProps: GetServerSideProps = async (context) => {\n  const { params, req, res, query } = context\n  \n  // Fetch data from API or database\n  const product = await fetch(`https://api.example.com/products/${params?.id}`)\n    .then(res => res.json())\n  \n  // Access request headers\n  const userAgent = req.headers['user-agent'] || ''\n  \n  // Handle not found\n  if (!product) {\n    return {\n      notFound: true\n    }\n  }\n  \n  // Redirect if needed\n  if (product.discontinued) {\n    return {\n      redirect: {\n        destination: '/products',\n        permanent: false\n      }\n    }\n  }\n  \n  return {\n    props: {\n      product,\n      userAgent\n    }\n  }\n}",
      "explanation": "This example shows comprehensive SSR implementation:\n\n1. getServerSideProps runs on every request\n2. Access to request/response objects\n3. Data fetching on the server\n4. Error handling with notFound\n5. Conditional redirects\n6. TypeScript support\n\nThe page is fully rendered on the server before being sent to the client.",
      "language": "typescript"
    },
    "pitfalls": [
      {
        "mistake": "Using SSR for static content",
        "solution": "Use SSG (getStaticProps) for content that doesn't change often",
        "severity": "medium"
      },
      {
        "mistake": "Not handling errors in getServerSideProps",
        "solution": "Always implement proper error handling and fallbacks",
        "severity": "high"
      }
    ],
    "exercises": [
      {
        "title": "Practice: Build a Product Catalog with SSR",
        "description": "Create a product page that fetches data server-side",
        "checkpoints": [
          "Implement getServerSideProps",
          "Handle loading states and errors",
          "Add proper TypeScript types"
        ]
      }
    ],
    "next": ["nextjs-advanced-lesson-4"],
    "estimatedMinutes": 40,
    "difficulty": "Advanced",
    "tags": ["SSR", "getServerSideProps", "Performance"],
    "lastUpdated": "2025-10-01T12:00:00.000Z",
    "version": "1.0.0"
  },
  {
    "id": "nextjs-advanced-lesson-4",
    "moduleSlug": "nextjs-advanced",
    "title": "Static Site Generation (SSG)",
    "order": 4,
    "objectives": [
      "Master Static Site Generation concepts",
      "Implement getStaticProps and getStaticPaths",
      "Understand Incremental Static Regeneration"
    ],
    "intro": "Static Site Generation (SSG) is Next.js's method for pre-rendering pages at build time, resulting in blazing-fast websites with excellent SEO.\n\nSSG is perfect for content that doesn't change frequently, providing the best performance while maintaining the flexibility of dynamic content through Incremental Static Regeneration (ISR).",
    "code": {
      "example": "// SSG with getStaticProps\n// pages/blog/[slug].js\nexport default function BlogPost({ post, relatedPosts }) {\n  return (\n    <article>\n      <h1>{post.title}</h1>\n      <p>{post.excerpt}</p>\n      <div dangerouslySetInnerHTML={{ __html: post.content }} />\n      \n      <aside>\n        <h3>Related Posts</h3>\n        {relatedPosts.map(post => (\n          <Link key={post.slug} href={`/blog/${post.slug}`}>\n            <a>{post.title}</a>\n          </Link>\n        ))}\n      </aside>\n    </article>\n  )\n}\n\n// Generate static paths at build time\nexport async function getStaticPaths() {\n  const posts = await getAllPosts()\n  \n  const paths = posts.map(post => ({\n    params: { slug: post.slug }\n  }))\n  \n  return {\n    paths,\n    fallback: 'blocking' // Enable ISR for new posts\n  }\n}\n\n// Fetch data at build time\nexport async function getStaticProps({ params }) {\n  const post = await getPostBySlug(params.slug)\n  const relatedPosts = await getRelatedPosts(post.tags)\n  \n  if (!post) {\n    return { notFound: true }\n  }\n  \n  return {\n    props: {\n      post,\n      relatedPosts\n    },\n    revalidate: 3600 // Revalidate every hour (ISR)\n  }\n}\n\n// Incremental Static Regeneration example\n// pages/products.js\nexport async function getStaticProps() {\n  const products = await fetchProducts()\n  \n  return {\n    props: { products },\n    revalidate: 10 // Regenerate page every 10 seconds if requested\n  }\n}",
      "explanation": "This example demonstrates advanced SSG patterns:\n\n1. getStaticPaths: Defines which dynamic routes to pre-render\n2. fallback: 'blocking': Enables ISR for new content\n3. getStaticProps: Fetches data at build time\n4. revalidate: Enables ISR with time-based regeneration\n5. Related content: Shows how to fetch additional data\n\nThe result is lightning-fast pages that can still update dynamically.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Not setting appropriate revalidate intervals",
        "solution": "Choose revalidate times based on content update frequency",
        "severity": "medium"
      },
      {
        "mistake": "Using fallback: false for large datasets",
        "solution": "Use fallback: 'blocking' or true for scalability",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "Practice: Build a Static Blog with ISR",
        "description": "Create a blog that updates automatically with ISR",
        "checkpoints": [
          "Implement getStaticPaths for all posts",
          "Add ISR with appropriate revalidate timing",
          "Handle fallback states properly"
        ]
      }
    ],
    "next": ["nextjs-advanced-lesson-5"],
    "estimatedMinutes": 45,
    "difficulty": "Advanced",
    "tags": ["SSG", "ISR", "Performance", "getStaticProps"],
    "lastUpdated": "2025-10-01T12:00:00.000Z",
    "version": "1.0.0"
  },
  {
    "id": "nextjs-advanced-lesson-5",
    "moduleSlug": "nextjs-advanced",
    "title": "API Routes and Backend Integration",
    "order": 5,
    "objectives": [
      "Create and manage API routes in Next.js",
      "Implement authentication and middleware",
      "Connect to databases and external APIs"
    ],
    "intro": "Next.js API routes provide a simple solution to build your API with Next.js. Any file inside pages/api folder is mapped to /api/* and will be treated as an API endpoint instead of a page.\n\nThis feature allows you to build full-stack applications without needing a separate backend server, making deployment and development much simpler.",
    "code": {
      "example": "// pages/api/users/[id].js\nimport { NextApiRequest, NextApiResponse } from 'next'\nimport { connectToDatabase } from '../../../lib/mongodb'\nimport { verifyToken } from '../../../lib/auth'\n\nexport default async function handler(req: NextApiRequest, res: NextApiResponse) {\n  const { method, query: { id }, headers } = req\n  \n  // Verify authentication\n  const token = headers.authorization?.replace('Bearer ', '')\n  const user = await verifyToken(token)\n  \n  if (!user) {\n    return res.status(401).json({ error: 'Unauthorized' })\n  }\n  \n  const { db } = await connectToDatabase()\n  \n  switch (method) {\n    case 'GET':\n      try {\n        const userData = await db.collection('users').findOne({ _id: id })\n        if (!userData) {\n          return res.status(404).json({ error: 'User not found' })\n        }\n        res.status(200).json(userData)\n      } catch (error) {\n        res.status(500).json({ error: 'Failed to fetch user' })\n      }\n      break\n      \n    case 'PUT':\n      try {\n        const { name, email } = req.body\n        const result = await db.collection('users').updateOne(\n          { _id: id },\n          { $set: { name, email, updatedAt: new Date() } }\n        )\n        res.status(200).json({ message: 'User updated successfully' })\n      } catch (error) {\n        res.status(500).json({ error: 'Failed to update user' })\n      }\n      break\n      \n    case 'DELETE':\n      try {\n        await db.collection('users').deleteOne({ _id: id })\n        res.status(200).json({ message: 'User deleted successfully' })\n      } catch (error) {\n        res.status(500).json({ error: 'Failed to delete user' })\n      }\n      break\n      \n    default:\n      res.setHeader('Allow', ['GET', 'PUT', 'DELETE'])\n      res.status(405).end(`Method ${method} Not Allowed`)\n  }\n}\n\n// pages/api/auth/login.js\nexport default async function handler(req, res) {\n  if (req.method !== 'POST') {\n    return res.status(405).json({ error: 'Method not allowed' })\n  }\n  \n  const { email, password } = req.body\n  \n  try {\n    const user = await authenticateUser(email, password)\n    const token = generateJWT(user)\n    \n    // Set HTTP-only cookie\n    res.setHeader('Set-Cookie', `token=${token}; HttpOnly; Secure; SameSite=Strict; Path=/`)\n    \n    res.status(200).json({ user: { id: user.id, email: user.email } })\n  } catch (error) {\n    res.status(401).json({ error: 'Invalid credentials' })\n  }\n}",
      "explanation": "This example shows comprehensive API route implementation:\n\n1. Dynamic routes: [id].js for parameterized endpoints\n2. HTTP method handling: GET, PUT, DELETE\n3. Authentication: Token verification\n4. Database integration: MongoDB connection\n5. Error handling: Proper status codes and messages\n6. Security: HttpOnly cookies, input validation\n\nAPI routes run on the server and can access databases directly.",
      "language": "typescript"
    },
    "pitfalls": [
      {
        "mistake": "Not validating input data",
        "solution": "Always validate and sanitize user input",
        "severity": "high"
      },
      {
        "mistake": "Exposing sensitive data in API responses",
        "solution": "Filter sensitive fields before sending responses",
        "severity": "high"
      }
    ],
    "exercises": [
      {
        "title": "Practice: Build a User Management API",
        "description": "Create CRUD operations for user management",
        "checkpoints": [
          "Implement all HTTP methods",
          "Add authentication middleware",
          "Connect to a database"
        ]
      }
    ],
    "next": ["nextjs-advanced-lesson-6"],
    "estimatedMinutes": 50,
    "difficulty": "Advanced",
    "tags": ["API Routes", "Backend", "Authentication", "Database"],
    "lastUpdated": "2025-10-01T12:00:00.000Z",
    "version": "1.0.0"
  },
  {
    "id": "nextjs-advanced-lesson-6",
    "moduleSlug": "nextjs-advanced",
    "title": "Image Optimization and Performance",
    "order": 6,
    "objectives": [
      "Master Next.js Image component",
      "Implement lazy loading and optimization",
      "Optimize Core Web Vitals"
    ],
    "intro": "Next.js provides automatic image optimization through the built-in Image component, which includes lazy loading, responsive images, and modern format serving.\n\nImage optimization is crucial for web performance and user experience, especially on mobile devices and slow connections.",
    "code": {
      "example": "import Image from 'next/image'\nimport profilePic from '../public/profile.jpg'\n\n// Basic usage\nexport default function Profile() {\n  return (\n    <div>\n      <Image\n        src={profilePic}\n        alt=\"Picture of the author\"\n        width={500}\n        height={500}\n        priority // Load immediately\n      />\n    </div>\n  )\n}\n\n// Remote images with domains configuration\n// next.config.js\nmodule.exports = {\n  images: {\n    domains: ['example.com', 'cdn.example.com'],\n    deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840],\n    imageSizes: [16, 32, 48, 64, 96, 128, 256, 384],\n    formats: ['image/webp', 'image/avif']\n  }\n}\n\n// Responsive images\nfunction ResponsiveImage() {\n  return (\n    <Image\n      src=\"/hero-image.jpg\"\n      alt=\"Hero image\"\n      fill\n      style={{\n        objectFit: 'cover'\n      }}\n      sizes=\"(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw\"\n    />\n  )\n}",
      "explanation": "Next.js Image optimization provides:\n\n1. Automatic format detection (WebP, AVIF)\n2. Responsive image serving\n3. Lazy loading by default\n4. Placeholder generation\n5. Size optimization\n\nThis dramatically improves Core Web Vitals scores.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Not specifying image dimensions",
        "solution": "Always provide width and height or use fill prop",
        "severity": "medium"
      },
      {
        "mistake": "Not configuring remote image domains",
        "solution": "Add all external domains to next.config.js",
        "severity": "high"
      }
    ],
    "exercises": [
      {
        "title": "Practice: Optimize a Photo Gallery",
        "description": "Build a responsive photo gallery with optimized images",
        "checkpoints": [
          "Implement Image component with proper sizing",
          "Add lazy loading and placeholders",
          "Configure remote image domains"
        ]
      }
    ],
    "next": ["nextjs-advanced-lesson-7"],
    "estimatedMinutes": 35,
    "difficulty": "Intermediate",
    "tags": ["Images", "Performance", "Optimization", "Core Web Vitals"],
    "lastUpdated": "2025-10-01T12:00:00.000Z",
    "version": "1.0.0"
  },
  {
    "id": "nextjs-advanced-lesson-7",
    "moduleSlug": "nextjs-advanced",
    "title": "Middleware and Edge Functions",
    "order": 7,
    "objectives": [
      "Implement Next.js middleware",
      "Handle authentication at the edge",
      "Optimize performance with edge computing"
    ],
    "intro": "Next.js Middleware allows you to run code before a request is completed. Based on the user's request, you can modify the response by rewriting, redirecting, modifying headers, or setting cookies.\n\nMiddleware runs at the Edge Runtime, providing exceptional performance for authentication, redirects, and request/response modifications.",
    "code": {
      "example": "// middleware.ts\nimport { NextRequest, NextResponse } from 'next/server'\nimport { verify } from 'jsonwebtoken'\n\nexport function middleware(request: NextRequest) {\n  const { pathname } = request.nextUrl\n  \n  // Skip middleware for public paths\n  if (pathname.startsWith('/api/auth') || pathname.startsWith('/_next')) {\n    return NextResponse.next()\n  }\n  \n  // Authentication check\n  const token = request.cookies.get('token')?.value\n  \n  if (pathname.startsWith('/dashboard')) {\n    if (!token) {\n      return NextResponse.redirect(new URL('/login', request.url))\n    }\n    \n    try {\n      verify(token, process.env.JWT_SECRET!)\n      return NextResponse.next()\n    } catch {\n      return NextResponse.redirect(new URL('/login', request.url))\n    }\n  }\n  \n  // A/B Testing\n  if (pathname === '/') {\n    const bucket = request.cookies.get('bucket')?.value\n    \n    if (!bucket) {\n      const newBucket = Math.random() < 0.5 ? 'A' : 'B'\n      const response = NextResponse.next()\n      response.cookies.set('bucket', newBucket)\n      \n      if (newBucket === 'B') {\n        return NextResponse.rewrite(new URL('/home-variant', request.url))\n      }\n    }\n  }\n  \n  // Geolocation redirect\n  const country = request.geo?.country || 'US'\n  if (pathname === '/store' && country === 'GB') {\n    return NextResponse.redirect(new URL('/store/uk', request.url))\n  }\n  \n  // Security headers\n  const response = NextResponse.next()\n  response.headers.set('X-Frame-Options', 'DENY')\n  response.headers.set('X-Content-Type-Options', 'nosniff')\n  \n  return response\n}\n\nexport const config = {\n  matcher: [\n    '/((?!api|_next/static|_next/image|favicon.ico).*)',\n  ]\n}",
      "explanation": "This middleware demonstrates:\n\n1. Authentication: Token verification and redirects\n2. A/B Testing: Random bucket assignment\n3. Geolocation: Country-based redirects\n4. Security: Adding security headers\n5. Performance: Running at the edge\n\nMiddleware runs before pages and API routes.",
      "language": "typescript"
    },
    "pitfalls": [
      {
        "mistake": "Running heavy computations in middleware",
        "solution": "Keep middleware lightweight for edge performance",
        "severity": "medium"
      },
      {
        "mistake": "Not configuring matcher correctly",
        "solution": "Use specific matchers to avoid unnecessary executions",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "Practice: Build Authentication Middleware",
        "description": "Create middleware for route protection and redirects",
        "checkpoints": [
          "Implement token verification",
          "Add protected route redirects",
          "Configure proper matchers"
        ]
      }
    ],
    "next": ["nextjs-advanced-lesson-8"],
    "estimatedMinutes": 40,
    "difficulty": "Advanced",
    "tags": ["Middleware", "Edge", "Authentication", "Performance"],
    "lastUpdated": "2025-10-01T12:00:00.000Z",
    "version": "1.0.0"
  },
  {
    "id": "nextjs-advanced-lesson-8",
    "moduleSlug": "nextjs-advanced",
    "title": "Advanced Data Fetching Patterns",
    "order": 8,
    "objectives": [
      "Master SWR and React Query integration",
      "Implement efficient caching strategies",
      "Handle complex data dependencies"
    ],
    "intro": "Advanced data fetching in Next.js goes beyond the built-in methods to include client-side libraries like SWR and React Query for sophisticated caching, revalidation, and state management.\n\nThese patterns are essential for building responsive, efficient applications that provide excellent user experience.",
    "code": {
      "example": "// Using SWR for client-side data fetching\nimport useSWR, { mutate } from 'swr'\nimport { useUser } from '../lib/auth'\n\nconst fetcher = (url: string) => fetch(url).then(r => r.json())\n\nfunction Profile() {\n  const { user } = useUser()\n  const { data, error, isLoading } = useSWR(\n    user ? `/api/user/${user.id}` : null,\n    fetcher,\n    {\n      refreshInterval: 30000, // Refresh every 30 seconds\n      revalidateOnFocus: true,\n      revalidateOnReconnect: true\n    }\n  )\n\n  if (error) return <div>Failed to load profile</div>\n  if (isLoading) return <div>Loading...</div>\n\n  return (\n    <div>\n      <h1>{data.name}</h1>\n      <p>{data.email}</p>\n      <button onClick={() => mutate(`/api/user/${user.id}`)}>\n        Refresh\n      </button>\n    </div>\n  )\n}\n\n// React Query with Next.js\nimport { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'\nimport { dehydrate, QueryClient } from '@tanstack/react-query'\n\nfunction PostsList() {\n  const queryClient = useQueryClient()\n  \n  const { data: posts, isLoading } = useQuery({\n    queryKey: ['posts'],\n    queryFn: () => fetch('/api/posts').then(res => res.json()),\n    staleTime: 5 * 60 * 1000, // 5 minutes\n  })\n\n  const deletePostMutation = useMutation({\n    mutationFn: (id: string) => fetch(`/api/posts/${id}`, { method: 'DELETE' }),\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: ['posts'] })\n    }\n  })\n\n  return (\n    <div>\n      {posts?.map(post => (\n        <div key={post.id}>\n          <h3>{post.title}</h3>\n          <button onClick={() => deletePostMutation.mutate(post.id)}>\n            Delete\n          </button>\n        </div>\n      ))}\n    </div>\n  )\n}\n\n// Server-side data prefetching\nexport async function getServerSideProps() {\n  const queryClient = new QueryClient()\n\n  await queryClient.prefetchQuery({\n    queryKey: ['posts'],\n    queryFn: () => fetch('http://localhost:3000/api/posts').then(res => res.json())\n  })\n\n  return {\n    props: {\n      dehydratedState: dehydrate(queryClient)\n    }\n  }\n}",
      "explanation": "Advanced data fetching patterns include:\n\n1. SWR: Automatic revalidation and caching\n2. React Query: Powerful state management for server state\n3. Optimistic updates: UI updates before server confirmation\n4. Background revalidation: Keep data fresh\n5. Server-side prefetching: Hydrate client cache\n\nThese patterns eliminate loading states and provide smooth UX.",
      "language": "typescript"
    },
    "pitfalls": [
      {
        "mistake": "Over-fetching data on every render",
        "solution": "Use proper cache keys and stale times",
        "severity": "medium"
      },
      {
        "mistake": "Not handling loading and error states",
        "solution": "Always provide fallbacks for loading and error states",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "Practice: Build a Real-time Dashboard",
        "description": "Create a dashboard with SWR and optimistic updates",
        "checkpoints": [
          "Implement SWR for data fetching",
          "Add optimistic updates for mutations",
          "Configure proper caching strategies"
        ]
      }
    ],
    "next": ["nextjs-advanced-lesson-9"],
    "estimatedMinutes": 45,
    "difficulty": "Advanced",
    "tags": ["SWR", "React Query", "Caching", "Data Fetching"],
    "lastUpdated": "2025-10-01T12:00:00.000Z",
    "version": "1.0.0"
  },
  {
    "id": "nextjs-advanced-lesson-9",
    "moduleSlug": "nextjs-advanced",
    "title": "Authentication and Security",
    "order": 9,
    "objectives": [
      "Implement NextAuth.js for authentication",
      "Secure API routes and pages",
      "Handle multiple authentication providers"
    ],
    "intro": "Authentication is a critical aspect of modern web applications. NextAuth.js provides a complete authentication solution for Next.js applications with support for multiple providers, sessions, and security best practices.",
    "code": {
      "example": "// pages/api/auth/[...nextauth].ts\nimport NextAuth from 'next-auth'\nimport GoogleProvider from 'next-auth/providers/google'\nimport CredentialsProvider from 'next-auth/providers/credentials'\nimport { MongoDBAdapter } from '@next-auth/mongodb-adapter'\nimport { MongoClient } from 'mongodb'\n\nconst client = new MongoClient(process.env.MONGODB_URI!)\nconst clientPromise = client.connect()\n\nexport default NextAuth({\n  adapter: MongoDBAdapter(clientPromise),\n  providers: [\n    GoogleProvider({\n      clientId: process.env.GOOGLE_CLIENT_ID!,\n      clientSecret: process.env.GOOGLE_CLIENT_SECRET!\n    }),\n    CredentialsProvider({\n      name: 'credentials',\n      credentials: {\n        email: { label: 'Email', type: 'email' },\n        password: { label: 'Password', type: 'password' }\n      },\n      async authorize(credentials) {\n        const user = await authenticateUser(credentials?.email, credentials?.password)\n        return user ? { id: user.id, email: user.email, name: user.name } : null\n      }\n    })\n  ],\n  callbacks: {\n    async jwt({ token, user }) {\n      if (user) {\n        token.role = user.role\n      }\n      return token\n    },\n    async session({ session, token }) {\n      session.user.role = token.role\n      return session\n    }\n  },\n  pages: {\n    signIn: '/auth/signin',\n    error: '/auth/error'\n  },\n  session: {\n    strategy: 'jwt',\n    maxAge: 30 * 24 * 60 * 60 // 30 days\n  }\n})\n\n// Using authentication in components\nimport { useSession, signIn, signOut } from 'next-auth/react'\n\nfunction LoginButton() {\n  const { data: session, status } = useSession()\n\n  if (status === 'loading') return <p>Loading...</p>\n\n  if (session) {\n    return (\n      <div>\n        <p>Signed in as {session.user?.email}</p>\n        <button onClick={() => signOut()}>Sign out</button>\n      </div>\n    )\n  }\n  \n  return (\n    <div>\n      <p>Not signed in</p>\n      <button onClick={() => signIn()}>Sign in</button>\n    </div>\n  )\n}\n\n// Protecting pages with getServerSideProps\nexport async function getServerSideProps(context) {\n  const session = await getSession(context)\n\n  if (!session) {\n    return {\n      redirect: {\n        destination: '/api/auth/signin',\n        permanent: false\n      }\n    }\n  }\n\n  return {\n    props: { session }\n  }\n}",
      "explanation": "NextAuth.js provides:\n\n1. Multiple authentication providers (Google, GitHub, etc.)\n2. Database adapters for session storage\n3. JWT and database sessions\n4. Custom authentication logic\n5. Role-based access control\n6. Secure session management\n\nThe solution handles all security concerns automatically.",
      "language": "typescript"
    },
    "pitfalls": [
      {
        "mistake": "Not securing API routes properly",
        "solution": "Always verify sessions in API routes",
        "severity": "high"
      },
      {
        "mistake": "Storing sensitive data in JWT tokens",
        "solution": "Keep JWTs minimal, store sensitive data in database",
        "severity": "high"
      }
    ],
    "exercises": [
      {
        "title": "Practice: Build Authentication System",
        "description": "Implement complete authentication with multiple providers",
        "checkpoints": [
          "Set up NextAuth.js with Google provider",
          "Add custom credentials provider",
          "Protect pages and API routes"
        ]
      }
    ],
    "next": ["nextjs-advanced-lesson-10"],
    "estimatedMinutes": 50,
    "difficulty": "Advanced",
    "tags": ["Authentication", "NextAuth", "Security", "JWT"],
    "lastUpdated": "2025-10-01T12:00:00.000Z",
    "version": "1.0.0"
  },
  {
    "id": "nextjs-advanced-lesson-10",
    "moduleSlug": "nextjs-advanced",
    "title": "Deployment and Production Optimization",
    "order": 10,
    "objectives": [
      "Deploy Next.js applications to various platforms",
      "Optimize for production performance",
      "Implement monitoring and analytics"
    ],
    "intro": "Deploying Next.js applications requires understanding of various hosting options, optimization techniques, and monitoring strategies to ensure optimal performance in production.",
    "code": {
      "example": "// next.config.js - Production optimization\nconst nextConfig = {\n  // Enable experimental features\n  experimental: {\n    appDir: true,\n    serverComponentsExternalPackages: ['mongoose']\n  },\n  \n  // Image optimization\n  images: {\n    domains: ['cdn.example.com'],\n    formats: ['image/webp', 'image/avif'],\n    minimumCacheTTL: 60\n  },\n  \n  // Compression and headers\n  compress: true,\n  poweredByHeader: false,\n  \n  // Custom headers for security\n  async headers() {\n    return [\n      {\n        source: '/(.*)',\n        headers: [\n          {\n            key: 'X-Frame-Options',\n            value: 'DENY'\n          },\n          {\n            key: 'X-Content-Type-Options',\n            value: 'nosniff'\n          },\n          {\n            key: 'Referrer-Policy',\n            value: 'origin-when-cross-origin'\n          }\n        ]\n      }\n    ]\n  },\n  \n  // Redirects for SEO\n  async redirects() {\n    return [\n      {\n        source: '/old-page',\n        destination: '/new-page',\n        permanent: true\n      }\n    ]\n  },\n  \n  // Bundle analyzer\n  webpack: (config, { isServer }) => {\n    if (!isServer) {\n      config.resolve.fallback = {\n        fs: false,\n        net: false,\n        tls: false\n      }\n    }\n    return config\n  }\n}\n\nmodule.exports = nextConfig\n\n// Vercel deployment configuration\n// vercel.json\n{\n  \"functions\": {\n    \"pages/api/**/*.js\": {\n      \"maxDuration\": 30\n    }\n  },\n  \"regions\": [\"iad1\"],\n  \"env\": {\n    \"NODE_ENV\": \"production\"\n  }\n}\n\n// Docker deployment\n# Dockerfile\nFROM node:18-alpine AS base\n\n# Install dependencies\nFROM base AS deps\nRUN apk add --no-cache libc6-compat\nWORKDIR /app\nCOPY package.json package-lock.json* ./\nRUN npm ci\n\n# Build application\nFROM base AS builder\nWORKDIR /app\nCOPY --from=deps /app/node_modules ./node_modules\nCOPY . .\nRUN npm run build\n\n# Production image\nFROM base AS runner\nWORKDIR /app\nENV NODE_ENV production\nRUN addgroup --system --gid 1001 nodejs\nRUN adduser --system --uid 1001 nextjs\n\nCOPY --from=builder /app/public ./public\nCOPY --from=builder --chown=nextjs:nodejs /app/.next/standalone ./\nCOPY --from=builder --chown=nextjs:nodejs /app/.next/static ./.next/static\n\nUSER nextjs\nEXPOSE 3000\nENV PORT 3000\nCMD [\"node\", \"server.js\"]",
      "explanation": "Production deployment involves:\n\n1. Configuration optimization: Compression, headers, security\n2. Platform-specific setup: Vercel, Docker, AWS\n3. Performance monitoring: Core Web Vitals, analytics\n4. Security hardening: Headers, environment variables\n5. CDN optimization: Static assets, images\n\nProper deployment ensures optimal performance and security.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Not optimizing for Core Web Vitals",
        "solution": "Use Lighthouse and optimize images, fonts, and loading",
        "severity": "medium"
      },
      {
        "mistake": "Exposing sensitive environment variables",
        "solution": "Use proper environment variable management",
        "severity": "high"
      }
    ],
    "exercises": [
      {
        "title": "Practice: Deploy to Production",
        "description": "Deploy a Next.js app with proper optimization",
        "checkpoints": [
          "Configure production settings",
          "Deploy to Vercel or Docker",
          "Set up monitoring and analytics"
        ]
      }
    ],
    "next": ["nextjs-advanced-lesson-11"],
    "estimatedMinutes": 45,
    "difficulty": "Advanced",
    "tags": ["Deployment", "Production", "Optimization", "Security"],
    "lastUpdated": "2025-10-01T12:00:00.000Z",
    "version": "1.0.0"
  },
  {
    "id": "nextjs-advanced-lesson-11",
    "moduleSlug": "nextjs-advanced",
    "title": "Testing Next.js Applications",
    "order": 11,
    "objectives": [
      "Implement unit testing for components and API routes",
      "Set up integration and E2E testing",
      "Test SSR and SSG functionality"
    ],
    "intro": "Testing Next.js applications requires understanding of different testing strategies for components, API routes, and the various rendering methods that Next.js provides.",
    "code": {
      "example": "// jest.config.js\nconst nextJest = require('next/jest')\n\nconst createJestConfig = nextJest({\n  dir: './'\n})\n\nconst customJestConfig = {\n  setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],\n  moduleNameMapping: {\n    '^@/components/(.*)$': '<rootDir>/components/$1',\n    '^@/pages/(.*)$': '<rootDir>/pages/$1'\n  },\n  testEnvironment: 'jest-environment-jsdom'\n}\n\nmodule.exports = createJestConfig(customJestConfig)\n\n// Component testing\nimport { render, screen, fireEvent } from '@testing-library/react'\nimport { SessionProvider } from 'next-auth/react'\nimport LoginForm from '../components/LoginForm'\n\nconst mockSession = {\n  user: { email: 'test@example.com' },\n  expires: '2024-01-01'\n}\n\ndescribe('LoginForm', () => {\n  it('renders login form correctly', () => {\n    render(\n      <SessionProvider session={null}>\n        <LoginForm />\n      </SessionProvider>\n    )\n    \n    expect(screen.getByLabelText(/email/i)).toBeInTheDocument()\n    expect(screen.getByLabelText(/password/i)).toBeInTheDocument()\n    expect(screen.getByRole('button', { name: /sign in/i })).toBeInTheDocument()\n  })\n  \n  it('handles form submission', async () => {\n    const mockSignIn = jest.fn()\n    jest.mock('next-auth/react', () => ({\n      ...jest.requireActual('next-auth/react'),\n      signIn: mockSignIn\n    }))\n    \n    render(<LoginForm />)\n    \n    fireEvent.change(screen.getByLabelText(/email/i), {\n      target: { value: 'test@example.com' }\n    })\n    fireEvent.change(screen.getByLabelText(/password/i), {\n      target: { value: 'password' }\n    })\n    fireEvent.click(screen.getByRole('button', { name: /sign in/i }))\n    \n    expect(mockSignIn).toHaveBeenCalledWith('credentials', {\n      email: 'test@example.com',\n      password: 'password'\n    })\n  })\n})\n\n// API route testing\nimport { createMocks } from 'node-mocks-http'\nimport handler from '../pages/api/users/[id]'\n\ndescribe('/api/users/[id]', () => {\n  it('returns user data for GET request', async () => {\n    const { req, res } = createMocks({\n      method: 'GET',\n      query: { id: '123' }\n    })\n    \n    await handler(req, res)\n    \n    expect(res._getStatusCode()).toBe(200)\n    const data = JSON.parse(res._getData())\n    expect(data).toHaveProperty('id', '123')\n  })\n  \n  it('returns 404 for non-existent user', async () => {\n    const { req, res } = createMocks({\n      method: 'GET',\n      query: { id: 'non-existent' }\n    })\n    \n    await handler(req, res)\n    \n    expect(res._getStatusCode()).toBe(404)\n  })\n})\n\n// E2E testing with Playwright\nimport { test, expect } from '@playwright/test'\n\ntest.describe('Authentication Flow', () => {\n  test('should login and access protected page', async ({ page }) => {\n    await page.goto('/login')\n    \n    await page.fill('[data-testid=email]', 'test@example.com')\n    await page.fill('[data-testid=password]', 'password')\n    await page.click('[data-testid=submit]')\n    \n    await expect(page).toHaveURL('/dashboard')\n    await expect(page.locator('h1')).toContainText('Dashboard')\n  })\n  \n  test('should redirect to login when accessing protected page', async ({ page }) => {\n    await page.goto('/dashboard')\n    await expect(page).toHaveURL('/login')\n  })\n})",
      "explanation": "Next.js testing covers:\n\n1. Unit tests: Components and utilities\n2. Integration tests: API routes and data fetching\n3. E2E tests: Full user workflows\n4. SSR/SSG testing: Server-side functionality\n5. Mock strategies: External dependencies\n\nProper testing ensures application reliability and maintainability.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Not testing server-side functionality",
        "solution": "Test API routes and SSR/SSG functions separately",
        "severity": "medium"
      },
      {
        "mistake": "Not mocking external dependencies",
        "solution": "Mock APIs, databases, and third-party services",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "Practice: Comprehensive Test Suite",
        "description": "Build a complete testing setup for a Next.js app",
        "checkpoints": [
          "Set up Jest and Testing Library",
          "Write component and API tests",
          "Add E2E tests with Playwright"
        ]
      }
    ],
    "next": ["nextjs-advanced-lesson-12"],
    "estimatedMinutes": 50,
    "difficulty": "Advanced",
    "tags": ["Testing", "Jest", "Playwright", "E2E"],
    "lastUpdated": "2025-10-01T12:00:00.000Z",
    "version": "1.0.0"
  },
  {
    "id": "nextjs-advanced-lesson-12",
    "moduleSlug": "nextjs-advanced",
    "title": "Advanced Next.js Patterns and Best Practices",
    "order": 12,
    "objectives": [
      "Implement advanced architectural patterns",
      "Optimize performance with advanced techniques",
      "Follow Next.js best practices for enterprise applications"
    ],
    "intro": "This final lesson covers advanced patterns, architectural decisions, and best practices for building large-scale Next.js applications in enterprise environments.",
    "code": {
      "example": "// Advanced error boundary with Next.js\nimport { ErrorBoundary } from 'react-error-boundary'\nimport { useRouter } from 'next/router'\n\nfunction ErrorFallback({ error, resetErrorBoundary }) {\n  const router = useRouter()\n  \n  return (\n    <div role=\"alert\" className=\"error-boundary\">\n      <h2>Something went wrong</h2>\n      <pre>{error.message}</pre>\n      <button onClick={resetErrorBoundary}>Try again</button>\n      <button onClick={() => router.push('/')}>Go home</button>\n    </div>\n  )\n}\n\n// Higher-order component for error boundaries\nexport function withErrorBoundary<T>(Component: React.ComponentType<T>) {\n  return function WrappedComponent(props: T) {\n    return (\n      <ErrorBoundary\n        FallbackComponent={ErrorFallback}\n        onError={(error, errorInfo) => {\n          console.error('Error boundary caught an error:', error, errorInfo)\n          // Send to error reporting service\n        }}\n      >\n        <Component {...props} />\n      </ErrorBoundary>\n    )\n  }\n}\n\n// Advanced layout pattern\ntype LayoutProps = {\n  children: React.ReactNode\n  title?: string\n  description?: string\n}\n\nexport function AppLayout({ children, title, description }: LayoutProps) {\n  return (\n    <>\n      <Head>\n        <title>{title ? `${title} | MyApp` : 'MyApp'}</title>\n        <meta name=\"description\" content={description || 'Default description'} />\n      </Head>\n      <Header />\n      <main className=\"min-h-screen\">\n        {children}\n      </main>\n      <Footer />\n    </>\n  )\n}\n\n// Page with layout\nconst AboutPage = () => {\n  return (\n    <AppLayout title=\"About\" description=\"Learn about our company\">\n      <div>About content</div>\n    </AppLayout>\n  )\n}\n\n// Performance optimization with React.memo and useMemo\nimport { memo, useMemo } from 'react'\n\ninterface ProductListProps {\n  products: Product[]\n  filters: FilterState\n}\n\nconst ProductList = memo(({ products, filters }: ProductListProps) => {\n  const filteredProducts = useMemo(() => {\n    return products.filter(product => {\n      return (!filters.category || product.category === filters.category) &&\n             (!filters.priceRange || isInPriceRange(product.price, filters.priceRange))\n    })\n  }, [products, filters])\n  \n  return (\n    <div className=\"grid grid-cols-1 md:grid-cols-3 gap-4\">\n      {filteredProducts.map(product => (\n        <ProductCard key={product.id} product={product} />\n      ))}\n    </div>\n  )\n})\n\n// Custom hook for data management\nfunction useProductData(initialFilters: FilterState) {\n  const [filters, setFilters] = useState(initialFilters)\n  const [isLoading, setIsLoading] = useState(false)\n  \n  const { data: products, error } = useSWR(\n    ['products', filters],\n    ([_, filters]) => fetchProducts(filters),\n    {\n      revalidateOnFocus: false,\n      dedupingInterval: 10000\n    }\n  )\n  \n  const updateFilters = useCallback((newFilters: Partial<FilterState>) => {\n    setFilters(prev => ({ ...prev, ...newFilters }))\n  }, [])\n  \n  return {\n    products: products || [],\n    filters,\n    updateFilters,\n    isLoading,\n    error\n  }\n}",
      "explanation": "Advanced Next.js patterns include:\n\n1. Error boundaries: Graceful error handling\n2. Layout patterns: Reusable page structures\n3. Performance optimization: Memoization and code splitting\n4. Custom hooks: Reusable state logic\n5. TypeScript integration: Type safety\n6. Error reporting: Production monitoring\n\nThese patterns ensure maintainable, scalable applications.",
      "language": "typescript"
    },
    "pitfalls": [
      {
        "mistake": "Over-optimizing with useMemo and useCallback",
        "solution": "Profile before optimizing, focus on actual bottlenecks",
        "severity": "low"
      },
      {
        "mistake": "Not implementing proper error boundaries",
        "solution": "Add error boundaries at appropriate component levels",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "Practice: Enterprise-Ready Application",
        "description": "Build a scalable Next.js application with all best practices",
        "checkpoints": [
          "Implement error boundaries and error handling",
          "Create reusable layout patterns",
          "Add performance optimizations"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 55,
    "difficulty": "Advanced",
    "tags": ["Architecture", "Performance", "Best Practices", "Enterprise"],
    "lastUpdated": "2025-10-01T12:00:00.000Z",
    "version": "1.0.0"
  },
  {
    "id": "nextjs-advanced-lesson-13",
    "moduleSlug": "nextjs-advanced",
    "title": "Real-time Features with WebSockets",
    "order": 13,
    "objectives": [
      "Implement WebSocket connections in Next.js applications",
      "Build real-time chat and notification systems",
      "Handle connection states and error recovery"
    ],
    "intro": "Real-time features are essential for modern web applications, from live chat systems to collaborative editing and real-time notifications. Next.js provides excellent support for WebSocket integration through API routes and custom server configurations.\n\nWebSockets enable bidirectional communication between the client and server, allowing for instant updates and interactive experiences that keep users engaged. This is particularly important for applications like social media platforms, trading dashboards, collaborative tools, and gaming applications.\n\nIn this comprehensive lesson, you'll learn to implement robust WebSocket solutions that handle connection management, error recovery, and state synchronization. We'll explore both simple implementations using socket.io and advanced patterns for scaling real-time features in production environments.\n\nBy the end of this lesson, you'll be equipped to build sophisticated real-time applications that provide seamless user experiences and maintain reliable connections even in challenging network conditions.",
    "code": {
      "example": "// Custom server with Socket.io\n// server.js\nconst express = require('express')\nconst next = require('next')\nconst { createServer } = require('http')\nconst { Server } = require('socket.io')\n\nconst dev = process.env.NODE_ENV !== 'production'\nconst app = next({ dev })\nconst handle = app.getRequestHandler()\n\napp.prepare().then(() => {\n  const server = express()\n  const httpServer = createServer(server)\n  const io = new Server(httpServer, {\n    cors: {\n      origin: process.env.CORS_ORIGIN || 'http://localhost:3000',\n      methods: ['GET', 'POST']\n    }\n  })\n\n  // Socket.io connection handling\n  io.on('connection', (socket) => {\n    console.log('User connected:', socket.id)\n\n    // Join user to specific rooms\n    socket.on('join-room', (roomId) => {\n      socket.join(roomId)\n      socket.to(roomId).emit('user-joined', {\n        userId: socket.id,\n        timestamp: new Date().toISOString()\n      })\n    })\n\n    // Handle chat messages\n    socket.on('send-message', async (data) => {\n      const { roomId, message, userId } = data\n      \n      // Validate and sanitize message\n      if (!message || message.trim().length === 0) return\n      \n      const messageData = {\n        id: Date.now().toString(),\n        message: message.trim(),\n        userId,\n        timestamp: new Date().toISOString()\n      }\n      \n      // Save to database\n      await saveMessage(messageData)\n      \n      // Broadcast to room\n      io.to(roomId).emit('new-message', messageData)\n    })\n\n    // Handle typing indicators\n    socket.on('typing', (data) => {\n      socket.to(data.roomId).emit('user-typing', {\n        userId: socket.id,\n        isTyping: data.isTyping\n      })\n    })\n\n    // Handle disconnection\n    socket.on('disconnect', () => {\n      console.log('User disconnected:', socket.id)\n    })\n  })\n\n  server.all('*', (req, res) => {\n    return handle(req, res)\n  })\n\n  const PORT = process.env.PORT || 3000\n  httpServer.listen(PORT, () => {\n    console.log(`Server running on port ${PORT}`)\n  })\n})",
      "explanation": "This WebSocket implementation demonstrates real-time communication with Socket.io, including room management, message broadcasting, and connection handling for building interactive applications.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Not handling connection drops and reconnection",
        "solution": "Implement proper error handling and automatic reconnection logic",
        "severity": "high"
      },
      {
        "mistake": "Exposing sensitive data through WebSocket messages",
        "solution": "Always validate and sanitize data, implement proper authentication",
        "severity": "high"
      }
    ],
    "exercises": [
      {
        "title": "Build a Real-time Chat Application",
        "description": "Create a chat system with rooms, typing indicators, and message persistence",
        "checkpoints": [
          "Set up WebSocket server with Socket.io",
          "Implement real-time messaging",
          "Add typing indicators and user presence",
          "Handle connection states and errors"
        ]
      }
    ],
    "next": ["nextjs-advanced-lesson-14"],
    "estimatedMinutes": 60,
    "difficulty": "Advanced",
    "tags": ["WebSockets", "Real-time", "Socket.io", "Chat"],
    "lastUpdated": "2025-01-27T10:15:00.000Z",
    "version": "1.0.0"
  },
  {
    "id": "nextjs-advanced-lesson-14",
    "moduleSlug": "nextjs-advanced",
    "title": "Internationalization (i18n) and Localization",
    "order": 14,
    "objectives": [
      "Implement multi-language support in Next.js applications",
      "Handle locale-specific routing and content delivery",
      "Optimize SEO for international markets"
    ],
    "intro": "Internationalization (i18n) is crucial for reaching global audiences and providing localized experiences that resonate with users from different cultures and languages. Next.js provides built-in support for i18n routing and integrates seamlessly with popular translation libraries.\n\nBuilding multilingual applications involves more than just translating text - you need to consider cultural differences, number formatting, date formats, reading directions, and even color preferences. Next.js i18n features make it easier to create applications that truly serve international markets.\n\nThis lesson covers the complete implementation of i18n in Next.js applications, from basic text translation to advanced features like locale-specific SSG, SEO optimization for different markets, and dynamic content loading. You'll learn to build applications that automatically detect user preferences and provide seamless language switching.\n\nBy mastering i18n patterns, you'll be able to expand your applications to global markets while maintaining excellent performance and user experience across all supported locales.",
    "code": {
      "example": "// next.config.js - i18n configuration\nmodule.exports = {\n  i18n: {\n    locales: ['en', 'es', 'fr', 'de', 'ja'],\n    defaultLocale: 'en',\n    domains: [\n      {\n        domain: 'example.com',\n        defaultLocale: 'en'\n      },\n      {\n        domain: 'example.es',\n        defaultLocale: 'es'\n      }\n    ],\n    localeDetection: true\n  }\n}\n\n// Translation usage with react-i18next\nimport { useTranslation } from 'next-i18next'\nimport { serverSideTranslations } from 'next-i18next/serverSideTranslations'\n\nexport default function HomePage() {\n  const { t } = useTranslation('common')\n\n  return (\n    <div>\n      <h1>{t('welcome')}</h1>\n      <p>{t('description')}</p>\n    </div>\n  )\n}\n\nexport async function getStaticProps({ locale }) {\n  return {\n    props: {\n      ...(await serverSideTranslations(locale, ['common']))\n    }\n  }\n}",
      "explanation": "This i18n implementation shows Next.js built-in internationalization features with react-i18next for translations, locale routing, and server-side rendering support.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Not considering cultural differences beyond language",
        "solution": "Research cultural preferences for colors, layouts, and user interactions",
        "severity": "medium"
      },
      {
        "mistake": "Poor SEO implementation for international content",
        "solution": "Implement proper hreflang tags, canonical URLs, and localized meta data",
        "severity": "high"
      }
    ],
    "exercises": [
      {
        "title": "Build a Multilingual Website",
        "description": "Create a multi-language website with proper SEO and cultural adaptations",
        "checkpoints": [
          "Set up i18n configuration for multiple locales",
          "Implement translation files and components",
          "Add language switching functionality",
          "Optimize SEO for international markets"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 50,
    "difficulty": "Advanced",
    "tags": ["i18n", "Internationalization", "Localization", "SEO"],
    "lastUpdated": "2025-01-27T10:15:00.000Z",
    "version": "1.0.0"
  }
]