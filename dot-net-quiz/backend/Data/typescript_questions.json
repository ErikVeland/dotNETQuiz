[
  {
    "id": 1,
    "topic": "Basic Types",
    "type": "multiple-choice",
    "question": "How do you define a variable with an explicit type annotation in TypeScript?",
    "choices": [
      "let myVar: string = \"hello\"",
      "let myVar string = \"hello\"",
      "let myVar = string \"hello\"",
      "let myVar := string = \"hello\""
    ],
    "correctAnswer": 0,
    "explanation": "In TypeScript, type annotations are specified using a colon (:) after the variable name, followed by the type. This provides compile-time type checking and better tooling support."
  },
  {
    "id": 2,
    "topic": "Basic Types",
    "type": "multiple-choice",
    "question": "Which of the following is the correct way to define an array of strings?",
    "choices": [
      "let arr: string[] = ['a', 'b', 'c']",
      "let arr: Array<string> = ['a', 'b', 'c']",
      "Both A and B",
      "let arr: [string] = ['a', 'b', 'c']"
    ],
    "correctAnswer": 2,
    "explanation": "Both syntaxes are valid in TypeScript. You can use string[] (array literal syntax) or Array<string> (generic syntax) to define an array of strings. The array literal syntax is more common."
  },
  {
    "id": 3,
    "topic": "Interfaces",
    "type": "open-ended",
    "question": "What is the difference between an interface and a type alias in TypeScript? When would you use each?",
    "choices": null,
    "correctAnswer": null,
    "explanation": "Interfaces create a new name that can be used everywhere and can be extended and implemented. Type aliases don't create a new name and cannot be extended or implemented. Use interfaces for defining object shapes and type aliases for complex types like union types. Interfaces are preferred for object shapes because they support declaration merging."
  },
  {
    "id": 4,
    "topic": "Classes",
    "type": "multiple-choice",
    "question": "Which access modifier makes a property or method accessible only within the same class?",
    "choices": [
      "private",
      "protected",
      "public",
      "internal"
    ],
    "correctAnswer": 0,
    "explanation": "The private access modifier restricts access to the containing class only. Protected allows access in the containing class and subclasses, while public allows access from anywhere. TypeScript also supports # syntax for truly private fields."
  },
  {
    "id": 5,
    "topic": "Generics",
    "type": "multiple-choice",
    "question": "What is the purpose of generics in TypeScript?",
    "choices": [
      "To create reusable components that work with multiple types",
      "To enforce strict typing at runtime",
      "To automatically convert JavaScript to TypeScript",
      "To provide better IDE support"
    ],
    "correctAnswer": 0,
    "explanation": "Generics allow you to create reusable components that work with a variety of types rather than a single type, providing type safety while maintaining flexibility. They help catch type-related errors at compile time."
  },
  {
    "id": 6,
    "topic": "Type System",
    "type": "multiple-choice",
    "question": "What is the difference between 'any' and 'unknown' types in TypeScript?",
    "choices": [
      "'any' bypasses type checking, 'unknown' requires type checking before usage",
      "'unknown' bypasses type checking, 'any' requires type checking",
      "Both work exactly the same way",
      "'any' is for strings, 'unknown' is for numbers"
    ],
    "correctAnswer": 0,
    "explanation": "The 'any' type bypasses all type checking, essentially opting out of type safety. The 'unknown' type is safer - it requires type checking (narrowing) before you can perform operations on it. 'unknown' is the type-safe counterpart of 'any'."
  },
  {
    "id": 7,
    "topic": "Interfaces",
    "type": "open-ended",
    "question": "Explain the concept of 'declaration merging' in TypeScript and when it's useful.",
    "choices": null,
    "correctAnswer": null,
    "explanation": "Declaration merging allows TypeScript to combine multiple declarations with the same name into a single definition. This is particularly useful for interfaces, where multiple interface declarations with the same name are merged into one. It's commonly used to extend existing types or add properties to global objects without modifying the original definition."
  },
  {
    "id": 8,
    "topic": "Advanced Types",
    "type": "multiple-choice",
    "question": "What is a discriminated union in TypeScript?",
    "choices": [
      "A union type with a common field that can be used to narrow the type",
      "A union of string literals",
      "A union that can only contain primitive types",
      "A union that discriminates against certain types"
    ],
    "correctAnswer": 0,
    "explanation": "A discriminated union is a pattern where you use a union of types with a common literal type field (the discriminant) that allows TypeScript to narrow the type in switch statements or conditional checks. This provides type safety for working with variant data structures."
  }
]