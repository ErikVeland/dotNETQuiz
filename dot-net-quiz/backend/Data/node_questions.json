[
  {
    "id": 1,
    "topic": "Basics",
    "type": "multiple-choice",
    "question": "What is Node.js?",
    "choices": [
      "A JavaScript runtime built on Chrome's V8 JavaScript engine",
      "A CSS framework",
      "A database management system",
      "A front-end framework"
    ],
    "correctAnswer": 0,
    "explanation": "Node.js is a JavaScript runtime that allows you to run JavaScript on the server-side, built on Chrome's V8 JavaScript engine."
  },
  {
    "id": 2,
    "topic": "Basics",
    "type": "multiple-choice",
    "question": "How do you import a module in Node.js?",
    "choices": [
      "require()",
      "import",
      "include",
      "load"
    ],
    "correctAnswer": 0,
    "explanation": "In Node.js, modules are imported using the require() function. The import statement is used in ES6 modules."
  },
  {
    "id": 3,
    "topic": "Express",
    "type": "open-ended",
    "question": "What is Express.js and why is it used?",
    "choices": null,
    "correctAnswer": null,
    "explanation": "Express.js is a minimal and flexible Node.js web application framework that provides a robust set of features for web and mobile applications. It simplifies the process of building web servers and APIs by providing helpful utilities and middleware."
  },
  {
    "id": 4,
    "topic": "Express",
    "type": "multiple-choice",
    "question": "Which method is used to handle GET requests in Express?",
    "choices": [
      "app.get()",
      "app.post()",
      "app.put()",
      "app.delete()"
    ],
    "correctAnswer": 0,
    "explanation": "In Express.js, app.get() is used to define a route handler for GET requests."
  },
  {
    "id": 5,
    "topic": "Middleware",
    "type": "multiple-choice",
    "question": "What is middleware in Express.js?",
    "choices": [
      "Functions that have access to the request and response objects",
      "Database connection utilities",
      "Template engines",
      "Routing functions"
    ],
    "correctAnswer": 0,
    "explanation": "Middleware functions in Express.js are functions that have access to the request object, the response object, and the next middleware function in the application's request-response cycle."
  },
  {
    "id": 6,
    "topic": "Async",
    "type": "multiple-choice",
    "question": "How do you handle asynchronous operations in Node.js?",
    "choices": [
      "Using callbacks, promises, or async/await",
      "Using synchronous functions only",
      "Using threads",
      "Using global variables"
    ],
    "correctAnswer": 0,
    "explanation": "Node.js handles asynchronous operations using callbacks, promises, or the more modern async/await syntax."
  },
  {
    "id": 7,
    "topic": "NPM",
    "type": "open-ended",
    "question": "What is NPM and what is it used for?",
    "choices": null,
    "correctAnswer": null,
    "explanation": "NPM (Node Package Manager) is the default package manager for Node.js. It is used to install, share, and manage packages (libraries and tools) in Node.js projects. It also helps with dependency management and script execution."
  },
  {
    "id": 8,
    "topic": "Event Loop",
    "type": "multiple-choice",
    "question": "What is the event loop in Node.js?",
    "choices": [
      "A mechanism that handles asynchronous operations",
      "A loop that executes synchronous code",
      "A database query optimizer",
      "A memory management system"
    ],
    "correctAnswer": 0,
    "explanation": "The event loop in Node.js is a mechanism that handles asynchronous operations by continuously checking the call stack and callback queue to execute callbacks when the call stack is empty."
  },
  {
    "id": 9,
    "topic": "Async Programming",
    "type": "multiple-choice",
    "question": "What is the main advantage of using async/await over Promises in Node.js?",
    "choices": [
      "More readable and easier to debug synchronous-looking code",
      "Better performance than Promises",
      "Automatic error handling without try-catch",
      "Faster execution than callback functions"
    ],
    "correctAnswer": 0,
    "explanation": "Async/await provides more readable, synchronous-looking code that's easier to debug and maintain. While it doesn't improve performance over Promises (it's syntactic sugar over them), it makes error handling with try-catch more natural and reduces callback hell and Promise chaining complexity."
  },
  {
    "id": 10,
    "topic": "Performance",
    "type": "multiple-choice",
    "question": "What is clustering in Node.js and why is it useful?",
    "choices": [
      "Running multiple Node.js processes to utilize all CPU cores",
      "Grouping related modules together",
      "Connecting multiple databases",
      "Organizing code into clusters of functions"
    ],
    "correctAnswer": 0,
    "explanation": "Clustering in Node.js allows you to create multiple worker processes that share the same server port, enabling utilization of all CPU cores. Since Node.js is single-threaded, clustering helps improve performance for CPU-intensive applications by distributing the workload across multiple processes."
  },
  {
    "id": 11,
    "topic": "Security",
    "type": "open-ended",
    "question": "What are some essential security practices for Node.js applications?",
    "choices": null,
    "correctAnswer": null,
    "explanation": "Essential security practices include: using HTTPS everywhere, validating and sanitizing all input, implementing proper authentication and authorization, using helmet.js for security headers, rate limiting, keeping dependencies updated, using environment variables for secrets, implementing CSRF protection, using secure session management, and regular security audits with tools like npm audit."
  },
  {
    "id": 12,
    "topic": "Testing",
    "type": "multiple-choice",
    "question": "Which testing framework is most commonly used for Node.js applications?",
    "choices": [
      "Jest",
      "JUnit",
      "PHPUnit",
      "NUnit"
    ],
    "correctAnswer": 0,
    "explanation": "Jest is the most popular testing framework for Node.js applications. It provides a comprehensive testing solution with built-in test runner, assertion library, mocking capabilities, and code coverage reporting. Other popular options include Mocha and Chai, but Jest has gained widespread adoption due to its simplicity and feature completeness."
  },
  {
    "id": 13,
    "topic": "File System",
    "type": "multiple-choice",
    "question": "What is the difference between fs.readFile() and fs.readFileSync() in Node.js?",
    "choices": [
      "readFile() is asynchronous and non-blocking, readFileSync() is synchronous and blocking",
      "readFile() is faster than readFileSync()",
      "readFileSync() supports more file formats",
      "readFile() requires more memory than readFileSync()"
    ],
    "correctAnswer": 0,
    "explanation": "fs.readFile() is asynchronous and non-blocking, allowing other operations to continue while the file is being read. fs.readFileSync() is synchronous and blocks the event loop until the file reading is complete. The async version is preferred in production applications to maintain performance and responsiveness."
  },
  {
    "id": 14,
    "topic": "Error Handling",
    "type": "open-ended",
    "question": "How should you handle uncaught exceptions in Node.js applications?",
    "choices": null,
    "correctAnswer": null,
    "explanation": "Handle uncaught exceptions by: 1) Using process.on('uncaughtException') to log errors and gracefully shut down, 2) Using process.on('unhandledRejection') for unhandled Promise rejections, 3) Implementing proper error handling in all async operations, 4) Using try-catch blocks around critical code, 5) Using process managers like PM2 for automatic restarts, 6) Logging all errors for debugging. Never ignore uncaught exceptions as they can lead to memory leaks and unstable applications."
  },
  {
    "id": 15,
    "topic": "Streams",
    "type": "multiple-choice",
    "question": "What is the main advantage of using streams for processing large files in Node.js?",
    "choices": [
      "Memory efficient processing of data in chunks",
      "Faster file compression",
      "Better error handling",
      "Automatic file backup"
    ],
    "correctAnswer": 0,
    "explanation": "Streams allow memory-efficient processing of large files by reading and processing data in small chunks rather than loading the entire file into memory. This prevents memory overflow issues and enables processing of files larger than available RAM, making applications more scalable and efficient."
  }
]