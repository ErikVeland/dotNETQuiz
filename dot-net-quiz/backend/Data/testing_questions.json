[
  {
    "id": 1,
    "topic": "Testing Fundamentals",
    "type": "multiple-choice",
    "question": "What is the purpose of the testing pyramid?",
    "choices": [
      "To guide the distribution of different types of tests in a project",
      "To measure the performance of test execution",
      "To organize test files in a directory structure",
      "To prioritize bug fixes in software development"
    ],
    "correctAnswer": 0,
    "explanation": "The testing pyramid is a conceptual model that guides teams on how to distribute different types of tests. It suggests having many unit tests (fast and cheap), fewer integration tests, and even fewer end-to-end tests (slow and expensive). This distribution optimizes for fast feedback and cost-effectiveness."
  },
  {
    "id": 2,
    "topic": "Testing Fundamentals",
    "type": "multiple-choice",
    "question": "Which type of test typically runs the fastest?",
    "choices": [
      "Unit tests",
      "Integration tests",
      "End-to-end tests",
      "Manual tests"
    ],
    "correctAnswer": 0,
    "explanation": "Unit tests typically run the fastest because they test small units of code in isolation without external dependencies like databases or network calls. They're executed in memory and can run in milliseconds, making them ideal for continuous integration pipelines."
  },
  {
    "id": 3,
    "topic": "Unit Testing",
    "type": "open-ended",
    "question": "What is the difference between a mock and a stub in testing? When would you use each?",
    "choices": null,
    "correctAnswer": null,
    "explanation": "A stub provides canned answers to calls made during the test, usually not responding at all to anything outside what's programmed in for the test. A mock is a stub with added behavior verification - it knows what methods should be called and with what arguments, and can verify this during the test. Use stubs when you need to control indirect inputs, and mocks when you need to verify interactions between objects."
  },
  {
    "id": 4,
    "topic": "Integration Testing",
    "type": "multiple-choice",
    "question": "What is the main focus of integration testing?",
    "choices": [
      "Testing interactions between different modules or services",
      "Testing individual functions in isolation",
      "Testing the user interface",
      "Testing database performance"
    ],
    "correctAnswer": 0,
    "explanation": "Integration testing focuses on verifying the interactions between different modules, services, or components to ensure they work together correctly. This includes testing database connections, API integrations, and communication between different layers of an application."
  },
  {
    "id": 5,
    "topic": "End-to-End Testing",
    "type": "multiple-choice",
    "question": "What is a key advantage of end-to-end testing?",
    "choices": [
      "It tests the entire system from the user's perspective",
      "It runs faster than unit tests",
      "It's easier to maintain than other test types",
      "It provides detailed code coverage reports"
    ],
    "correctAnswer": 0,
    "explanation": "End-to-end testing validates the entire system workflow from the user's perspective, ensuring that all integrated components work together as expected in a production-like environment. This helps catch issues that might not be apparent in unit or integration tests."
  },
  {
    "id": 6,
    "topic": "Test Patterns",
    "type": "multiple-choice",
    "question": "What is the purpose of the Arrange-Act-Assert pattern in testing?",
    "choices": [
      "To structure tests in a clear, readable format",
      "To make tests run faster",
      "To reduce the number of test cases needed",
      "To eliminate the need for test documentation"
    ],
    "correctAnswer": 0,
    "explanation": "The Arrange-Act-Assert (AAA) pattern structures tests into three clear sections: Arrange (set up preconditions and inputs), Act (execute the code under test), and Assert (verify the outcomes). This pattern makes tests more readable, maintainable, and easier to debug."
  },
  {
    "id": 7,
    "topic": "Mocking",
    "type": "open-ended",
    "question": "What is test isolation and why is it important? How do you achieve it?",
    "choices": null,
    "correctAnswer": null,
    "explanation": "Test isolation means each test can run independently without being affected by other tests. It's important because it ensures tests are reliable, repeatable, and can be run in any order. You achieve it by using fresh test data for each test, mocking external dependencies, avoiding shared state between tests, and using setup/teardown methods to prepare and clean up the test environment."
  },
  {
    "id": 8,
    "topic": "Code Coverage",
    "type": "multiple-choice",
    "question": "What does code coverage measure and what are its limitations?",
    "choices": [
      "The percentage of code executed by tests, but doesn't measure test quality",
      "The number of bugs found in the code",
      "The speed of test execution",
      "The complexity of the code"
    ],
    "correctAnswer": 0,
    "explanation": "Code coverage measures the percentage of code executed by tests, including lines, branches, and functions. However, it doesn't measure test quality or correctness - 100% coverage doesn't guarantee bug-free code. Tests could execute all code paths but still have incorrect assertions. It's a useful metric for identifying untested code but shouldn't be the sole measure of test effectiveness."
  }
]