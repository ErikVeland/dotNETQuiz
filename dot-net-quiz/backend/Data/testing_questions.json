[
  {
    "id": 1,
    "topic": "Testing Fundamentals",
    "type": "multiple-choice",
    "question": "What is the purpose of the testing pyramid?",
    "choices": [
      "To guide the distribution of different types of tests in a project",
      "To measure the performance of test execution",
      "To organize test files in a directory structure",
      "To prioritize bug fixes in software development"
    ],
    "correctAnswer": 0,
    "explanation": "The testing pyramid is a conceptual model that guides teams on how to distribute different types of tests. It suggests having many unit tests (fast and cheap), fewer integration tests, and even fewer end-to-end tests (slow and expensive). This distribution optimizes for fast feedback and cost-effectiveness."
  },
  {
    "id": 2,
    "topic": "Testing Fundamentals",
    "type": "multiple-choice",
    "question": "Which type of test typically runs the fastest?",
    "choices": [
      "Unit tests",
      "Integration tests",
      "End-to-end tests",
      "Manual tests"
    ],
    "correctAnswer": 0,
    "explanation": "Unit tests typically run the fastest because they test small units of code in isolation without external dependencies like databases or network calls. They're executed in memory and can run in milliseconds, making them ideal for continuous integration pipelines."
  },
  {
    "id": 3,
    "topic": "Unit Testing",
    "type": "open-ended",
    "question": "What is the difference between a mock and a stub in testing? When would you use each?",
    "choices": null,
    "correctAnswer": null,
    "explanation": "A stub provides canned answers to calls made during the test, usually not responding at all to anything outside what's programmed in for the test. A mock is a stub with added behavior verification - it knows what methods should be called and with what arguments, and can verify this during the test. Use stubs when you need to control indirect inputs, and mocks when you need to verify interactions between objects."
  },
  {
    "id": 4,
    "topic": "Integration Testing",
    "type": "multiple-choice",
    "question": "What is the main focus of integration testing?",
    "choices": [
      "Testing interactions between different modules or services",
      "Testing individual functions in isolation",
      "Testing the user interface",
      "Testing database performance"
    ],
    "correctAnswer": 0,
    "explanation": "Integration testing focuses on verifying the interactions between different modules, services, or components to ensure they work together correctly. This includes testing database connections, API integrations, and communication between different layers of an application."
  },
  {
    "id": 5,
    "topic": "End-to-End Testing",
    "type": "multiple-choice",
    "question": "What is a key advantage of end-to-end testing?",
    "choices": [
      "It tests the entire system from the user's perspective",
      "It runs faster than unit tests",
      "It's easier to maintain than other test types",
      "It provides detailed code coverage reports"
    ],
    "correctAnswer": 0,
    "explanation": "End-to-end testing validates the entire system workflow from the user's perspective, ensuring that all integrated components work together as expected in a production-like environment. This helps catch issues that might not be apparent in unit or integration tests."
  },
  {
    "id": 6,
    "topic": "Test Patterns",
    "type": "multiple-choice",
    "question": "What is the purpose of the Arrange-Act-Assert pattern in testing?",
    "choices": [
      "To structure tests in a clear, readable format",
      "To make tests run faster",
      "To reduce the number of test cases needed",
      "To eliminate the need for test documentation"
    ],
    "correctAnswer": 0,
    "explanation": "The Arrange-Act-Assert (AAA) pattern structures tests into three clear sections: Arrange (set up preconditions and inputs), Act (execute the code under test), and Assert (verify the outcomes). This pattern makes tests more readable, maintainable, and easier to debug."
  },
  {
    "id": 7,
    "topic": "Mocking",
    "type": "open-ended",
    "question": "What is test isolation and why is it important? How do you achieve it?",
    "choices": null,
    "correctAnswer": null,
    "explanation": "Test isolation means each test can run independently without being affected by other tests. It's important because it ensures tests are reliable, repeatable, and can be run in any order. You achieve it by using fresh test data for each test, mocking external dependencies, avoiding shared state between tests, and using setup/teardown methods to prepare and clean up the test environment."
  },
  {
    "id": 8,
    "topic": "Code Coverage",
    "type": "multiple-choice",
    "question": "What does code coverage measure and what are its limitations?",
    "choices": [
      "The percentage of code executed by tests, but doesn't measure test quality",
      "The number of bugs found in the code",
      "The speed of test execution",
      "The complexity of the code"
    ],
    "correctAnswer": 0,
    "explanation": "Code coverage measures the percentage of code executed by tests, including lines, branches, and functions. However, it doesn't measure test quality or correctness - 100% coverage doesn't guarantee bug-free code. Tests could execute all code paths but still have incorrect assertions. It's a useful metric for identifying untested code but shouldn't be the sole measure of test effectiveness."
  },
  {
    "id": 9,
    "topic": "Test Types",
    "type": "multiple-choice",
    "question": "What is the testing pyramid?",
    "choices": ["More unit tests, fewer integration tests, fewest E2E tests", "Equal amounts of all test types", "More E2E tests than unit tests", "Only integration tests"],
    "correctAnswer": 0,
    "explanation": "The testing pyramid suggests having many fast, cheap unit tests at the base, fewer integration tests in the middle, and fewest expensive E2E tests at the top."
  },
  {
    "id": 10,
    "topic": "Mocking",
    "type": "multiple-choice",
    "question": "What is the difference between mocks, stubs, and spies?",
    "choices": ["Mocks verify behavior, stubs provide responses, spies record calls", "All are the same thing", "Mocks are fastest", "Stubs are most reliable"],
    "correctAnswer": 0,
    "explanation": "Mocks verify that specific methods were called with expected parameters. Stubs provide predetermined responses. Spies record information about function calls for later verification."
  },
  {
    "id": 11,
    "topic": "Coverage",
    "type": "open-ended",
    "question": "What are the different types of code coverage and what do they measure?",
    "choices": null,
    "correctAnswer": null,
    "explanation": "Line coverage: percentage of code lines executed. Branch coverage: percentage of code branches taken. Function coverage: percentage of functions called. Statement coverage: percentage of statements executed. Condition coverage: percentage of boolean conditions evaluated to both true and false."
  },
  {
    "id": 12,
    "topic": "Performance Testing",
    "type": "multiple-choice",
    "question": "What is load testing?",
    "choices": ["Testing system behavior under expected load conditions", "Testing code loading speed", "Testing database loads", "Testing file loading"],
    "correctAnswer": 0,
    "explanation": "Load testing evaluates system performance under expected user load to identify bottlenecks and ensure the application can handle normal traffic volumes."
  },
  {
    "id": 13,
    "topic": "TDD",
    "type": "multiple-choice",
    "question": "What is the TDD cycle?",
    "choices": ["Red, Green, Refactor", "Write, Test, Deploy", "Plan, Code, Test", "Design, Implement, Verify"],
    "correctAnswer": 0,
    "explanation": "TDD follows Red (write failing test), Green (make test pass with minimal code), Refactor (improve code while keeping tests passing) cycle."
  },
  {
    "id": 14,
    "topic": "API Testing",
    "type": "open-ended",
    "question": "What should you test when testing REST APIs?",
    "choices": null,
    "correctAnswer": null,
    "explanation": "Test: HTTP status codes, response data structure and content, request/response headers, authentication/authorization, input validation, error handling, performance under load, and edge cases like invalid data or missing parameters."
  },
  {
    "id": 15,
    "topic": "Best Practices",
    "type": "multiple-choice",
    "question": "What makes a good unit test?",
    "choices": ["Fast, isolated, repeatable, and focused on single behavior", "Complex and comprehensive", "Tests multiple functions at once", "Requires manual setup"],
    "correctAnswer": 0,
    "explanation": "Good unit tests are FIRST: Fast, Independent/Isolated, Repeatable, Self-validating, and Timely. They should test one specific behavior and be easy to understand and maintain."
  }
]