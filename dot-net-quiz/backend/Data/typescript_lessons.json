[
  {
    "id": 1,
    "topic": "Basic Types",
    "title": "Primitive Types and Type Annotations",
    "description": "Learn about TypeScript's primitive types including string, number, and boolean, along with advanced types like any, unknown, and never.",
    "codeExample": "// Primitive types with explicit annotations\nlet isDone: boolean = false\nlet decimal: number = 6\nlet hex: number = 0xf00d\nlet binary: number = 0b1010\nlet octal: number = 0o744\nlet color: string = \"blue\"\n\ncolor = 'red'  // Still valid\n\nlet fullName: string = `Bob Bobbington`\nlet sentence: string = `Hello, my name is ${fullName}`\n\n// Special types\nlet notSure: any = 4  // Can be anything (avoid when possible)\nnotSure = \"maybe a string instead\"\nnotSure = false\n\nlet uncertain: unknown = 4  // Safer than any\n// uncertain.toFixed(); // Error: Object is of type 'unknown'\nif (typeof uncertain === 'number') {\n  uncertain.toFixed()  // OK\n}\n\nfunction fail(): never {\n  throw new Error(\"Something failed\")\n}",
    "output": "Variables with explicit type annotations for various primitive types, demonstrating the difference between any and unknown"
  },
  {
    "id": 2,
    "topic": "Basic Types",
    "title": "Arrays, Tuples, and Enums",
    "description": "Learn how to work with arrays, tuples, and enums in TypeScript for more precise type safety.",
    "codeExample": "// Arrays\nlet list: number[] = [1, 2, 3]\nlet list2: Array<number> = [1, 2, 3]\n\n// Tuples - fixed-length arrays with known types\nlet x: [string, number]\nx = ['hello', 10]  // OK\n// x = [10, 'hello']  // Error\n\nconsole.log(x[0].substring(1))  // OK\n// console.log(x[1].substring(1))  // Error, 'number' does not have 'substring'\n\nx[3] = 'world'  // OK, 'string' can be assigned to (string | number)\nx[5] = 100  // OK, 'number' can be assigned to (string | number)\n// x[6] = true  // Error, 'boolean' isn't (string | number)\n\n// Enums\nenum Color { Red, Green, Blue }\nlet c: Color = Color.Green\n\nenum Color2 { Red = 1, Green, Blue }\nlet c2: Color2 = Color2.Green\n\nenum Color3 { Red = 1, Green = 2, Blue = 4 }\nlet c3: Color3 = Color3.Green\n\n// String enums\nenum Direction {\n  Up = \"UP\",\n  Down = \"DOWN\",\n  Left = \"LEFT\",\n  Right = \"RIGHT\",\n}",
    "output": "Type-safe arrays, tuples with fixed types, and enums for named constants"
  },
  {
    "id": 3,
    "topic": "Interfaces",
    "title": "Interface Declaration and Extension",
    "description": "Learn how to define interfaces to describe the shape of objects, including optional properties, readonly properties, and extending interfaces.",
    "codeExample": "// Basic interface\ninterface Person {\n  firstName: string\n  lastName: string\n  age?: number  // Optional property\n  readonly ssn: string  // Readonly property\n}\n\nfunction greeter(person: Person) {\n  // person.ssn = \"123-45-6789\"  // Error! Cannot assign to 'ssn'\n  return `Hello, ${person.firstName} ${person.lastName}${person.age ? `, age ${person.age}` : ''}`\n}\n\nlet user = { firstName: \"Jane\", lastName: \"User\", ssn: \"123-45-6789\", age: 25 }\n\ngreeter(user)\n\n// Extending interfaces\ninterface Shape {\n  color: string\n}\n\ninterface Square extends Shape {\n  sideLength: number\n}\n\nlet square = <Square>{ color: \"blue\", sideLength: 10 }\n\n// Multiple inheritance\ninterface PenStroke {\n  penWidth: number\n}\n\ninterface Square2 extends Shape, PenStroke {\n  sideLength: number\n}\n\nlet square2 = <Square2>{ color: \"blue\", sideLength: 10, penWidth: 5.0 }",
    "output": "Type-safe object manipulation with interfaces, showing optional and readonly properties, and interface extension"
  },
  {
    "id": 4,
    "topic": "Classes",
    "title": "Class Implementation with Access Modifiers and Abstract Classes",
    "description": "Learn how to implement classes with access modifiers in TypeScript, including abstract classes and method overriding.",
    "codeExample": "abstract class Department {\n  // Public by default\n  name: string\n  \n  // Protected - accessible within class and subclasses\n  protected employees: string[] = []\n  \n  // Private - only accessible within this class\n  private readonly id: string\n  \n  constructor(id: string, n: string) {\n    this.id = id\n    this.name = n\n  }\n  \n  // Abstract method - must be implemented in derived classes\n  abstract describe(): void\n  \n  addEmployee(employee: string) {\n    this.employees.push(employee)\n  }\n  \n  printEmployeeInformation() {\n    console.log(`Department: ${this.name} (${this.id})`)\n    console.log('Employees:', this.employees)\n  }\n}\n\nclass ITDepartment extends Department {\n  admins: string[]\n  \n  constructor(id: string, admins: string[]) {\n    super(id, 'IT')  // Call parent constructor\n    this.admins = admins\n  }\n  \n  describe() {\n    console.log(`IT Department - ID: ${this.id}`)\n  }\n  \n  addEmployee(name: string) {\n    if (name === 'Bill') {\n      return  // Don't add Bill\n    }\n    super.addEmployee(name)  // Call parent method\n  }\n}\n\nlet it = new ITDepartment('d1', ['Max'])\nit.addEmployee('Max')\nit.addEmployee('Bill')  // Won't be added\nit.printEmployeeInformation()\nit.describe()",
    "output": "Class hierarchy with proper encapsulation, abstract classes, and method overriding"
  },
  {
    "id": 5,
    "topic": "Generics",
    "title": "Generic Types and Constraints",
    "description": "Learn how to create reusable components with generics, including generic constraints for more precise type safety.",
    "codeExample": "// Simple generic function\nfunction identity<T>(arg: T): T {\n  return arg\n}\n\nlet output1 = identity<string>(\"myString\")\nlet output2 = identity(\"myString\")  // Type argument inferred\n\n// Generic interface\ninterface GenericIdentityFn<T> {\n  (arg: T): T\n}\n\nfunction identity2<T>(arg: T): T {\n  return arg\n}\n\nlet myIdentity: GenericIdentityFn<number> = identity2\n\n// Generic class\nclass GenericNumber<T> {\n  zeroValue: T\n  add: (x: T, y: T) => T\n}\n\nlet myGenericNumber = new GenericNumber<number>()\nmyGenericNumber.zeroValue = 0\nmyGenericNumber.add = function(x, y) {\n  return x + y\n}\n\n// Generic constraints\ninterface Lengthwise {\n  length: number\n}\n\nfunction loggingIdentity<T extends Lengthwise>(arg: T): T {\n  console.log(arg.length)  // Now we know it has a .length property\n  return arg\n}\n\nloggingIdentity(\"hello\")  // OK - string has length\nloggingIdentity([1, 2, 3])  // OK - array has length\n// loggingIdentity(3)  // Error - number doesn't have length\n\n// Using type parameters in generic constraints\nfunction getProperty<T, K extends keyof T>(obj: T, key: K) {\n  return obj[key]\n}\n\nlet x = { a: 1, b: 2, c: 3, d: 4 }\ngetProperty(x, \"a\")  // OK\n// getProperty(x, \"m\")  // Error - Argument of type '\"m\"' is not assignable to parameter of type '\"a\" | \"b\" | \"c\" | \"d\"'",
    "output": "Type-safe generic functions, interfaces, and classes with constraints for flexible yet safe type usage"
  },
  {
    "id": 6,
    "topic": "Advanced Types",
    "title": "Union, Intersection, and Conditional Types",
    "description": "Learn about advanced type compositions including union types, intersection types, and conditional types.",
    "codeExample": "// Union types\ntype StringOrNumber = string | number\n\nfunction printId(id: StringOrNumber) {\n  if (typeof id === 'string') {\n    console.log(`ID (string): ${id.toUpperCase()}`)\n  } else {\n    console.log(`ID (number): ${id.toFixed(2)}`)\n  }\n}\n\nprintId('abc123')\nprintId(12345)\n\n// Intersection types\ninterface Person {\n  name: string\n}\n\ninterface Employee {\n  employeeId: number\n}\n\ntype PersonEmployee = Person & Employee\n\nconst worker: PersonEmployee = {\n  name: 'John Doe',\n  employeeId: 12345\n}\n\n// Discriminated unions\ninterface Square {\n  kind: 'square'\n  size: number\n}\n\ninterface Rectangle {\n  kind: 'rectangle'\n  width: number\n  height: number\n}\n\ninterface Circle {\n  kind: 'circle'\n  radius: number\n}\n\ntype Shape = Square | Rectangle | Circle\n\nfunction getArea(shape: Shape): number {\n  switch (shape.kind) {\n    case 'square':\n      return shape.size * shape.size\n    case 'rectangle':\n      return shape.width * shape.height\n    case 'circle':\n      return Math.PI * shape.radius ** 2\n    default:\n      const _exhaustiveCheck: never = shape\n      return _exhaustiveCheck\n  }\n}\n\n// Conditional types\ntype NonNullable<T> = T extends null | undefined ? never : T\ntype StringsOnly<T> = T extends string ? T : never\n\ntype A = NonNullable<string | null>  // string\ntype B = StringsOnly<string | number>  // string",
    "output": "ID (string): ABC123\nID (number): 12345.00\nDemonstrates union types, intersection types, and type-safe discriminated unions"
  },
  {
    "id": 7,
    "topic": "Type Guards",
    "title": "Type Guards and Type Assertions",
    "description": "Learn how to narrow types using type guards and safely assert types in TypeScript.",
    "codeExample": "// Type predicate functions\nfunction isString(value: unknown): value is string {\n  return typeof value === 'string'\n}\n\nfunction isNumber(value: unknown): value is number {\n  return typeof value === 'number'\n}\n\n// Using type guards\nfunction processValue(value: unknown) {\n  if (isString(value)) {\n    // TypeScript knows value is string here\n    console.log(`String length: ${value.length}`)\n  } else if (isNumber(value)) {\n    // TypeScript knows value is number here\n    console.log(`Number fixed: ${value.toFixed(2)}`)\n  } else {\n    console.log('Unknown type')\n  }\n}\n\nprocessValue('Hello')\nprocessValue(42.123)\nprocessValue(true)\n\n// instanceof type guard\nclass Bird {\n  fly() {\n    console.log('Flying!')\n  }\n  layEggs() {\n    console.log('Laying eggs!')\n  }\n}\n\nclass Fish {\n  swim() {\n    console.log('Swimming!')\n  }\n  layEggs() {\n    console.log('Laying eggs!')\n  }\n}\n\nfunction getAnimal(): Bird | Fish {\n  return Math.random() > 0.5 ? new Bird() : new Fish()\n}\n\nfunction moveAnimal(animal: Bird | Fish) {\n  if (animal instanceof Bird) {\n    animal.fly()  // TypeScript knows it's a Bird\n  } else {\n    animal.swim()  // TypeScript knows it's a Fish\n  }\n  animal.layEggs()  // Available on both\n}\n\n// Type assertions\nconst someValue: unknown = 'this is a string'\nconst strLength: number = (someValue as string).length\n\n// Non-null assertion operator\nfunction processName(name: string | null) {\n  // We know name is not null here\n  console.log(name!.charAt(0))\n}",
    "output": "String length: 5\nNumber fixed: 42.12\nUnknown type\nFlying! or Swimming!\nLaying eggs!"
  },
  {
    "id": 8,
    "topic": "Utility Types",
    "title": "Built-in Utility Types",
    "description": "Learn about TypeScript's built-in utility types for transforming types efficiently.",
    "codeExample": "interface User {\n  id: number\n  name: string\n  email: string\n  age: number\n  isActive: boolean\n}\n\n// Partial - makes all properties optional\ntype PartialUser = Partial<User>\nconst updateUser: PartialUser = {\n  name: 'John Doe'  // Only name is provided\n}\n\n// Required - makes all properties required\ninterface OptionalUser {\n  id?: number\n  name?: string\n  email?: string\n}\n\ntype RequiredUser = Required<OptionalUser>\n// All properties are now required\n\n// Pick - creates a type by picking specific properties\ntype UserSummary = Pick<User, 'id' | 'name' | 'email'>\nconst summary: UserSummary = {\n  id: 1,\n  name: 'Jane',\n  email: 'jane@example.com'\n  // age and isActive are not included\n}\n\n// Omit - creates a type by omitting specific properties\ntype PublicUser = Omit<User, 'id' | 'isActive'>\nconst publicInfo: PublicUser = {\n  name: 'Bob',\n  email: 'bob@example.com',\n  age: 30\n  // id and isActive are omitted\n}\n\n// Record - creates an object type with specific keys and values\ntype UserRoles = Record<'admin' | 'user' | 'guest', string[]>\nconst roles: UserRoles = {\n  admin: ['read', 'write', 'delete'],\n  user: ['read', 'write'],\n  guest: ['read']\n}\n\n// Exclude and Extract\ntype T1 = Exclude<'a' | 'b' | 'c', 'a'>  // 'b' | 'c'\ntype T2 = Extract<'a' | 'b' | 'c', 'a' | 'f'>  // 'a'\n\n// ReturnType - extracts return type of function\nfunction getUser() {\n  return { id: 1, name: 'John' }\n}\n\ntype UserReturnType = ReturnType<typeof getUser>  // { id: number, name: string }\n\n// Parameters - extracts parameter types\nfunction createUser(name: string, age: number, email: string) {\n  return { name, age, email }\n}\n\ntype CreateUserParams = Parameters<typeof createUser>  // [string, number, string]",
    "output": "Demonstrates various utility types for flexible type transformations and code reuse"
  },
  {
    "id": 9,
    "topic": "Decorators",
    "title": "Decorators and Metadata",
    "description": "Learn how to use decorators for meta-programming in TypeScript.",
    "codeExample": "// Enable decorators in tsconfig.json:\n// \"experimentalDecorators\": true,\n// \"emitDecoratorMetadata\": true\n\n// Class decorator\nfunction sealed(constructor: Function) {\n  Object.seal(constructor)\n  Object.seal(constructor.prototype)\n}\n\n// Method decorator\nfunction enumerable(value: boolean) {\n  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n    descriptor.enumerable = value\n  }\n}\n\n// Property decorator\nfunction format(formatString: string) {\n  return function (target: any, propertyKey: string) {\n    let value = target[propertyKey]\n    \n    const getter = function () {\n      return `${formatString} ${value}`\n    }\n    \n    const setter = function (newVal: string) {\n      value = newVal\n    }\n    \n    Object.defineProperty(target, propertyKey, {\n      get: getter,\n      set: setter,\n      enumerable: true,\n      configurable: true\n    })\n  }\n}\n\n// Parameter decorator\nfunction required(target: any, propertyKey: string, parameterIndex: number) {\n  const existingRequiredParameters: number[] = Reflect.getOwnMetadata('required', target, propertyKey) || []\n  existingRequiredParameters.push(parameterIndex)\n  Reflect.defineMetadata('required', existingRequiredParameters, target, propertyKey)\n}\n\n// Usage of decorators\n@sealed\nclass Greeter {\n  @format('Hello')\n  greeting: string\n  \n  constructor(message: string) {\n    this.greeting = message\n  }\n  \n  @enumerable(false)\n  greet(@required name: string) {\n    return `${this.greeting}, ${name}!`\n  }\n}\n\nconst greeter = new Greeter('world')\nconsole.log(greeter.greet('TypeScript'))\n\n// Decorator factory example\nfunction log(prefix: string) {\n  return function (target: any, propertyName: string, descriptor: PropertyDescriptor) {\n    const method = descriptor.value\n    \n    descriptor.value = function (...args: any[]) {\n      console.log(`${prefix}: Calling ${propertyName} with args:`, args)\n      const result = method.apply(this, args)\n      console.log(`${prefix}: ${propertyName} returned:`, result)\n      return result\n    }\n  }\n}\n\nclass Calculator {\n  @log('CALC')\n  add(a: number, b: number): number {\n    return a + b\n  }\n}\n\nconst calc = new Calculator()\ncalc.add(2, 3)",
    "output": "Hello world, TypeScript!\nCALC: Calling add with args: [2, 3]\nCALC: add returned: 5"
  },
  {
    "id": 10,
    "topic": "Modules",
    "title": "Module System and Namespaces",
    "description": "Learn about TypeScript's module system, import/export statements, and namespaces.",
    "codeExample": "// math.ts - Module with multiple exports\nexport function add(x: number, y: number): number {\n  return x + y\n}\n\nexport function subtract(x: number, y: number): number {\n  return x - y\n}\n\nexport const PI = 3.14159\n\n// Default export\nexport default class Calculator {\n  multiply(x: number, y: number): number {\n    return x * y\n  }\n}\n\n// utils.ts - Re-exports\nexport { add, subtract } from './math'\nexport { default as Calculator } from './math'\n\n// app.ts - Various import syntaxes\nimport Calculator, { add, subtract, PI } from './math'\nimport * as MathUtils from './math'\nimport { add as addition } from './math'\n\nconst calc = new Calculator()\nconsole.log(add(5, 3))\nconsole.log(subtract(10, 4))\nconsole.log(calc.multiply(3, 4))\nconsole.log(PI)\n\n// Using namespace alias\nconsole.log(MathUtils.add(1, 2))\nconsole.log(addition(2, 3))\n\n// Namespace declaration (legacy approach)\nnamespace Geometry {\n  export interface Point {\n    x: number\n    y: number\n  }\n  \n  export function distance(p1: Point, p2: Point): number {\n    const dx = p1.x - p2.x\n    const dy = p1.y - p2.y\n    return Math.sqrt(dx * dx + dy * dy)\n  }\n  \n  export namespace Circle {\n    export function area(radius: number): number {\n      return Math.PI * radius * radius\n    }\n    \n    export function circumference(radius: number): number {\n      return 2 * Math.PI * radius\n    }\n  }\n}\n\n// Using namespace\nconst p1: Geometry.Point = { x: 0, y: 0 }\nconst p2: Geometry.Point = { x: 3, y: 4 }\nconsole.log(Geometry.distance(p1, p2))  // 5\nconsole.log(Geometry.Circle.area(5))    // ~78.54\n\n// Dynamic imports\nasync function loadMath() {\n  const mathModule = await import('./math')\n  console.log(mathModule.add(10, 20))\n}",
    "output": "8\n6\n12\n3.14159\n3\n5\n5\n78.54\n30 (from dynamic import)"
  },
  {
    "id": 11,
    "topic": "Async Programming",
    "title": "Promises, Async/Await with TypeScript",
    "description": "Learn how to work with asynchronous code in TypeScript using Promises and async/await.",
    "codeExample": "// Typed Promise functions\nfunction fetchUser(id: number): Promise<{ id: number; name: string; email: string }> {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (id > 0) {\n        resolve({\n          id,\n          name: `User ${id}`,\n          email: `user${id}@example.com`\n        })\n      } else {\n        reject(new Error('Invalid user ID'))\n      }\n    }, 1000)\n  })\n}\n\n// Generic Promise wrapper\nfunction delay<T>(ms: number, value: T): Promise<T> {\n  return new Promise(resolve => {\n    setTimeout(() => resolve(value), ms)\n  })\n}\n\n// Async/await with error handling\nasync function getUserInfo(id: number): Promise<string> {\n  try {\n    const user = await fetchUser(id)\n    const greeting = await delay(500, `Hello, ${user.name}!`)\n    return greeting\n  } catch (error) {\n    throw new Error(`Failed to get user info: ${error.message}`)\n  }\n}\n\n// Promise combinators with types\ninterface ApiResponse<T> {\n  data: T\n  status: number\n  timestamp: Date\n}\n\nasync function fetchMultipleUsers(ids: number[]): Promise<ApiResponse<any>[]> {\n  const promises = ids.map(id => \n    fetchUser(id).then(user => ({\n      data: user,\n      status: 200,\n      timestamp: new Date()\n    })).catch(error => ({\n      data: null,\n      status: 404,\n      timestamp: new Date(),\n      error: error.message\n    }))\n  )\n  \n  return Promise.all(promises)\n}\n\n// Async iterators\nasync function* generateNumbers(): AsyncIterableIterator<number> {\n  for (let i = 1; i <= 5; i++) {\n    await delay(100, null)\n    yield i\n  }\n}\n\n// Usage examples\nasync function main() {\n  try {\n    // Single user\n    const greeting = await getUserInfo(1)\n    console.log(greeting)\n    \n    // Multiple users\n    const responses = await fetchMultipleUsers([1, 2, -1])\n    console.log('Responses:', responses.length)\n    \n    // Async iteration\n    for await (const num of generateNumbers()) {\n      console.log(`Generated: ${num}`)\n    }\n    \n  } catch (error) {\n    console.error('Error:', error.message)\n  }\n}\n\nmain()",
    "output": "Hello, User 1!\nResponses: 3\nGenerated: 1\nGenerated: 2\nGenerated: 3\nGenerated: 4\nGenerated: 5"
  },
  {
    "id": 12,
    "topic": "Testing",
    "title": "Testing TypeScript Code",
    "description": "Learn how to write comprehensive tests for TypeScript code using Jest and type-safe testing patterns.",
    "codeExample": "// user.ts - Code to test\nexport interface User {\n  id: number\n  name: string\n  email: string\n  age: number\n}\n\nexport class UserService {\n  private users: User[] = []\n  \n  addUser(user: Omit<User, 'id'>): User {\n    const newUser: User = {\n      ...user,\n      id: Math.max(0, ...this.users.map(u => u.id)) + 1\n    }\n    this.users.push(newUser)\n    return newUser\n  }\n  \n  getUser(id: number): User | undefined {\n    return this.users.find(user => user.id === id)\n  }\n  \n  updateUser(id: number, updates: Partial<User>): User | null {\n    const userIndex = this.users.findIndex(user => user.id === id)\n    if (userIndex === -1) return null\n    \n    this.users[userIndex] = { ...this.users[userIndex], ...updates }\n    return this.users[userIndex]\n  }\n  \n  deleteUser(id: number): boolean {\n    const userIndex = this.users.findIndex(user => user.id === id)\n    if (userIndex === -1) return false\n    \n    this.users.splice(userIndex, 1)\n    return true\n  }\n  \n  getAllUsers(): User[] {\n    return [...this.users]\n  }\n}\n\n// user.test.ts - Comprehensive tests\nimport { UserService, User } from './user'\n\ndescribe('UserService', () => {\n  let userService: UserService\n  \n  beforeEach(() => {\n    userService = new UserService()\n  })\n  \n  describe('addUser', () => {\n    it('should add a user with auto-generated id', () => {\n      const userData = { name: 'John Doe', email: 'john@example.com', age: 30 }\n      const user = userService.addUser(userData)\n      \n      expect(user.id).toBe(1)\n      expect(user.name).toBe('John Doe')\n      expect(user.email).toBe('john@example.com')\n      expect(user.age).toBe(30)\n    })\n    \n    it('should increment id for subsequent users', () => {\n      userService.addUser({ name: 'User 1', email: 'user1@test.com', age: 25 })\n      const secondUser = userService.addUser({ name: 'User 2', email: 'user2@test.com', age: 35 })\n      \n      expect(secondUser.id).toBe(2)\n    })\n  })\n  \n  describe('getUser', () => {\n    it('should return user by id', () => {\n      const addedUser = userService.addUser({ name: 'Test User', email: 'test@example.com', age: 28 })\n      const foundUser = userService.getUser(addedUser.id)\n      \n      expect(foundUser).toEqual(addedUser)\n    })\n    \n    it('should return undefined for non-existent user', () => {\n      const user = userService.getUser(999)\n      expect(user).toBeUndefined()\n    })\n  })\n  \n  describe('updateUser', () => {\n    it('should update existing user partially', () => {\n      const user = userService.addUser({ name: 'Original Name', email: 'original@test.com', age: 25 })\n      const updated = userService.updateUser(user.id, { name: 'Updated Name', age: 26 })\n      \n      expect(updated).toMatchObject({\n        id: user.id,\n        name: 'Updated Name',\n        email: 'original@test.com',\n        age: 26\n      })\n    })\n    \n    it('should return null for non-existent user', () => {\n      const result = userService.updateUser(999, { name: 'New Name' })\n      expect(result).toBeNull()\n    })\n  })\n})",
    "output": "✓ UserService › addUser › should add a user with auto-generated id\n✓ UserService › addUser › should increment id for subsequent users\n✓ UserService › getUser › should return user by id\n✓ UserService › getUser › should return undefined for non-existent user\n✓ UserService › updateUser › should update existing user partially\n✓ UserService › updateUser › should return null for non-existent user"
  }
]