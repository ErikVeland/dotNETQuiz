{
  "timestamp": "2025-10-02T00:11:58.225Z",
  "version": "1.0.0",
  "analysis": {
    "modules": {
      "programming-fundamentals": {
        "slug": "programming-fundamentals",
        "title": "Programming Fundamentals",
        "tier": "foundational",
        "track": "Programming",
        "difficulty": "Beginner",
        "thresholds": {
          "requiredLessons": 12,
          "requiredQuestions": 15
        },
        "lessons": {
          "exists": true,
          "count": 12,
          "lessons": [
            {
              "id": "programming-fundamentals-lesson-1",
              "moduleSlug": "programming-fundamentals",
              "title": "Variables and Data Types",
              "order": 1,
              "objectives": [
                "Understand different data types in programming (numbers, strings, booleans)",
                "Learn how to declare and initialize variables",
                "Master variable naming conventions and best practices"
              ],
              "intro": "Variables are fundamental building blocks in programming that store and manage data in your applications. Understanding data types is crucial for writing efficient and bug-free code.\n\nIn this lesson, you'll learn about primitive data types including numbers, strings, and booleans. We'll explore how different programming languages handle these types and when to use each one effectively.\n\nVariables act as containers that hold values which can change during program execution. Proper variable management is essential for memory efficiency and code readability. You'll discover naming conventions that make your code self-documenting and easier to maintain.\n\nBy the end of this lesson, you'll confidently declare variables, choose appropriate data types, and follow industry-standard naming practices. These skills form the foundation for all programming concepts you'll learn throughout your development journey.\n\nWe'll cover practical examples showing how variables store different types of information, from user input to calculation results. Understanding these fundamentals will prepare you for more complex topics like functions, arrays, and object-oriented programming.",
              "code": {
                "example": "// Variable declarations with different data types\n\n// Numbers (integers and floating-point)\nlet age = 25;\nlet price = 19.99;\nlet temperature = -5;\n\n// Strings (text data)\nlet firstName = \"John\";\nlet lastName = \"Doe\";\nlet message = `Hello, ${firstName} ${lastName}!`;\n\n// Booleans (true/false values)\nlet isLoggedIn = true;\nlet hasPermission = false;\nlet isValidEmail = email.includes('@');\n\n// Constants (values that don't change)\nconst PI = 3.14159;\nconst MAX_USERS = 100;\n\n// Variable naming conventions\nlet userName = \"camelCase for variables\";\nconst API_URL = \"UPPER_CASE for constants\";\nlet is_valid = false; // avoid snake_case in JavaScript\n\nconsole.log(`Age: ${age}, Price: $${price}, User: ${firstName}`);",
                "explanation": "This example demonstrates proper variable declaration, different data types, and naming conventions. Notice how we use 'let' for variables that can change, 'const' for constants, and template literals for string interpolation.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following Logic best practices",
                  "solution": "Review official documentation and established patterns for Logic",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling in implementation",
                  "solution": "Always implement proper error handling and validation",
                  "severity": "high"
                },
                {
                  "mistake": "Ignoring performance implications",
                  "solution": "Consider performance impact of your implementation choices",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Variable Declaration Practice",
                  "description": "Create a simple program that declares variables for a user profile and displays the information.",
                  "checkpoints": [
                    "Declare variables for name, age, email, and account status",
                    "Use appropriate data types for each variable",
                    "Display the user information using template literals",
                    "Verify your variable names follow naming conventions"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Beginner",
              "tags": [
                "Logic",
                "Algorithms",
                "Data Structures"
              ],
              "lastUpdated": "2025-10-01T06:42:16.313Z",
              "version": "1.0.0"
            },
            {
              "id": "programming-fundamentals-lesson-2",
              "moduleSlug": "programming-fundamentals",
              "title": "Control Structures",
              "order": 2,
              "objectives": [
                "Master if statements and conditional logic",
                "Implement loops for repetitive tasks (for, while, do-while)",
                "Use switch statements for multiple conditions"
              ],
              "intro": "Control structures are the building blocks that control the flow of your program execution. They determine which code runs when, based on conditions and repetition needs.\n\nIn this lesson, you'll learn how to make decisions in your code using if statements, else clauses, and complex conditional logic. These structures allow your programs to respond dynamically to different situations and user inputs.\n\nLoops are essential for performing repetitive tasks efficiently. Instead of writing the same code multiple times, you'll use for loops, while loops, and do-while loops to iterate through data and repeat operations.\n\nSwitch statements provide a clean way to handle multiple possible values for a single variable. This is particularly useful when dealing with user choices, menu systems, or processing different types of data.\n\nBy mastering these control structures, you'll be able to create programs that make intelligent decisions and handle repetitive tasks automatically. These concepts are fundamental to all programming languages and essential for building any meaningful application.",
              "code": {
                "example": "// Conditional statements (if/else)\nlet age = 18;\nlet hasLicense = true;\n\nif (age >= 18 && hasLicense) {\n    console.log('Can drive legally');\n} else if (age >= 16) {\n    console.log('Can drive with supervision');\n} else {\n    console.log('Too young to drive');\n}\n\n// Switch statement for multiple conditions\nlet dayOfWeek = 'Monday';\nswitch (dayOfWeek) {\n    case 'Monday':\n    case 'Tuesday':\n    case 'Wednesday':\n    case 'Thursday':\n    case 'Friday':\n        console.log('Weekday');\n        break;\n    case 'Saturday':\n    case 'Sunday':\n        console.log('Weekend');\n        break;\n    default:\n        console.log('Invalid day');\n}\n\n// For loop for counting\nfor (let i = 1; i <= 5; i++) {\n    console.log(`Count: ${i}`);\n}\n\n// While loop for unknown iterations\nlet password = '';\nwhile (password !== 'secret') {\n    password = prompt('Enter password:');\n    if (password !== 'secret') {\n        console.log('Incorrect password, try again');\n    }\n}\n\n// Array iteration\nlet fruits = ['apple', 'banana', 'orange'];\nfor (let fruit of fruits) {\n    console.log(`I like ${fruit}`);\n}",
                "explanation": "This example shows different control structures: if/else for decisions, switch for multiple conditions, for loops for counting, while loops for unknown iterations, and array iteration.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Using assignment (=) instead of comparison (===) in conditions",
                  "solution": "Always use === for comparison and = for assignment. Use === instead of == for strict equality",
                  "severity": "high"
                },
                {
                  "mistake": "Forgetting break statements in switch cases",
                  "solution": "Always include break statements to prevent fall-through behavior unless intentional",
                  "severity": "medium"
                },
                {
                  "mistake": "Creating infinite loops by forgetting to update loop variables",
                  "solution": "Ensure loop conditions will eventually become false by updating variables inside the loop",
                  "severity": "high"
                }
              ],
              "exercises": [
                {
                  "title": "Grade Calculator",
                  "description": "Create a program that determines letter grades based on numeric scores and calculates class statistics.",
                  "checkpoints": [
                    "Use if/else statements to convert numeric grades to letters (A, B, C, D, F)",
                    "Implement a loop to process multiple student grades",
                    "Use a switch statement to count how many of each letter grade",
                    "Calculate and display the class average"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Beginner",
              "tags": [
                "Logic",
                "Algorithms",
                "Data Structures"
              ],
              "lastUpdated": "2025-10-01T06:42:16.314Z",
              "version": "1.0.0"
            },
            {
              "id": "programming-fundamentals-lesson-3",
              "moduleSlug": "programming-fundamentals",
              "title": "Functions and Methods",
              "order": 3,
              "objectives": [
                "Understand function syntax and parameter passing",
                "Learn about return values and scope",
                "Master function best practices and naming conventions"
              ],
              "intro": "Functions are reusable blocks of code that perform specific tasks, making your programs modular, organized, and easier to maintain. They are essential for writing clean, efficient code.\n\nIn this lesson, you'll learn how to define functions, pass data through parameters, and return results. Functions help eliminate code duplication and make your programs easier to test and debug.\n\nScope is a crucial concept that determines where variables can be accessed in your code. Understanding local and global scope prevents common bugs and helps you write more predictable functions.\n\nYou'll discover different types of functions including arrow functions, anonymous functions, and higher-order functions. These concepts prepare you for advanced programming patterns and modern development practices.\n\nBy the end of this lesson, you'll confidently create functions that solve specific problems, accept input parameters, return meaningful results, and follow industry naming conventions. Functions are the building blocks of larger applications.",
              "code": {
                "example": "// Basic function declaration\nfunction greetUser(name, timeOfDay) {\n    return `Good ${timeOfDay}, ${name}!`;\n}\n\n// Function expression\nconst calculateArea = function(length, width) {\n    return length * width;\n};\n\n// Arrow function (ES6+)\nconst multiply = (a, b) => a * b;\n\n// Function with default parameters\nfunction createUser(name, role = 'user', active = true) {\n    return {\n        name: name,\n        role: role,\n        active: active,\n        createdAt: new Date()\n    };\n}\n\n// Higher-order function (function that takes another function)\nfunction processNumbers(numbers, operation) {\n    return numbers.map(operation);\n}\n\n// Usage examples\nconsole.log(greetUser('Alice', 'morning'));\nconst roomArea = calculateArea(10, 12);\nconst product = multiply(5, 3);\n\nconst newUser = createUser('Bob');\nconst adminUser = createUser('Carol', 'admin');\n\nconst doubled = processNumbers([1, 2, 3, 4], x => x * 2);\nconsole.log(doubled); // [2, 4, 6, 8]\n\n// Function scope example\nlet globalVar = 'I am global';\n\nfunction demonstrateScope() {\n    let localVar = 'I am local';\n    console.log(globalVar); // Can access global\n    console.log(localVar);  // Can access local\n}\n\n// console.log(localVar); // Error: localVar is not defined",
                "explanation": "This example demonstrates function declarations, expressions, arrow functions, parameters with defaults, return values, higher-order functions, and variable scope.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Modifying global variables inside functions",
                  "solution": "Use parameters and return values instead of relying on global variables",
                  "severity": "high"
                },
                {
                  "mistake": "Creating functions that do too many things",
                  "solution": "Follow the single responsibility principle - each function should do one thing well",
                  "severity": "medium"
                },
                {
                  "mistake": "Not handling missing or invalid parameters",
                  "solution": "Validate parameters and provide default values or error handling",
                  "severity": "medium"
                }
              ],
              "exercises": [
                {
                  "title": "Calculator Functions",
                  "description": "Build a set of calculator functions that demonstrate parameter passing and return values.",
                  "checkpoints": [
                    "Create functions for basic math operations (add, subtract, multiply, divide)",
                    "Implement input validation to handle invalid numbers",
                    "Build a main function that uses all the math functions",
                    "Add error handling for division by zero"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Beginner",
              "tags": [
                "Logic",
                "Algorithms",
                "Data Structures"
              ],
              "lastUpdated": "2025-10-01T06:42:16.314Z",
              "version": "1.0.0"
            },
            {
              "id": "programming-fundamentals-lesson-4",
              "moduleSlug": "programming-fundamentals",
              "title": "Core Fundamentals",
              "order": 4,
              "objectives": [
                "Apply advanced Logic techniques",
                "Optimize performance and efficiency",
                "Integrate with external systems"
              ],
              "intro": "Welcome to Core Fundamentals in the Programming Fundamentals module. \n\nThis lesson is part of the foundational tier, designed for beginner level learners. Throughout this lesson, you'll explore essential concepts and practical applications that form the foundation of modern programming development.\n\nVariables, data types, control structures, and basic algorithms This lesson builds upon previous concepts while introducing new techniques that will enhance your understanding and practical skills.\n\nBy the end of this lesson, you'll have hands-on experience with Logic and Algorithms, along with best practices for implementing these technologies in real-world scenarios. The knowledge gained here will prepare you for more advanced topics in subsequent lessons.\n\nKey areas we'll cover include practical implementation techniques, common challenges developers face, and proven solutions that industry professionals use daily. This lesson balances theoretical understanding with practical application, ensuring you can immediately apply what you learn.",
              "code": {
                "example": "// Example Logic implementation\n// TODO: Add specific code example for Programming Fundamentals\n\nfunction example() {\n    // Placeholder implementation\n    console.log('Programming Fundamentals example');\n}\n\nexport default example;",
                "explanation": "This example demonstrates the key concepts covered in this lesson.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following Logic best practices",
                  "solution": "Review official documentation and established patterns for Logic",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling in implementation",
                  "solution": "Always implement proper error handling and validation",
                  "severity": "high"
                },
                {
                  "mistake": "Ignoring performance implications",
                  "solution": "Consider performance impact of your implementation choices",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice Core Fundamentals",
                  "description": "Apply the concepts learned in this lesson through hands-on practice.",
                  "checkpoints": [
                    "Complete the basic implementation",
                    "Test your solution",
                    "Identify areas for improvement"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Beginner",
              "tags": [
                "Logic",
                "Algorithms",
                "Data Structures"
              ],
              "lastUpdated": "2025-10-01T06:42:16.314Z",
              "version": "1.0.0"
            },
            {
              "id": "programming-fundamentals-lesson-5",
              "moduleSlug": "programming-fundamentals",
              "title": "Essential Patterns",
              "order": 5,
              "objectives": [
                "Apply advanced Logic techniques",
                "Optimize performance and efficiency",
                "Integrate with external systems"
              ],
              "intro": "Welcome to Essential Patterns in the Programming Fundamentals module. \n\nThis lesson is part of the foundational tier, designed for beginner level learners. Throughout this lesson, you'll explore essential concepts and practical applications that form the foundation of modern programming development.\n\nVariables, data types, control structures, and basic algorithms This lesson builds upon previous concepts while introducing new techniques that will enhance your understanding and practical skills.\n\nBy the end of this lesson, you'll have hands-on experience with Logic and Algorithms, along with best practices for implementing these technologies in real-world scenarios. The knowledge gained here will prepare you for more advanced topics in subsequent lessons.\n\nKey areas we'll cover include practical implementation techniques, common challenges developers face, and proven solutions that industry professionals use daily. This lesson balances theoretical understanding with practical application, ensuring you can immediately apply what you learn.",
              "code": {
                "example": "// Example Logic implementation\n// TODO: Add specific code example for Programming Fundamentals\n\nfunction example() {\n    // Placeholder implementation\n    console.log('Programming Fundamentals example');\n}\n\nexport default example;",
                "explanation": "This example demonstrates the key concepts covered in this lesson.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following Logic best practices",
                  "solution": "Review official documentation and established patterns for Logic",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling in implementation",
                  "solution": "Always implement proper error handling and validation",
                  "severity": "high"
                },
                {
                  "mistake": "Ignoring performance implications",
                  "solution": "Consider performance impact of your implementation choices",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice Essential Patterns",
                  "description": "Apply the concepts learned in this lesson through hands-on practice.",
                  "checkpoints": [
                    "Complete the basic implementation",
                    "Test your solution",
                    "Identify areas for improvement"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Beginner",
              "tags": [
                "Logic",
                "Algorithms",
                "Data Structures"
              ],
              "lastUpdated": "2025-10-01T06:42:16.314Z",
              "version": "1.0.0"
            },
            {
              "id": "programming-fundamentals-lesson-6",
              "moduleSlug": "programming-fundamentals",
              "title": "Building Blocks",
              "order": 6,
              "objectives": [
                "Apply advanced Logic techniques",
                "Optimize performance and efficiency",
                "Integrate with external systems"
              ],
              "intro": "Welcome to Building Blocks in the Programming Fundamentals module. \n\nThis lesson is part of the foundational tier, designed for beginner level learners. Throughout this lesson, you'll explore essential concepts and practical applications that form the foundation of modern programming development.\n\nVariables, data types, control structures, and basic algorithms This lesson builds upon previous concepts while introducing new techniques that will enhance your understanding and practical skills.\n\nBy the end of this lesson, you'll have hands-on experience with Logic and Algorithms, along with best practices for implementing these technologies in real-world scenarios. The knowledge gained here will prepare you for more advanced topics in subsequent lessons.\n\nKey areas we'll cover include practical implementation techniques, common challenges developers face, and proven solutions that industry professionals use daily. This lesson balances theoretical understanding with practical application, ensuring you can immediately apply what you learn.",
              "code": {
                "example": "// Example Logic implementation\n// TODO: Add specific code example for Programming Fundamentals\n\nfunction example() {\n    // Placeholder implementation\n    console.log('Programming Fundamentals example');\n}\n\nexport default example;",
                "explanation": "This example demonstrates the key concepts covered in this lesson.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following Logic best practices",
                  "solution": "Review official documentation and established patterns for Logic",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling in implementation",
                  "solution": "Always implement proper error handling and validation",
                  "severity": "high"
                },
                {
                  "mistake": "Ignoring performance implications",
                  "solution": "Consider performance impact of your implementation choices",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice Building Blocks",
                  "description": "Apply the concepts learned in this lesson through hands-on practice.",
                  "checkpoints": [
                    "Complete the basic implementation",
                    "Test your solution",
                    "Identify areas for improvement"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Beginner",
              "tags": [
                "Logic",
                "Algorithms",
                "Data Structures"
              ],
              "lastUpdated": "2025-10-01T06:42:16.314Z",
              "version": "1.0.0"
            },
            {
              "id": "programming-fundamentals-lesson-7",
              "moduleSlug": "programming-fundamentals",
              "title": "First Steps",
              "order": 7,
              "objectives": [
                "Apply advanced Logic techniques",
                "Optimize performance and efficiency",
                "Integrate with external systems"
              ],
              "intro": "Welcome to First Steps in the Programming Fundamentals module. \n\nThis lesson is part of the foundational tier, designed for beginner level learners. Throughout this lesson, you'll explore essential concepts and practical applications that form the foundation of modern programming development.\n\nVariables, data types, control structures, and basic algorithms This lesson builds upon previous concepts while introducing new techniques that will enhance your understanding and practical skills.\n\nBy the end of this lesson, you'll have hands-on experience with Logic and Algorithms, along with best practices for implementing these technologies in real-world scenarios. The knowledge gained here will prepare you for more advanced topics in subsequent lessons.\n\nKey areas we'll cover include practical implementation techniques, common challenges developers face, and proven solutions that industry professionals use daily. This lesson balances theoretical understanding with practical application, ensuring you can immediately apply what you learn.",
              "code": {
                "example": "// Example Logic implementation\n// TODO: Add specific code example for Programming Fundamentals\n\nfunction example() {\n    // Placeholder implementation\n    console.log('Programming Fundamentals example');\n}\n\nexport default example;",
                "explanation": "This example demonstrates the key concepts covered in this lesson.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following Logic best practices",
                  "solution": "Review official documentation and established patterns for Logic",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling in implementation",
                  "solution": "Always implement proper error handling and validation",
                  "severity": "high"
                },
                {
                  "mistake": "Ignoring performance implications",
                  "solution": "Consider performance impact of your implementation choices",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice First Steps",
                  "description": "Apply the concepts learned in this lesson through hands-on practice.",
                  "checkpoints": [
                    "Complete the basic implementation",
                    "Test your solution",
                    "Identify areas for improvement"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Beginner",
              "tags": [
                "Logic",
                "Algorithms",
                "Data Structures"
              ],
              "lastUpdated": "2025-10-01T06:42:16.314Z",
              "version": "1.0.0"
            },
            {
              "id": "programming-fundamentals-lesson-8",
              "moduleSlug": "programming-fundamentals",
              "title": "Understanding Basics",
              "order": 8,
              "objectives": [
                "Apply advanced Logic techniques",
                "Optimize performance and efficiency",
                "Integrate with external systems"
              ],
              "intro": "Welcome to Understanding Basics in the Programming Fundamentals module. \n\nThis lesson is part of the foundational tier, designed for beginner level learners. Throughout this lesson, you'll explore essential concepts and practical applications that form the foundation of modern programming development.\n\nVariables, data types, control structures, and basic algorithms This lesson builds upon previous concepts while introducing new techniques that will enhance your understanding and practical skills.\n\nBy the end of this lesson, you'll have hands-on experience with Logic and Algorithms, along with best practices for implementing these technologies in real-world scenarios. The knowledge gained here will prepare you for more advanced topics in subsequent lessons.\n\nKey areas we'll cover include practical implementation techniques, common challenges developers face, and proven solutions that industry professionals use daily. This lesson balances theoretical understanding with practical application, ensuring you can immediately apply what you learn.",
              "code": {
                "example": "// Example Logic implementation\n// TODO: Add specific code example for Programming Fundamentals\n\nfunction example() {\n    // Placeholder implementation\n    console.log('Programming Fundamentals example');\n}\n\nexport default example;",
                "explanation": "This example demonstrates the key concepts covered in this lesson.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following Logic best practices",
                  "solution": "Review official documentation and established patterns for Logic",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling in implementation",
                  "solution": "Always implement proper error handling and validation",
                  "severity": "high"
                },
                {
                  "mistake": "Ignoring performance implications",
                  "solution": "Consider performance impact of your implementation choices",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice Understanding Basics",
                  "description": "Apply the concepts learned in this lesson through hands-on practice.",
                  "checkpoints": [
                    "Complete the basic implementation",
                    "Test your solution",
                    "Identify areas for improvement"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Beginner",
              "tags": [
                "Logic",
                "Algorithms",
                "Data Structures"
              ],
              "lastUpdated": "2025-10-01T06:42:16.314Z",
              "version": "1.0.0"
            },
            {
              "id": "programming-fundamentals-lesson-9",
              "moduleSlug": "programming-fundamentals",
              "title": "Key Concepts",
              "order": 9,
              "objectives": [
                "Apply advanced Logic techniques",
                "Optimize performance and efficiency",
                "Integrate with external systems"
              ],
              "intro": "Welcome to Key Concepts in the Programming Fundamentals module. \n\nThis lesson is part of the foundational tier, designed for beginner level learners. Throughout this lesson, you'll explore essential concepts and practical applications that form the foundation of modern programming development.\n\nVariables, data types, control structures, and basic algorithms This lesson builds upon previous concepts while introducing new techniques that will enhance your understanding and practical skills.\n\nBy the end of this lesson, you'll have hands-on experience with Logic and Algorithms, along with best practices for implementing these technologies in real-world scenarios. The knowledge gained here will prepare you for more advanced topics in subsequent lessons.\n\nKey areas we'll cover include practical implementation techniques, common challenges developers face, and proven solutions that industry professionals use daily. This lesson balances theoretical understanding with practical application, ensuring you can immediately apply what you learn.",
              "code": {
                "example": "// Example Logic implementation\n// TODO: Add specific code example for Programming Fundamentals\n\nfunction example() {\n    // Placeholder implementation\n    console.log('Programming Fundamentals example');\n}\n\nexport default example;",
                "explanation": "This example demonstrates the key concepts covered in this lesson.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following Logic best practices",
                  "solution": "Review official documentation and established patterns for Logic",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling in implementation",
                  "solution": "Always implement proper error handling and validation",
                  "severity": "high"
                },
                {
                  "mistake": "Ignoring performance implications",
                  "solution": "Consider performance impact of your implementation choices",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice Key Concepts",
                  "description": "Apply the concepts learned in this lesson through hands-on practice.",
                  "checkpoints": [
                    "Complete the basic implementation",
                    "Test your solution",
                    "Identify areas for improvement"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Beginner",
              "tags": [
                "Logic",
                "Algorithms",
                "Data Structures"
              ],
              "lastUpdated": "2025-10-01T06:42:16.314Z",
              "version": "1.0.0"
            },
            {
              "id": "programming-fundamentals-lesson-10",
              "moduleSlug": "programming-fundamentals",
              "title": "Foundation Knowledge",
              "order": 10,
              "objectives": [
                "Apply advanced Logic techniques",
                "Optimize performance and efficiency",
                "Integrate with external systems"
              ],
              "intro": "Welcome to Foundation Knowledge in the Programming Fundamentals module. \n\nThis lesson is part of the foundational tier, designed for beginner level learners. Throughout this lesson, you'll explore essential concepts and practical applications that form the foundation of modern programming development.\n\nVariables, data types, control structures, and basic algorithms This lesson builds upon previous concepts while introducing new techniques that will enhance your understanding and practical skills.\n\nBy the end of this lesson, you'll have hands-on experience with Logic and Algorithms, along with best practices for implementing these technologies in real-world scenarios. The knowledge gained here will prepare you for more advanced topics in subsequent lessons.\n\nKey areas we'll cover include practical implementation techniques, common challenges developers face, and proven solutions that industry professionals use daily. This lesson balances theoretical understanding with practical application, ensuring you can immediately apply what you learn.",
              "code": {
                "example": "// Example Logic implementation\n// TODO: Add specific code example for Programming Fundamentals\n\nfunction example() {\n    // Placeholder implementation\n    console.log('Programming Fundamentals example');\n}\n\nexport default example;",
                "explanation": "This example demonstrates the key concepts covered in this lesson.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following Logic best practices",
                  "solution": "Review official documentation and established patterns for Logic",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling in implementation",
                  "solution": "Always implement proper error handling and validation",
                  "severity": "high"
                },
                {
                  "mistake": "Ignoring performance implications",
                  "solution": "Consider performance impact of your implementation choices",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice Foundation Knowledge",
                  "description": "Apply the concepts learned in this lesson through hands-on practice.",
                  "checkpoints": [
                    "Complete the basic implementation",
                    "Test your solution",
                    "Identify areas for improvement"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Beginner",
              "tags": [
                "Logic",
                "Algorithms",
                "Data Structures"
              ],
              "lastUpdated": "2025-10-01T06:42:16.314Z",
              "version": "1.0.0"
            },
            {
              "id": "programming-fundamentals-lesson-11",
              "moduleSlug": "programming-fundamentals",
              "title": "Practical Applications",
              "order": 11,
              "objectives": [
                "Apply advanced Logic techniques",
                "Optimize performance and efficiency",
                "Integrate with external systems"
              ],
              "intro": "Welcome to Practical Applications in the Programming Fundamentals module. \n\nThis lesson is part of the foundational tier, designed for beginner level learners. Throughout this lesson, you'll explore essential concepts and practical applications that form the foundation of modern programming development.\n\nVariables, data types, control structures, and basic algorithms This lesson builds upon previous concepts while introducing new techniques that will enhance your understanding and practical skills.\n\nBy the end of this lesson, you'll have hands-on experience with Logic and Algorithms, along with best practices for implementing these technologies in real-world scenarios. The knowledge gained here will prepare you for more advanced topics in subsequent lessons.\n\nKey areas we'll cover include practical implementation techniques, common challenges developers face, and proven solutions that industry professionals use daily. This lesson balances theoretical understanding with practical application, ensuring you can immediately apply what you learn.",
              "code": {
                "example": "// Example Logic implementation\n// TODO: Add specific code example for Programming Fundamentals\n\nfunction example() {\n    // Placeholder implementation\n    console.log('Programming Fundamentals example');\n}\n\nexport default example;",
                "explanation": "This example demonstrates the key concepts covered in this lesson.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following Logic best practices",
                  "solution": "Review official documentation and established patterns for Logic",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling in implementation",
                  "solution": "Always implement proper error handling and validation",
                  "severity": "high"
                },
                {
                  "mistake": "Ignoring performance implications",
                  "solution": "Consider performance impact of your implementation choices",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice Practical Applications",
                  "description": "Apply the concepts learned in this lesson through hands-on practice.",
                  "checkpoints": [
                    "Complete the basic implementation",
                    "Test your solution",
                    "Identify areas for improvement"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Beginner",
              "tags": [
                "Logic",
                "Algorithms",
                "Data Structures"
              ],
              "lastUpdated": "2025-10-01T06:42:16.314Z",
              "version": "1.0.0"
            },
            {
              "id": "programming-fundamentals-lesson-12",
              "moduleSlug": "programming-fundamentals",
              "title": "Review and Practice",
              "order": 12,
              "objectives": [
                "Apply advanced Logic techniques",
                "Optimize performance and efficiency",
                "Integrate with external systems"
              ],
              "intro": "Welcome to Review and Practice in the Programming Fundamentals module. \n\nThis lesson is part of the foundational tier, designed for beginner level learners. Throughout this lesson, you'll explore essential concepts and practical applications that form the foundation of modern programming development.\n\nVariables, data types, control structures, and basic algorithms This lesson builds upon previous concepts while introducing new techniques that will enhance your understanding and practical skills.\n\nBy the end of this lesson, you'll have hands-on experience with Logic and Algorithms, along with best practices for implementing these technologies in real-world scenarios. The knowledge gained here will prepare you for more advanced topics in subsequent lessons.\n\nKey areas we'll cover include practical implementation techniques, common challenges developers face, and proven solutions that industry professionals use daily. This lesson balances theoretical understanding with practical application, ensuring you can immediately apply what you learn.",
              "code": {
                "example": "// Example Logic implementation\n// TODO: Add specific code example for Programming Fundamentals\n\nfunction example() {\n    // Placeholder implementation\n    console.log('Programming Fundamentals example');\n}\n\nexport default example;",
                "explanation": "This example demonstrates the key concepts covered in this lesson.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following Logic best practices",
                  "solution": "Review official documentation and established patterns for Logic",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling in implementation",
                  "solution": "Always implement proper error handling and validation",
                  "severity": "high"
                },
                {
                  "mistake": "Ignoring performance implications",
                  "solution": "Consider performance impact of your implementation choices",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice Review and Practice",
                  "description": "Apply the concepts learned in this lesson through hands-on practice.",
                  "checkpoints": [
                    "Complete the basic implementation",
                    "Test your solution",
                    "Identify areas for improvement"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Beginner",
              "tags": [
                "Logic",
                "Algorithms",
                "Data Structures"
              ],
              "lastUpdated": "2025-10-01T06:42:16.314Z",
              "version": "1.0.0"
            }
          ],
          "issues": []
        },
        "quiz": {
          "exists": true,
          "count": 15,
          "questions": [
            {
              "id": "programming-fundamentals-q1",
              "question": "Which variable declaration is most appropriate for storing a user's age that might change over time?",
              "topic": "Variables",
              "difficulty": "Beginner",
              "choices": [
                "let age = 25;",
                "const age = 25;",
                "var age = 25;",
                "age = 25;"
              ],
              "correctIndex": 0,
              "explanation": "'let' is the correct choice because the user's age might change (when they have a birthday), so we need a variable that can be reassigned. 'const' is for constants that never change, 'var' has scope issues and should be avoided in modern JavaScript, and declaring without a keyword creates a global variable which is dangerous.",
              "industryContext": "In professional development, choosing the right variable declaration prevents bugs and makes code intentions clear to other developers.",
              "tags": [
                "foundational",
                "beginner"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "programming-fundamentals-q2",
              "question": "What will this code output?\n\nlet x = 5;\nif (x > 3) {\n    console.log('A');\n} else if (x > 7) {\n    console.log('B');\n} else {\n    console.log('C');\n}",
              "topic": "Control Structures",
              "difficulty": "Beginner",
              "choices": [
                "A",
                "B",
                "C",
                "Nothing (no output)"
              ],
              "correctIndex": 0,
              "explanation": "The code will output 'A'. Since x = 5 and 5 > 3 is true, the first condition is met and 'A' is logged. The else if condition (x > 7) is never checked because the first condition was already true. In if-else chains, only the first true condition executes.",
              "industryContext": "Understanding conditional flow is crucial for implementing business logic, user authentication, and decision-making features in applications.",
              "tags": [
                "foundational",
                "beginner"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "programming-fundamentals-q3",
              "question": "Which function definition follows best practices for a function that calculates the total price including tax?",
              "topic": "Functions",
              "difficulty": "Intermediate",
              "choices": [
                "function calculateTotalPrice(price, taxRate) { return price + (price * taxRate); }",
                "function calc(p, t) { return p + p * t; }",
                "function calculatePrice() { return price + tax; }",
                "const calculate = () => { console.log(price * 1.08); }"
              ],
              "correctIndex": 0,
              "explanation": "Option A follows best practices with a descriptive function name, clear parameter names, and returns a value instead of just logging. Option B uses unclear abbreviations, Option C relies on global variables which is bad practice, and Option D doesn't return a value and hardcodes the tax rate.",
              "industryContext": "Clear function names and proper parameter handling are essential for maintainable code in team environments and large applications.",
              "tags": [
                "foundational",
                "intermediate"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "programming-fundamentals-q4",
              "question": "What is wrong with this loop and how would you fix it?\n\nlet i = 0;\nwhile (i < 10) {\n    console.log(i);\n    // Missing something here\n}",
              "topic": "Control Structures",
              "difficulty": "Beginner",
              "choices": [
                "Missing i++ or i = i + 1 to increment the counter",
                "Should use for loop instead of while loop",
                "The condition should be i <= 10",
                "Need to declare i inside the loop"
              ],
              "correctIndex": 0,
              "explanation": "The loop is missing the increment statement (i++ or i = i + 1). Without incrementing i, the condition i < 10 will always be true, creating an infinite loop that will crash the program. The counter variable must be updated inside the loop body.",
              "industryContext": "Infinite loops are a common bug that can crash applications or freeze user interfaces. Always ensure loop conditions will eventually become false.",
              "tags": [
                "foundational",
                "beginner"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "programming-fundamentals-q5",
              "question": "Which data type should you use to store whether a user is currently logged in?",
              "topic": "Data Types",
              "difficulty": "Beginner",
              "choices": [
                "boolean",
                "string",
                "number",
                "array"
              ],
              "correctIndex": 0,
              "explanation": "Boolean is the correct data type for true/false values like login status. A boolean can only be true or false, making it perfect for yes/no, on/off, or logged-in/logged-out states. Strings and numbers could work but waste memory and allow invalid values.",
              "industryContext": "Using appropriate data types prevents bugs, saves memory, and makes code self-documenting. Booleans are essential for feature flags, user permissions, and application state.",
              "tags": [
                "foundational",
                "beginner"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "programming-fundamentals-q6",
              "question": "What will happen when this function is called with calculateDiscount(100)?\n\nfunction calculateDiscount(price, discountRate = 0.1) {\n    return price * discountRate;\n}",
              "topic": "Functions",
              "difficulty": "Intermediate",
              "choices": [
                "Returns 10 (using default discount rate of 0.1)",
                "Returns an error because discountRate is missing",
                "Returns 0 because discountRate is undefined",
                "Returns 100 because no discount is applied"
              ],
              "correctIndex": 0,
              "explanation": "The function will return 10. When discountRate is not provided, it uses the default value of 0.1. So 100 * 0.1 = 10. Default parameters allow functions to work even when some arguments are omitted, making them more flexible and user-friendly.",
              "industryContext": "Default parameters are essential for creating flexible APIs and functions that work in multiple scenarios without requiring all arguments every time.",
              "tags": [
                "foundational",
                "intermediate"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "programming-fundamentals-q7",
              "question": "What are the performance considerations when using Logic?",
              "topic": "Algorithms",
              "difficulty": "Intermediate",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of Logic concepts. The correct answer demonstrates proper implementation of Programming Fundamentals principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding Logic is crucial for building scalable and maintainable applications.",
              "tags": [
                "foundational",
                "intermediate"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "programming-fundamentals-q8",
              "question": "How do you troubleshoot complex Logic issues?",
              "topic": "Data Structures",
              "difficulty": "Advanced",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of Logic concepts. The correct answer demonstrates proper implementation of Programming Fundamentals principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding Logic is crucial for building scalable and maintainable applications.",
              "tags": [
                "foundational",
                "advanced"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "programming-fundamentals-q9",
              "question": "How would you optimize Logic for large-scale applications?",
              "topic": "Logic",
              "difficulty": "Advanced",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of Logic concepts. The correct answer demonstrates proper implementation of Programming Fundamentals principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding Logic is crucial for building scalable and maintainable applications.",
              "tags": [
                "foundational",
                "advanced"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "programming-fundamentals-q10",
              "question": "Which of the following is a key feature of Programming Fundamentals?",
              "topic": "Algorithms",
              "difficulty": "Beginner",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of Logic concepts. The correct answer demonstrates proper implementation of Programming Fundamentals principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding Logic is crucial for building scalable and maintainable applications.",
              "tags": [
                "foundational",
                "beginner"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "programming-fundamentals-q11",
              "question": "When should you use Logic in development?",
              "topic": "Data Structures",
              "difficulty": "Beginner",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of Logic concepts. The correct answer demonstrates proper implementation of Programming Fundamentals principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding Logic is crucial for building scalable and maintainable applications.",
              "tags": [
                "foundational",
                "beginner"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "programming-fundamentals-q12",
              "question": "How do you implement Logic in a production environment?",
              "topic": "Logic",
              "difficulty": "Intermediate",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of Logic concepts. The correct answer demonstrates proper implementation of Programming Fundamentals principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding Logic is crucial for building scalable and maintainable applications.",
              "tags": [
                "foundational",
                "intermediate"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "programming-fundamentals-q13",
              "question": "What are the performance considerations when using Logic?",
              "topic": "Algorithms",
              "difficulty": "Intermediate",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of Logic concepts. The correct answer demonstrates proper implementation of Programming Fundamentals principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding Logic is crucial for building scalable and maintainable applications.",
              "tags": [
                "foundational",
                "intermediate"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "programming-fundamentals-q14",
              "question": "Which pattern is most effective for Logic architecture?",
              "topic": "Data Structures",
              "difficulty": "Intermediate",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of Logic concepts. The correct answer demonstrates proper implementation of Programming Fundamentals principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding Logic is crucial for building scalable and maintainable applications.",
              "tags": [
                "foundational",
                "intermediate"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "programming-fundamentals-q15",
              "question": "How do you implement Logic in a production environment?",
              "topic": "Logic",
              "difficulty": "Intermediate",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of Logic concepts. The correct answer demonstrates proper implementation of Programming Fundamentals principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding Logic is crucial for building scalable and maintainable applications.",
              "tags": [
                "foundational",
                "intermediate"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            }
          ],
          "issues": []
        },
        "meetsThresholds": true,
        "issues": []
      },
      "web-fundamentals": {
        "slug": "web-fundamentals",
        "title": "Web Development Basics",
        "tier": "foundational",
        "track": "Frontend",
        "difficulty": "Beginner",
        "thresholds": {
          "requiredLessons": 15,
          "requiredQuestions": 20
        },
        "lessons": {
          "exists": true,
          "count": 15,
          "lessons": [
            {
              "id": "web-fundamentals-lesson-1",
              "moduleSlug": "web-fundamentals",
              "title": "HTML5 Semantic Elements",
              "order": 1,
              "objectives": [
                "Understand HTML5 document structure and semantic elements",
                "Create accessible and SEO-friendly markup",
                "Learn proper HTML5 form elements and validation"
              ],
              "intro": "HTML5 semantic elements provide meaningful structure to web documents, making them accessible to screen readers and search engines while improving code maintainability.\n\nIn this lesson, you'll learn about semantic elements like header, nav, main, article, section, and footer that replace generic div elements. These elements convey meaning about the content they contain, making your websites more accessible.\n\nProper HTML structure is the foundation of web development. You'll discover how semantic markup improves SEO rankings, helps assistive technologies understand your content, and creates a logical document outline.\n\nHTML5 also introduced new form input types and validation attributes that enhance user experience without requiring JavaScript. You'll learn about email, date, number inputs and built-in validation features.\n\nBy mastering semantic HTML5, you'll create websites that are accessible to all users, rank better in search engines, and provide a solid foundation for CSS styling and JavaScript interactions. This knowledge is essential for modern web development.",
              "code": {
                "example": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Semantic HTML5 Example</title>\n</head>\n<body>\n    <!-- Main page header -->\n    <header>\n        <h1>My Blog</h1>\n        <nav>\n            <ul>\n                <li><a href=\"#home\">Home</a></li>\n                <li><a href=\"#about\">About</a></li>\n                <li><a href=\"#contact\">Contact</a></li>\n            </ul>\n        </nav>\n    </header>\n\n    <!-- Main content area -->\n    <main>\n        <article>\n            <header>\n                <h2>Understanding Semantic HTML</h2>\n                <time datetime=\"2024-01-15\">January 15, 2024</time>\n            </header>\n            <p>Semantic HTML provides meaning to web content...</p>\n            <section>\n                <h3>Benefits of Semantic HTML</h3>\n                <ul>\n                    <li>Better accessibility</li>\n                    <li>Improved SEO</li>\n                    <li>Cleaner code structure</li>\n                </ul>\n            </section>\n        </article>\n\n        <!-- Contact form with HTML5 validation -->\n        <section>\n            <h3>Contact Form</h3>\n            <form action=\"/submit\" method=\"post\">\n                <div>\n                    <label for=\"name\">Name:</label>\n                    <input type=\"text\" id=\"name\" name=\"name\" required>\n                </div>\n                <div>\n                    <label for=\"email\">Email:</label>\n                    <input type=\"email\" id=\"email\" name=\"email\" required>\n                </div>\n                <div>\n                    <label for=\"phone\">Phone:</label>\n                    <input type=\"tel\" id=\"phone\" name=\"phone\" pattern=\"[0-9]{3}-[0-9]{3}-[0-9]{4}\">\n                </div>\n                <div>\n                    <label for=\"birthdate\">Birth Date:</label>\n                    <input type=\"date\" id=\"birthdate\" name=\"birthdate\">\n                </div>\n                <button type=\"submit\">Submit</button>\n            </form>\n        </section>\n    </main>\n\n    <!-- Sidebar content -->\n    <aside>\n        <section>\n            <h3>Related Articles</h3>\n            <ul>\n                <li><a href=\"#\">CSS Grid Layout</a></li>\n                <li><a href=\"#\">JavaScript ES6</a></li>\n            </ul>\n        </section>\n    </aside>\n\n    <!-- Page footer -->\n    <footer>\n        <p>&copy; 2024 My Blog. All rights reserved.</p>\n    </footer>\n</body>\n</html>",
                "explanation": "This example demonstrates semantic HTML5 elements including header, nav, main, article, section, aside, and footer. Notice the proper nesting, accessibility features like labels and ARIA attributes, and HTML5 form validation.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Using div elements instead of semantic HTML5 elements",
                  "solution": "Use header, nav, main, article, section, aside, footer for better accessibility and SEO",
                  "severity": "medium"
                },
                {
                  "mistake": "Missing alt attributes on images",
                  "solution": "Always include descriptive alt text for images to support screen readers",
                  "severity": "high"
                },
                {
                  "mistake": "Not associating form labels with input elements",
                  "solution": "Use the 'for' attribute on labels to connect them with input 'id' attributes",
                  "severity": "high"
                }
              ],
              "exercises": [
                {
                  "title": "Build a Semantic Blog Post",
                  "description": "Create a complete blog post page using semantic HTML5 elements and proper form validation.",
                  "checkpoints": [
                    "Use semantic elements (header, nav, main, article, aside, footer)",
                    "Create a contact form with HTML5 input types and validation",
                    "Include proper heading hierarchy (h1, h2, h3)",
                    "Validate your HTML using the W3C validator"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Beginner",
              "tags": [
                "HTML5",
                "CSS3",
                "JavaScript"
              ],
              "lastUpdated": "2025-10-01T06:42:16.315Z",
              "version": "1.0.0"
            },
            {
              "id": "web-fundamentals-lesson-2",
              "moduleSlug": "web-fundamentals",
              "title": "CSS3 Layout and Styling",
              "order": 2,
              "objectives": [
                "Master CSS3 layout techniques (Flexbox and Grid)",
                "Implement responsive design with media queries",
                "Apply modern CSS3 features and animations"
              ],
              "intro": "CSS3 provides powerful layout systems and styling capabilities that make creating beautiful, responsive websites easier than ever. Modern CSS eliminates the need for complex float-based layouts.\n\nIn this lesson, you'll master Flexbox for one-dimensional layouts and CSS Grid for two-dimensional layouts. These layout systems are essential for creating professional, responsive designs that work across all devices.\n\nResponsive design ensures your websites look great on smartphones, tablets, and desktops. You'll learn media queries, flexible units, and responsive design patterns that adapt to different screen sizes.\n\nCSS3 also introduces powerful visual effects including transitions, animations, transforms, and advanced selectors. These features help create engaging user experiences without requiring JavaScript.\n\nBy the end of this lesson, you'll confidently create responsive layouts, implement smooth animations, and use modern CSS3 features to build visually appealing websites that work perfectly across all devices and browsers.",
              "code": {
                "example": "/* Modern CSS3 Layout and Styling */\n\n/* CSS Reset and Base Styles */\n* {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n}\n\nbody {\n    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n    line-height: 1.6;\n    color: #333;\n}\n\n/* Flexbox Layout for Navigation */\n.navbar {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    padding: 1rem 2rem;\n    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n    color: white;\n}\n\n.nav-links {\n    display: flex;\n    list-style: none;\n    gap: 2rem;\n}\n\n.nav-links a {\n    color: white;\n    text-decoration: none;\n    transition: opacity 0.3s ease;\n}\n\n.nav-links a:hover {\n    opacity: 0.8;\n}\n\n/* CSS Grid Layout for Main Content */\n.container {\n    display: grid;\n    grid-template-columns: 1fr 300px;\n    grid-template-rows: auto 1fr auto;\n    grid-template-areas:\n        'header header'\n        'main sidebar'\n        'footer footer';\n    min-height: 100vh;\n    gap: 2rem;\n    padding: 2rem;\n}\n\n.header { grid-area: header; }\n.main { grid-area: main; }\n.sidebar { grid-area: sidebar; }\n.footer { grid-area: footer; }\n\n/* Card Component with Modern CSS */\n.card {\n    background: white;\n    border-radius: 12px;\n    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);\n    padding: 2rem;\n    transition: transform 0.3s ease, box-shadow 0.3s ease;\n}\n\n.card:hover {\n    transform: translateY(-5px);\n    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);\n}\n\n/* CSS3 Animations */\n@keyframes fadeInUp {\n    from {\n        opacity: 0;\n        transform: translateY(30px);\n    }\n    to {\n        opacity: 1;\n        transform: translateY(0);\n    }\n}\n\n.animate-in {\n    animation: fadeInUp 0.6s ease forwards;\n}\n\n/* Responsive Design with Media Queries */\n@media (max-width: 768px) {\n    .container {\n        grid-template-columns: 1fr;\n        grid-template-areas:\n            'header'\n            'main'\n            'sidebar'\n            'footer';\n    }\n    \n    .navbar {\n        flex-direction: column;\n        gap: 1rem;\n    }\n    \n    .nav-links {\n        flex-direction: column;\n        text-align: center;\n        gap: 1rem;\n    }\n}\n\n/* Modern CSS Features */\n.button {\n    background: linear-gradient(45deg, #667eea, #764ba2);\n    color: white;\n    border: none;\n    padding: 1rem 2rem;\n    border-radius: 8px;\n    cursor: pointer;\n    font-weight: 600;\n    transition: all 0.3s ease;\n    position: relative;\n    overflow: hidden;\n}\n\n.button::before {\n    content: '';\n    position: absolute;\n    top: 0;\n    left: -100%;\n    width: 100%;\n    height: 100%;\n    background: rgba(255, 255, 255, 0.2);\n    transition: left 0.5s ease;\n}\n\n.button:hover::before {\n    left: 100%;\n}",
                "explanation": "This example demonstrates modern CSS3 features including Flexbox, Grid, gradients, animations, transitions, media queries, and advanced selectors. Notice the responsive design patterns and modern visual effects.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Using floats instead of Flexbox or Grid for layout",
                  "solution": "Use modern layout systems like Flexbox for 1D layouts and Grid for 2D layouts",
                  "severity": "medium"
                },
                {
                  "mistake": "Not using relative units (rem, em, %) for responsive design",
                  "solution": "Use relative units and avoid fixed pixel values for better responsiveness",
                  "severity": "medium"
                },
                {
                  "mistake": "Missing vendor prefixes for CSS3 properties",
                  "solution": "Use autoprefixer or include vendor prefixes for older browser support",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Responsive Portfolio Layout",
                  "description": "Create a responsive portfolio website using CSS Grid and Flexbox with animations.",
                  "checkpoints": [
                    "Build a responsive navigation using Flexbox",
                    "Create a portfolio grid layout using CSS Grid",
                    "Add CSS3 animations and transitions",
                    "Test responsiveness across different screen sizes"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Beginner",
              "tags": [
                "HTML5",
                "CSS3",
                "JavaScript"
              ],
              "lastUpdated": "2025-10-01T06:42:16.315Z",
              "version": "1.0.0"
            },
            {
              "id": "web-fundamentals-lesson-3",
              "moduleSlug": "web-fundamentals",
              "title": "Getting Started",
              "order": 3,
              "objectives": [
                "Apply advanced HTML5 techniques",
                "Optimize performance and efficiency",
                "Integrate with external systems"
              ],
              "intro": "Welcome to Getting Started in the Web Development Basics module. \n\nThis lesson is part of the foundational tier, designed for beginner level learners. Throughout this lesson, you'll explore essential concepts and practical applications that form the foundation of modern frontend development.\n\nHTML5, CSS3, JavaScript fundamentals, and DOM manipulation This lesson builds upon previous concepts while introducing new techniques that will enhance your understanding and practical skills.\n\nBy the end of this lesson, you'll have hands-on experience with HTML5 and CSS3, along with best practices for implementing these technologies in real-world scenarios. The knowledge gained here will prepare you for more advanced topics in subsequent lessons.\n\nKey areas we'll cover include practical implementation techniques, common challenges developers face, and proven solutions that industry professionals use daily. This lesson balances theoretical understanding with practical application, ensuring you can immediately apply what you learn.",
              "code": {
                "example": "// Example HTML5 implementation\n// TODO: Add specific code example for Web Development Basics\n\nfunction example() {\n    // Placeholder implementation\n    console.log('Web Development Basics example');\n}\n\nexport default example;",
                "explanation": "This example demonstrates the key concepts covered in this lesson.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following HTML5 best practices",
                  "solution": "Review official documentation and established patterns for HTML5",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling in implementation",
                  "solution": "Always implement proper error handling and validation",
                  "severity": "high"
                },
                {
                  "mistake": "Ignoring performance implications",
                  "solution": "Consider performance impact of your implementation choices",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice Getting Started",
                  "description": "Apply the concepts learned in this lesson through hands-on practice.",
                  "checkpoints": [
                    "Complete the basic implementation",
                    "Test your solution",
                    "Identify areas for improvement"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Beginner",
              "tags": [
                "HTML5",
                "CSS3",
                "JavaScript"
              ],
              "lastUpdated": "2025-10-01T06:42:16.315Z",
              "version": "1.0.0"
            },
            {
              "id": "web-fundamentals-lesson-4",
              "moduleSlug": "web-fundamentals",
              "title": "Core Fundamentals",
              "order": 4,
              "objectives": [
                "Apply advanced HTML5 techniques",
                "Optimize performance and efficiency",
                "Integrate with external systems"
              ],
              "intro": "Welcome to Core Fundamentals in the Web Development Basics module. \n\nThis lesson is part of the foundational tier, designed for beginner level learners. Throughout this lesson, you'll explore essential concepts and practical applications that form the foundation of modern frontend development.\n\nHTML5, CSS3, JavaScript fundamentals, and DOM manipulation This lesson builds upon previous concepts while introducing new techniques that will enhance your understanding and practical skills.\n\nBy the end of this lesson, you'll have hands-on experience with HTML5 and CSS3, along with best practices for implementing these technologies in real-world scenarios. The knowledge gained here will prepare you for more advanced topics in subsequent lessons.\n\nKey areas we'll cover include practical implementation techniques, common challenges developers face, and proven solutions that industry professionals use daily. This lesson balances theoretical understanding with practical application, ensuring you can immediately apply what you learn.",
              "code": {
                "example": "// Example HTML5 implementation\n// TODO: Add specific code example for Web Development Basics\n\nfunction example() {\n    // Placeholder implementation\n    console.log('Web Development Basics example');\n}\n\nexport default example;",
                "explanation": "This example demonstrates the key concepts covered in this lesson.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following HTML5 best practices",
                  "solution": "Review official documentation and established patterns for HTML5",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling in implementation",
                  "solution": "Always implement proper error handling and validation",
                  "severity": "high"
                },
                {
                  "mistake": "Ignoring performance implications",
                  "solution": "Consider performance impact of your implementation choices",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice Core Fundamentals",
                  "description": "Apply the concepts learned in this lesson through hands-on practice.",
                  "checkpoints": [
                    "Complete the basic implementation",
                    "Test your solution",
                    "Identify areas for improvement"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Beginner",
              "tags": [
                "HTML5",
                "CSS3",
                "JavaScript"
              ],
              "lastUpdated": "2025-10-01T06:42:16.315Z",
              "version": "1.0.0"
            },
            {
              "id": "web-fundamentals-lesson-5",
              "moduleSlug": "web-fundamentals",
              "title": "Essential Patterns",
              "order": 5,
              "objectives": [
                "Apply advanced HTML5 techniques",
                "Optimize performance and efficiency",
                "Integrate with external systems"
              ],
              "intro": "Welcome to Essential Patterns in the Web Development Basics module. \n\nThis lesson is part of the foundational tier, designed for beginner level learners. Throughout this lesson, you'll explore essential concepts and practical applications that form the foundation of modern frontend development.\n\nHTML5, CSS3, JavaScript fundamentals, and DOM manipulation This lesson builds upon previous concepts while introducing new techniques that will enhance your understanding and practical skills.\n\nBy the end of this lesson, you'll have hands-on experience with HTML5 and CSS3, along with best practices for implementing these technologies in real-world scenarios. The knowledge gained here will prepare you for more advanced topics in subsequent lessons.\n\nKey areas we'll cover include practical implementation techniques, common challenges developers face, and proven solutions that industry professionals use daily. This lesson balances theoretical understanding with practical application, ensuring you can immediately apply what you learn.",
              "code": {
                "example": "// Example HTML5 implementation\n// TODO: Add specific code example for Web Development Basics\n\nfunction example() {\n    // Placeholder implementation\n    console.log('Web Development Basics example');\n}\n\nexport default example;",
                "explanation": "This example demonstrates the key concepts covered in this lesson.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following HTML5 best practices",
                  "solution": "Review official documentation and established patterns for HTML5",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling in implementation",
                  "solution": "Always implement proper error handling and validation",
                  "severity": "high"
                },
                {
                  "mistake": "Ignoring performance implications",
                  "solution": "Consider performance impact of your implementation choices",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice Essential Patterns",
                  "description": "Apply the concepts learned in this lesson through hands-on practice.",
                  "checkpoints": [
                    "Complete the basic implementation",
                    "Test your solution",
                    "Identify areas for improvement"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Beginner",
              "tags": [
                "HTML5",
                "CSS3",
                "JavaScript"
              ],
              "lastUpdated": "2025-10-01T06:42:16.315Z",
              "version": "1.0.0"
            },
            {
              "id": "web-fundamentals-lesson-6",
              "moduleSlug": "web-fundamentals",
              "title": "Building Blocks",
              "order": 6,
              "objectives": [
                "Apply advanced HTML5 techniques",
                "Optimize performance and efficiency",
                "Integrate with external systems"
              ],
              "intro": "Welcome to Building Blocks in the Web Development Basics module. \n\nThis lesson is part of the foundational tier, designed for beginner level learners. Throughout this lesson, you'll explore essential concepts and practical applications that form the foundation of modern frontend development.\n\nHTML5, CSS3, JavaScript fundamentals, and DOM manipulation This lesson builds upon previous concepts while introducing new techniques that will enhance your understanding and practical skills.\n\nBy the end of this lesson, you'll have hands-on experience with HTML5 and CSS3, along with best practices for implementing these technologies in real-world scenarios. The knowledge gained here will prepare you for more advanced topics in subsequent lessons.\n\nKey areas we'll cover include practical implementation techniques, common challenges developers face, and proven solutions that industry professionals use daily. This lesson balances theoretical understanding with practical application, ensuring you can immediately apply what you learn.",
              "code": {
                "example": "<!-- HTML5 Semantic Structure -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Interactive Web Component</title>\n  <style>\n    /* CSS3 Building Blocks */\n    .container {\n      max-width: 800px;\n      margin: 0 auto;\n      padding: 20px;\n      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n    }\n    \n    .card {\n      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n      border-radius: 12px;\n      padding: 24px;\n      margin: 16px 0;\n      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);\n      transition: transform 0.3s ease, box-shadow 0.3s ease;\n      position: relative;\n      overflow: hidden;\n    }\n    \n    .card:hover {\n      transform: translateY(-4px);\n      box-shadow: 0 8px 30px rgba(0, 0, 0, 0.15);\n    }\n    \n    .card::before {\n      content: '';\n      position: absolute;\n      top: 0;\n      left: 0;\n      right: 0;\n      height: 3px;\n      background: linear-gradient(90deg, #ff6b6b, #4ecdc4, #45b7d1);\n    }\n    \n    .card-title {\n      color: white;\n      margin: 0 0 16px 0;\n      font-size: 1.5rem;\n      font-weight: 600;\n    }\n    \n    .card-content {\n      color: rgba(255, 255, 255, 0.9);\n      line-height: 1.6;\n    }\n    \n    .interactive-button {\n      background: rgba(255, 255, 255, 0.2);\n      border: 2px solid rgba(255, 255, 255, 0.3);\n      color: white;\n      padding: 12px 24px;\n      border-radius: 8px;\n      cursor: pointer;\n      transition: all 0.3s ease;\n      margin-top: 16px;\n      backdrop-filter: blur(10px);\n    }\n    \n    .interactive-button:hover {\n      background: rgba(255, 255, 255, 0.3);\n      border-color: rgba(255, 255, 255, 0.5);\n      transform: scale(1.02);\n    }\n    \n    .progress-bar {\n      width: 100%;\n      height: 8px;\n      background: rgba(255, 255, 255, 0.2);\n      border-radius: 4px;\n      margin: 16px 0;\n      overflow: hidden;\n    }\n    \n    .progress-fill {\n      height: 100%;\n      background: linear-gradient(90deg, #ff6b6b, #4ecdc4);\n      border-radius: 4px;\n      width: 0%;\n      transition: width 0.5s ease;\n    }\n    \n    @media (max-width: 768px) {\n      .container {\n        padding: 12px;\n      }\n      \n      .card {\n        padding: 16px;\n        margin: 12px 0;\n      }\n    }\n  </style>\n</head>\n<body>\n  <div class=\"container\">\n    <header>\n      <h1>Modern Web Building Blocks</h1>\n    </header>\n    \n    <main>\n      <article class=\"card\" id=\"interactive-card\">\n        <h2 class=\"card-title\">Interactive Component</h2>\n        <div class=\"card-content\">\n          <p>This component demonstrates HTML5 semantic structure, CSS3 modern styling, and JavaScript interactivity.</p>\n          <div class=\"progress-bar\">\n            <div class=\"progress-fill\" id=\"progress\"></div>\n          </div>\n          <button class=\"interactive-button\" onclick=\"animateProgress()\">\n            Animate Progress\n          </button>\n          <button class=\"interactive-button\" onclick=\"toggleTheme()\">\n            Toggle Theme\n          </button>\n        </div>\n      </article>\n    </main>\n  </div>\n\n  <script>\n    // JavaScript Building Blocks\n    let currentProgress = 0;\n    let isDarkTheme = false;\n    \n    // Progressive enhancement\n    document.addEventListener('DOMContentLoaded', function() {\n      console.log('DOM fully loaded - ready for interaction');\n      \n      // Add smooth scrolling behavior\n      document.documentElement.style.scrollBehavior = 'smooth';\n      \n      // Initialize progress bar\n      updateProgress(25);\n    });\n    \n    function animateProgress() {\n      const progressBar = document.getElementById('progress');\n      const targetProgress = Math.min(currentProgress + 25, 100);\n      \n      // Animate progress incrementally\n      const animationDuration = 500;\n      const steps = 20;\n      const increment = (targetProgress - currentProgress) / steps;\n      let step = 0;\n      \n      const animation = setInterval(() => {\n        step++;\n        currentProgress += increment;\n        progressBar.style.width = currentProgress + '%';\n        \n        if (step >= steps) {\n          clearInterval(animation);\n          currentProgress = targetProgress;\n          \n          // Reset if at 100%\n          if (currentProgress >= 100) {\n            setTimeout(() => {\n              currentProgress = 0;\n              progressBar.style.width = '0%';\n            }, 1000);\n          }\n        }\n      }, animationDuration / steps);\n    }\n    \n    function updateProgress(value) {\n      const progressBar = document.getElementById('progress');\n      currentProgress = Math.max(0, Math.min(100, value));\n      progressBar.style.width = currentProgress + '%';\n    }\n    \n    function toggleTheme() {\n      const card = document.getElementById('interactive-card');\n      const body = document.body;\n      \n      isDarkTheme = !isDarkTheme;\n      \n      if (isDarkTheme) {\n        body.style.backgroundColor = '#1a1a1a';\n        body.style.color = '#ffffff';\n        card.style.background = 'linear-gradient(135deg, #2c3e50 0%, #34495e 100%)';\n      } else {\n        body.style.backgroundColor = '';\n        body.style.color = '';\n        card.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';\n      }\n      \n      // Provide visual feedback\n      const button = event.target;\n      button.textContent = isDarkTheme ? 'Light Theme' : 'Toggle Theme';\n      \n      // Add animation class\n      card.style.transform = 'scale(1.02)';\n      setTimeout(() => {\n        card.style.transform = '';\n      }, 200);\n    }\n    \n    // Touch/mobile support\n    document.addEventListener('touchstart', function() {}, {passive: true});\n    \n    // Keyboard accessibility\n    document.addEventListener('keydown', function(e) {\n      if (e.key === 'Enter' || e.key === ' ') {\n        if (e.target.classList.contains('interactive-button')) {\n          e.target.click();\n        }\n      }\n    });\n  </script>\n</body>\n</html>",
                "explanation": "This comprehensive example demonstrates the fundamental building blocks of modern web development: semantic HTML5 structure with proper document outline, CSS3 features including gradients, transitions, responsive design, and accessibility considerations, plus JavaScript for DOM manipulation, event handling, animations, and progressive enhancement. The code showcases real-world patterns used in production websites.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following HTML5 best practices",
                  "solution": "Review official documentation and established patterns for HTML5",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling in implementation",
                  "solution": "Always implement proper error handling and validation",
                  "severity": "high"
                },
                {
                  "mistake": "Ignoring performance implications",
                  "solution": "Consider performance impact of your implementation choices",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice Building Blocks",
                  "description": "Apply the concepts learned in this lesson through hands-on practice.",
                  "checkpoints": [
                    "Complete the basic implementation",
                    "Test your solution",
                    "Identify areas for improvement"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Beginner",
              "tags": [
                "HTML5",
                "CSS3",
                "JavaScript"
              ],
              "lastUpdated": "2025-10-01T06:42:16.315Z",
              "version": "1.0.0"
            },
            {
              "id": "web-fundamentals-lesson-7",
              "moduleSlug": "web-fundamentals",
              "title": "First Steps",
              "order": 7,
              "objectives": [
                "Apply advanced HTML5 techniques",
                "Optimize performance and efficiency",
                "Integrate with external systems"
              ],
              "intro": "Welcome to First Steps in the Web Development Basics module. \n\nThis lesson is part of the foundational tier, designed for beginner level learners. Throughout this lesson, you'll explore essential concepts and practical applications that form the foundation of modern frontend development.\n\nHTML5, CSS3, JavaScript fundamentals, and DOM manipulation This lesson builds upon previous concepts while introducing new techniques that will enhance your understanding and practical skills.\n\nBy the end of this lesson, you'll have hands-on experience with HTML5 and CSS3, along with best practices for implementing these technologies in real-world scenarios. The knowledge gained here will prepare you for more advanced topics in subsequent lessons.\n\nKey areas we'll cover include practical implementation techniques, common challenges developers face, and proven solutions that industry professionals use daily. This lesson balances theoretical understanding with practical application, ensuring you can immediately apply what you learn.",
              "code": {
                "example": "// Example HTML5 implementation\n// TODO: Add specific code example for Web Development Basics\n\nfunction example() {\n    // Placeholder implementation\n    console.log('Web Development Basics example');\n}\n\nexport default example;",
                "explanation": "This example demonstrates the key concepts covered in this lesson.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following HTML5 best practices",
                  "solution": "Review official documentation and established patterns for HTML5",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling in implementation",
                  "solution": "Always implement proper error handling and validation",
                  "severity": "high"
                },
                {
                  "mistake": "Ignoring performance implications",
                  "solution": "Consider performance impact of your implementation choices",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice First Steps",
                  "description": "Apply the concepts learned in this lesson through hands-on practice.",
                  "checkpoints": [
                    "Complete the basic implementation",
                    "Test your solution",
                    "Identify areas for improvement"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Beginner",
              "tags": [
                "HTML5",
                "CSS3",
                "JavaScript"
              ],
              "lastUpdated": "2025-10-01T06:42:16.315Z",
              "version": "1.0.0"
            },
            {
              "id": "web-fundamentals-lesson-8",
              "moduleSlug": "web-fundamentals",
              "title": "Understanding Basics",
              "order": 8,
              "objectives": [
                "Apply advanced HTML5 techniques",
                "Optimize performance and efficiency",
                "Integrate with external systems"
              ],
              "intro": "Welcome to Understanding Basics in the Web Development Basics module. \n\nThis lesson is part of the foundational tier, designed for beginner level learners. Throughout this lesson, you'll explore essential concepts and practical applications that form the foundation of modern frontend development.\n\nHTML5, CSS3, JavaScript fundamentals, and DOM manipulation This lesson builds upon previous concepts while introducing new techniques that will enhance your understanding and practical skills.\n\nBy the end of this lesson, you'll have hands-on experience with HTML5 and CSS3, along with best practices for implementing these technologies in real-world scenarios. The knowledge gained here will prepare you for more advanced topics in subsequent lessons.\n\nKey areas we'll cover include practical implementation techniques, common challenges developers face, and proven solutions that industry professionals use daily. This lesson balances theoretical understanding with practical application, ensuring you can immediately apply what you learn.",
              "code": {
                "example": "// Example HTML5 implementation\n// TODO: Add specific code example for Web Development Basics\n\nfunction example() {\n    // Placeholder implementation\n    console.log('Web Development Basics example');\n}\n\nexport default example;",
                "explanation": "This example demonstrates the key concepts covered in this lesson.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following HTML5 best practices",
                  "solution": "Review official documentation and established patterns for HTML5",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling in implementation",
                  "solution": "Always implement proper error handling and validation",
                  "severity": "high"
                },
                {
                  "mistake": "Ignoring performance implications",
                  "solution": "Consider performance impact of your implementation choices",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice Understanding Basics",
                  "description": "Apply the concepts learned in this lesson through hands-on practice.",
                  "checkpoints": [
                    "Complete the basic implementation",
                    "Test your solution",
                    "Identify areas for improvement"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Beginner",
              "tags": [
                "HTML5",
                "CSS3",
                "JavaScript"
              ],
              "lastUpdated": "2025-10-01T06:42:16.315Z",
              "version": "1.0.0"
            },
            {
              "id": "web-fundamentals-lesson-9",
              "moduleSlug": "web-fundamentals",
              "title": "Key Concepts",
              "order": 9,
              "objectives": [
                "Apply advanced HTML5 techniques",
                "Optimize performance and efficiency",
                "Integrate with external systems"
              ],
              "intro": "Welcome to Key Concepts in the Web Development Basics module. \n\nThis lesson is part of the foundational tier, designed for beginner level learners. Throughout this lesson, you'll explore essential concepts and practical applications that form the foundation of modern frontend development.\n\nHTML5, CSS3, JavaScript fundamentals, and DOM manipulation This lesson builds upon previous concepts while introducing new techniques that will enhance your understanding and practical skills.\n\nBy the end of this lesson, you'll have hands-on experience with HTML5 and CSS3, along with best practices for implementing these technologies in real-world scenarios. The knowledge gained here will prepare you for more advanced topics in subsequent lessons.\n\nKey areas we'll cover include practical implementation techniques, common challenges developers face, and proven solutions that industry professionals use daily. This lesson balances theoretical understanding with practical application, ensuring you can immediately apply what you learn.",
              "code": {
                "example": "// Example HTML5 implementation\n// TODO: Add specific code example for Web Development Basics\n\nfunction example() {\n    // Placeholder implementation\n    console.log('Web Development Basics example');\n}\n\nexport default example;",
                "explanation": "This example demonstrates the key concepts covered in this lesson.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following HTML5 best practices",
                  "solution": "Review official documentation and established patterns for HTML5",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling in implementation",
                  "solution": "Always implement proper error handling and validation",
                  "severity": "high"
                },
                {
                  "mistake": "Ignoring performance implications",
                  "solution": "Consider performance impact of your implementation choices",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice Key Concepts",
                  "description": "Apply the concepts learned in this lesson through hands-on practice.",
                  "checkpoints": [
                    "Complete the basic implementation",
                    "Test your solution",
                    "Identify areas for improvement"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Beginner",
              "tags": [
                "HTML5",
                "CSS3",
                "JavaScript"
              ],
              "lastUpdated": "2025-10-01T06:42:16.315Z",
              "version": "1.0.0"
            },
            {
              "id": "web-fundamentals-lesson-10",
              "moduleSlug": "web-fundamentals",
              "title": "Foundation Knowledge",
              "order": 10,
              "objectives": [
                "Apply advanced HTML5 techniques",
                "Optimize performance and efficiency",
                "Integrate with external systems"
              ],
              "intro": "Welcome to Foundation Knowledge in the Web Development Basics module. \n\nThis lesson is part of the foundational tier, designed for beginner level learners. Throughout this lesson, you'll explore essential concepts and practical applications that form the foundation of modern frontend development.\n\nHTML5, CSS3, JavaScript fundamentals, and DOM manipulation This lesson builds upon previous concepts while introducing new techniques that will enhance your understanding and practical skills.\n\nBy the end of this lesson, you'll have hands-on experience with HTML5 and CSS3, along with best practices for implementing these technologies in real-world scenarios. The knowledge gained here will prepare you for more advanced topics in subsequent lessons.\n\nKey areas we'll cover include practical implementation techniques, common challenges developers face, and proven solutions that industry professionals use daily. This lesson balances theoretical understanding with practical application, ensuring you can immediately apply what you learn.",
              "code": {
                "example": "// Example HTML5 implementation\n// TODO: Add specific code example for Web Development Basics\n\nfunction example() {\n    // Placeholder implementation\n    console.log('Web Development Basics example');\n}\n\nexport default example;",
                "explanation": "This example demonstrates the key concepts covered in this lesson.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following HTML5 best practices",
                  "solution": "Review official documentation and established patterns for HTML5",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling in implementation",
                  "solution": "Always implement proper error handling and validation",
                  "severity": "high"
                },
                {
                  "mistake": "Ignoring performance implications",
                  "solution": "Consider performance impact of your implementation choices",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice Foundation Knowledge",
                  "description": "Apply the concepts learned in this lesson through hands-on practice.",
                  "checkpoints": [
                    "Complete the basic implementation",
                    "Test your solution",
                    "Identify areas for improvement"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Beginner",
              "tags": [
                "HTML5",
                "CSS3",
                "JavaScript"
              ],
              "lastUpdated": "2025-10-01T06:42:16.315Z",
              "version": "1.0.0"
            },
            {
              "id": "web-fundamentals-lesson-11",
              "moduleSlug": "web-fundamentals",
              "title": "Practical Applications",
              "order": 11,
              "objectives": [
                "Apply advanced HTML5 techniques",
                "Optimize performance and efficiency",
                "Integrate with external systems"
              ],
              "intro": "Welcome to Practical Applications in the Web Development Basics module. \n\nThis lesson is part of the foundational tier, designed for beginner level learners. Throughout this lesson, you'll explore essential concepts and practical applications that form the foundation of modern frontend development.\n\nHTML5, CSS3, JavaScript fundamentals, and DOM manipulation This lesson builds upon previous concepts while introducing new techniques that will enhance your understanding and practical skills.\n\nBy the end of this lesson, you'll have hands-on experience with HTML5 and CSS3, along with best practices for implementing these technologies in real-world scenarios. The knowledge gained here will prepare you for more advanced topics in subsequent lessons.\n\nKey areas we'll cover include practical implementation techniques, common challenges developers face, and proven solutions that industry professionals use daily. This lesson balances theoretical understanding with practical application, ensuring you can immediately apply what you learn.",
              "code": {
                "example": "// Example HTML5 implementation\n// TODO: Add specific code example for Web Development Basics\n\nfunction example() {\n    // Placeholder implementation\n    console.log('Web Development Basics example');\n}\n\nexport default example;",
                "explanation": "This example demonstrates the key concepts covered in this lesson.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following HTML5 best practices",
                  "solution": "Review official documentation and established patterns for HTML5",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling in implementation",
                  "solution": "Always implement proper error handling and validation",
                  "severity": "high"
                },
                {
                  "mistake": "Ignoring performance implications",
                  "solution": "Consider performance impact of your implementation choices",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice Practical Applications",
                  "description": "Apply the concepts learned in this lesson through hands-on practice.",
                  "checkpoints": [
                    "Complete the basic implementation",
                    "Test your solution",
                    "Identify areas for improvement"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Beginner",
              "tags": [
                "HTML5",
                "CSS3",
                "JavaScript"
              ],
              "lastUpdated": "2025-10-01T06:42:16.315Z",
              "version": "1.0.0"
            },
            {
              "id": "web-fundamentals-lesson-12",
              "moduleSlug": "web-fundamentals",
              "title": "Review and Practice",
              "order": 12,
              "objectives": [
                "Apply advanced HTML5 techniques",
                "Optimize performance and efficiency",
                "Integrate with external systems"
              ],
              "intro": "Welcome to Review and Practice in the Web Development Basics module. \n\nThis lesson is part of the foundational tier, designed for beginner level learners. Throughout this lesson, you'll explore essential concepts and practical applications that form the foundation of modern frontend development.\n\nHTML5, CSS3, JavaScript fundamentals, and DOM manipulation This lesson builds upon previous concepts while introducing new techniques that will enhance your understanding and practical skills.\n\nBy the end of this lesson, you'll have hands-on experience with HTML5 and CSS3, along with best practices for implementing these technologies in real-world scenarios. The knowledge gained here will prepare you for more advanced topics in subsequent lessons.\n\nKey areas we'll cover include practical implementation techniques, common challenges developers face, and proven solutions that industry professionals use daily. This lesson balances theoretical understanding with practical application, ensuring you can immediately apply what you learn.",
              "code": {
                "example": "// Example HTML5 implementation\n// TODO: Add specific code example for Web Development Basics\n\nfunction example() {\n    // Placeholder implementation\n    console.log('Web Development Basics example');\n}\n\nexport default example;",
                "explanation": "This example demonstrates the key concepts covered in this lesson.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following HTML5 best practices",
                  "solution": "Review official documentation and established patterns for HTML5",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling in implementation",
                  "solution": "Always implement proper error handling and validation",
                  "severity": "high"
                },
                {
                  "mistake": "Ignoring performance implications",
                  "solution": "Consider performance impact of your implementation choices",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice Review and Practice",
                  "description": "Apply the concepts learned in this lesson through hands-on practice.",
                  "checkpoints": [
                    "Complete the basic implementation",
                    "Test your solution",
                    "Identify areas for improvement"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Beginner",
              "tags": [
                "HTML5",
                "CSS3",
                "JavaScript"
              ],
              "lastUpdated": "2025-10-01T06:42:16.315Z",
              "version": "1.0.0"
            },
            {
              "id": "web-fundamentals-lesson-13",
              "moduleSlug": "web-fundamentals",
              "title": "Lesson 13",
              "order": 13,
              "objectives": [
                "Apply advanced HTML5 techniques",
                "Optimize performance and efficiency",
                "Integrate with external systems"
              ],
              "intro": "Welcome to Lesson 13 in the Web Development Basics module. \n\nThis lesson is part of the foundational tier, designed for beginner level learners. Throughout this lesson, you'll explore essential concepts and practical applications that form the foundation of modern frontend development.\n\nHTML5, CSS3, JavaScript fundamentals, and DOM manipulation This lesson builds upon previous concepts while introducing new techniques that will enhance your understanding and practical skills.\n\nBy the end of this lesson, you'll have hands-on experience with HTML5 and CSS3, along with best practices for implementing these technologies in real-world scenarios. The knowledge gained here will prepare you for more advanced topics in subsequent lessons.\n\nKey areas we'll cover include practical implementation techniques, common challenges developers face, and proven solutions that industry professionals use daily. This lesson balances theoretical understanding with practical application, ensuring you can immediately apply what you learn.",
              "code": {
                "example": "// Example HTML5 implementation\n// TODO: Add specific code example for Web Development Basics\n\nfunction example() {\n    // Placeholder implementation\n    console.log('Web Development Basics example');\n}\n\nexport default example;",
                "explanation": "This example demonstrates the key concepts covered in this lesson.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following HTML5 best practices",
                  "solution": "Review official documentation and established patterns for HTML5",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling in implementation",
                  "solution": "Always implement proper error handling and validation",
                  "severity": "high"
                },
                {
                  "mistake": "Ignoring performance implications",
                  "solution": "Consider performance impact of your implementation choices",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice Lesson 13",
                  "description": "Apply the concepts learned in this lesson through hands-on practice.",
                  "checkpoints": [
                    "Complete the basic implementation",
                    "Test your solution",
                    "Identify areas for improvement"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Beginner",
              "tags": [
                "HTML5",
                "CSS3",
                "JavaScript"
              ],
              "lastUpdated": "2025-10-01T06:42:16.315Z",
              "version": "1.0.0"
            },
            {
              "id": "web-fundamentals-lesson-14",
              "moduleSlug": "web-fundamentals",
              "title": "Lesson 14",
              "order": 14,
              "objectives": [
                "Apply advanced HTML5 techniques",
                "Optimize performance and efficiency",
                "Integrate with external systems"
              ],
              "intro": "Welcome to Lesson 14 in the Web Development Basics module. \n\nThis lesson is part of the foundational tier, designed for beginner level learners. Throughout this lesson, you'll explore essential concepts and practical applications that form the foundation of modern frontend development.\n\nHTML5, CSS3, JavaScript fundamentals, and DOM manipulation This lesson builds upon previous concepts while introducing new techniques that will enhance your understanding and practical skills.\n\nBy the end of this lesson, you'll have hands-on experience with HTML5 and CSS3, along with best practices for implementing these technologies in real-world scenarios. The knowledge gained here will prepare you for more advanced topics in subsequent lessons.\n\nKey areas we'll cover include practical implementation techniques, common challenges developers face, and proven solutions that industry professionals use daily. This lesson balances theoretical understanding with practical application, ensuring you can immediately apply what you learn.",
              "code": {
                "example": "// Example HTML5 implementation\n// TODO: Add specific code example for Web Development Basics\n\nfunction example() {\n    // Placeholder implementation\n    console.log('Web Development Basics example');\n}\n\nexport default example;",
                "explanation": "This example demonstrates the key concepts covered in this lesson.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following HTML5 best practices",
                  "solution": "Review official documentation and established patterns for HTML5",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling in implementation",
                  "solution": "Always implement proper error handling and validation",
                  "severity": "high"
                },
                {
                  "mistake": "Ignoring performance implications",
                  "solution": "Consider performance impact of your implementation choices",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice Lesson 14",
                  "description": "Apply the concepts learned in this lesson through hands-on practice.",
                  "checkpoints": [
                    "Complete the basic implementation",
                    "Test your solution",
                    "Identify areas for improvement"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Beginner",
              "tags": [
                "HTML5",
                "CSS3",
                "JavaScript"
              ],
              "lastUpdated": "2025-10-01T06:42:16.315Z",
              "version": "1.0.0"
            },
            {
              "id": "web-fundamentals-lesson-15",
              "moduleSlug": "web-fundamentals",
              "title": "Lesson 15",
              "order": 15,
              "objectives": [
                "Apply advanced HTML5 techniques",
                "Optimize performance and efficiency",
                "Integrate with external systems"
              ],
              "intro": "Welcome to Lesson 15 in the Web Development Basics module. \n\nThis lesson is part of the foundational tier, designed for beginner level learners. Throughout this lesson, you'll explore essential concepts and practical applications that form the foundation of modern frontend development.\n\nHTML5, CSS3, JavaScript fundamentals, and DOM manipulation This lesson builds upon previous concepts while introducing new techniques that will enhance your understanding and practical skills.\n\nBy the end of this lesson, you'll have hands-on experience with HTML5 and CSS3, along with best practices for implementing these technologies in real-world scenarios. The knowledge gained here will prepare you for more advanced topics in subsequent lessons.\n\nKey areas we'll cover include practical implementation techniques, common challenges developers face, and proven solutions that industry professionals use daily. This lesson balances theoretical understanding with practical application, ensuring you can immediately apply what you learn.",
              "code": {
                "example": "// Example HTML5 implementation\n// TODO: Add specific code example for Web Development Basics\n\nfunction example() {\n    // Placeholder implementation\n    console.log('Web Development Basics example');\n}\n\nexport default example;",
                "explanation": "This example demonstrates the key concepts covered in this lesson.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following HTML5 best practices",
                  "solution": "Review official documentation and established patterns for HTML5",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling in implementation",
                  "solution": "Always implement proper error handling and validation",
                  "severity": "high"
                },
                {
                  "mistake": "Ignoring performance implications",
                  "solution": "Consider performance impact of your implementation choices",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice Lesson 15",
                  "description": "Apply the concepts learned in this lesson through hands-on practice.",
                  "checkpoints": [
                    "Complete the basic implementation",
                    "Test your solution",
                    "Identify areas for improvement"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Beginner",
              "tags": [
                "HTML5",
                "CSS3",
                "JavaScript"
              ],
              "lastUpdated": "2025-10-01T06:42:16.315Z",
              "version": "1.0.0"
            }
          ],
          "issues": []
        },
        "quiz": {
          "exists": true,
          "count": 20,
          "questions": [
            {
              "id": "web-fundamentals-q1",
              "question": "Which HTML5 element should be used to wrap the main navigation links of a website?",
              "topic": "HTML5",
              "difficulty": "Beginner",
              "choices": [
                "<nav>",
                "<div>",
                "<header>",
                "<menu>"
              ],
              "correctIndex": 0,
              "explanation": "The <nav> element is specifically designed for navigation links. It provides semantic meaning that helps screen readers and search engines understand the purpose of the content. Using <div> provides no semantic value, while <header> is for page headers and <menu> is for interactive commands.",
              "industryContext": "Semantic HTML improves website accessibility for users with disabilities and helps search engines better understand and rank your content.",
              "tags": [
                "foundational",
                "beginner"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "web-fundamentals-q2",
              "question": "What is the correct CSS to center a div horizontally and vertically using Flexbox?",
              "topic": "CSS3",
              "difficulty": "Intermediate",
              "choices": [
                "display: flex; justify-content: center; align-items: center;",
                "display: flex; align-content: center; justify-items: center;",
                "display: block; text-align: center; vertical-align: middle;",
                "display: grid; place-items: center;"
              ],
              "correctIndex": 0,
              "explanation": "With Flexbox, 'justify-content: center' centers items horizontally (main axis) and 'align-items: center' centers them vertically (cross axis). Option D would work with CSS Grid, but the question specifically asks about Flexbox.",
              "industryContext": "Flexbox is the most common method for centering content in modern web development, replacing older techniques like floats and positioning.",
              "tags": [
                "foundational",
                "intermediate"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "web-fundamentals-q3",
              "question": "Which JavaScript method is used to select an element by its ID?",
              "topic": "JavaScript",
              "difficulty": "Beginner",
              "choices": [
                "document.getElementById('myId')",
                "document.querySelector('#myId')",
                "document.getElementByClass('myId')",
                "Both A and B are correct"
              ],
              "correctIndex": 3,
              "explanation": "Both document.getElementById('myId') and document.querySelector('#myId') can select an element by ID. getElementById is the traditional method, while querySelector is more flexible and can use any CSS selector. Option C is incorrect because it should be getElementsByClassName and it's for classes, not IDs.",
              "industryContext": "DOM manipulation is fundamental to interactive web development. Understanding different selection methods helps you choose the most efficient approach for your needs.",
              "tags": [
                "foundational",
                "beginner"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "web-fundamentals-q4",
              "question": "What does this CSS media query do?\n\n@media (max-width: 768px) { /* styles */ }",
              "topic": "CSS3",
              "difficulty": "Beginner",
              "choices": [
                "Applies styles when screen width is 768px or less",
                "Applies styles when screen width is exactly 768px",
                "Applies styles when screen width is more than 768px",
                "Only applies to tablets with 768px width"
              ],
              "correctIndex": 0,
              "explanation": "The 'max-width: 768px' media query applies styles when the viewport width is 768 pixels or smaller. This is commonly used for mobile-first responsive design to apply mobile styles on smaller screens.",
              "industryContext": "Media queries are essential for responsive web design, ensuring websites work well on mobile devices, tablets, and desktops. 768px is a common breakpoint for tablet/mobile design.",
              "tags": [
                "foundational",
                "beginner"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "web-fundamentals-q5",
              "question": "Which input type provides built-in email validation in HTML5?",
              "topic": "HTML5",
              "difficulty": "Beginner",
              "choices": [
                "<input type=\"email\">",
                "<input type=\"text\" pattern=\"email\">",
                "<input type=\"validation\" format=\"email\">",
                "<input type=\"text\" validate=\"email\">"
              ],
              "correctIndex": 0,
              "explanation": "HTML5 introduced the 'email' input type which automatically validates that the entered text follows email format (contains @ symbol and valid structure). Modern browsers will show validation errors if the format is incorrect.",
              "industryContext": "HTML5 form validation reduces the need for custom JavaScript validation and provides better user experience with instant feedback on form inputs.",
              "tags": [
                "foundational",
                "beginner"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "web-fundamentals-q6",
              "question": "How do you implement HTML5 in a production environment?",
              "topic": "JavaScript",
              "difficulty": "Intermediate",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of HTML5 concepts. The correct answer demonstrates proper implementation of Web Development Basics principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding HTML5 is crucial for building scalable and maintainable applications.",
              "tags": [
                "foundational",
                "intermediate"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "web-fundamentals-q7",
              "question": "What are the performance considerations when using HTML5?",
              "topic": "DOM",
              "difficulty": "Intermediate",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of HTML5 concepts. The correct answer demonstrates proper implementation of Web Development Basics principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding HTML5 is crucial for building scalable and maintainable applications.",
              "tags": [
                "foundational",
                "intermediate"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "web-fundamentals-q8",
              "question": "Which pattern is most effective for HTML5 architecture?",
              "topic": "HTML5",
              "difficulty": "Intermediate",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of HTML5 concepts. The correct answer demonstrates proper implementation of Web Development Basics principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding HTML5 is crucial for building scalable and maintainable applications.",
              "tags": [
                "foundational",
                "intermediate"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "web-fundamentals-q9",
              "question": "How do you implement HTML5 in a production environment?",
              "topic": "CSS3",
              "difficulty": "Intermediate",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of HTML5 concepts. The correct answer demonstrates proper implementation of Web Development Basics principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding HTML5 is crucial for building scalable and maintainable applications.",
              "tags": [
                "foundational",
                "intermediate"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "web-fundamentals-q10",
              "question": "Which of the following is a key feature of Web Development Basics?",
              "topic": "JavaScript",
              "difficulty": "Beginner",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of HTML5 concepts. The correct answer demonstrates proper implementation of Web Development Basics principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding HTML5 is crucial for building scalable and maintainable applications.",
              "tags": [
                "foundational",
                "beginner"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "web-fundamentals-q11",
              "question": "Which pattern is most effective for HTML5 architecture?",
              "topic": "DOM",
              "difficulty": "Intermediate",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of HTML5 concepts. The correct answer demonstrates proper implementation of Web Development Basics principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding HTML5 is crucial for building scalable and maintainable applications.",
              "tags": [
                "foundational",
                "intermediate"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "web-fundamentals-q12",
              "question": "How would you optimize HTML5 for large-scale applications?",
              "topic": "HTML5",
              "difficulty": "Advanced",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of HTML5 concepts. The correct answer demonstrates proper implementation of Web Development Basics principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding HTML5 is crucial for building scalable and maintainable applications.",
              "tags": [
                "foundational",
                "advanced"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "web-fundamentals-q13",
              "question": "What are the performance considerations when using HTML5?",
              "topic": "CSS3",
              "difficulty": "Intermediate",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of HTML5 concepts. The correct answer demonstrates proper implementation of Web Development Basics principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding HTML5 is crucial for building scalable and maintainable applications.",
              "tags": [
                "foundational",
                "intermediate"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "web-fundamentals-q14",
              "question": "When should you use HTML5 in development?",
              "topic": "JavaScript",
              "difficulty": "Beginner",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of HTML5 concepts. The correct answer demonstrates proper implementation of Web Development Basics principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding HTML5 is crucial for building scalable and maintainable applications.",
              "tags": [
                "foundational",
                "beginner"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "web-fundamentals-q15",
              "question": "How do you implement HTML5 in a production environment?",
              "topic": "DOM",
              "difficulty": "Intermediate",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of HTML5 concepts. The correct answer demonstrates proper implementation of Web Development Basics principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding HTML5 is crucial for building scalable and maintainable applications.",
              "tags": [
                "foundational",
                "intermediate"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "web-fundamentals-q16",
              "question": "Which of the following is a key feature of Web Development Basics?",
              "topic": "HTML5",
              "difficulty": "Beginner",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of HTML5 concepts. The correct answer demonstrates proper implementation of Web Development Basics principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding HTML5 is crucial for building scalable and maintainable applications.",
              "tags": [
                "foundational",
                "beginner"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "web-fundamentals-q17",
              "question": "How do you troubleshoot complex HTML5 issues?",
              "topic": "CSS3",
              "difficulty": "Advanced",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of HTML5 concepts. The correct answer demonstrates proper implementation of Web Development Basics principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding HTML5 is crucial for building scalable and maintainable applications.",
              "tags": [
                "foundational",
                "advanced"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "web-fundamentals-q18",
              "question": "How do you implement HTML5 in a production environment?",
              "topic": "JavaScript",
              "difficulty": "Intermediate",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of HTML5 concepts. The correct answer demonstrates proper implementation of Web Development Basics principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding HTML5 is crucial for building scalable and maintainable applications.",
              "tags": [
                "foundational",
                "intermediate"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "web-fundamentals-q19",
              "question": "Which of the following is a key feature of Web Development Basics?",
              "topic": "DOM",
              "difficulty": "Beginner",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of HTML5 concepts. The correct answer demonstrates proper implementation of Web Development Basics principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding HTML5 is crucial for building scalable and maintainable applications.",
              "tags": [
                "foundational",
                "beginner"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "web-fundamentals-q20",
              "question": "When should you use HTML5 in development?",
              "topic": "HTML5",
              "difficulty": "Beginner",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of HTML5 concepts. The correct answer demonstrates proper implementation of Web Development Basics principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding HTML5 is crucial for building scalable and maintainable applications.",
              "tags": [
                "foundational",
                "beginner"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            }
          ],
          "issues": []
        },
        "meetsThresholds": true,
        "issues": []
      },
      "version-control": {
        "slug": "version-control",
        "title": "Version Control with Git",
        "tier": "foundational",
        "track": "DevOps",
        "difficulty": "Beginner",
        "thresholds": {
          "requiredLessons": 10,
          "requiredQuestions": 15
        },
        "lessons": {
          "exists": true,
          "count": 10,
          "lessons": [
            {
              "id": "version-control-lesson-1",
              "moduleSlug": "version-control",
              "title": "Git Fundamentals and Setup",
              "order": 1,
              "objectives": [
                "Understand what version control is and why it's essential",
                "Install and configure Git with proper user settings",
                "Learn basic Git terminology and concepts"
              ],
              "intro": "Version control is the foundation of modern software development, allowing developers to track changes, collaborate effectively, and maintain project history safely. Git is the most widely used version control system in the industry.\n\nIn this lesson, you'll learn why version control is crucial for any development project, from solo work to large team collaborations. You'll understand how Git tracks file changes over time and enables multiple developers to work on the same codebase without conflicts.\n\nGit's distributed nature means every developer has a complete copy of the project history, making it robust and flexible. You'll discover how this differs from older centralized systems and why it's become the industry standard.\n\nProper Git configuration is essential for professional development workflows. You'll learn to set up your identity, configure helpful settings, and understand the basic Git workflow that you'll use throughout your development career.\n\nBy the end of this lesson, you'll have Git installed and configured correctly, understand fundamental concepts like repositories and commits, and be ready to start tracking your code changes professionally. This foundation is critical for all software development work.",
              "code": {
                "example": "# Git Installation and Configuration\n\n# Install Git (varies by operating system)\n# Windows: Download from git-scm.com\n# macOS: brew install git\n# Linux: sudo apt-get install git (Ubuntu/Debian)\n\n# Configure your identity (required for commits)\ngit config --global user.name \"Your Name\"\ngit config --global user.email \"your.email@example.com\"\n\n# Configure helpful settings\ngit config --global init.defaultBranch main\ngit config --global core.editor \"code --wait\"  # Use VS Code as editor\ngit config --global pull.rebase false  # Use merge strategy for pulls\n\n# Check your configuration\ngit config --list\n\n# Get help for any Git command\ngit help <command>\ngit <command> --help\n\n# Initialize a new Git repository\nmkdir my-project\ncd my-project\ngit init\n\n# Check repository status\ngit status\n\n# Create a simple README file\necho \"# My Project\" > README.md\n\n# Add file to staging area\ngit add README.md\n\n# Create your first commit\ngit commit -m \"Initial commit: Add README\"\n\n# View commit history\ngit log\ngit log --oneline  # Compact view\n\n# Check current branch\ngit branch\n\n# View repository status\ngit status",
                "explanation": "This example shows the complete Git setup process from installation to first commit. Notice the global configuration settings that will apply to all your Git repositories, and the basic workflow of add, commit, and status checking.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not configuring user.name and user.email before first commit",
                  "solution": "Always configure your Git identity with 'git config --global user.name' and 'user.email'",
                  "severity": "high"
                },
                {
                  "mistake": "Using 'git add .' without checking what files are being added",
                  "solution": "Use 'git status' first to see changes, then add files selectively or use 'git add -A' intentionally",
                  "severity": "medium"
                },
                {
                  "mistake": "Working without a .gitignore file",
                  "solution": "Create a .gitignore file to exclude build files, dependencies, and sensitive information",
                  "severity": "medium"
                }
              ],
              "exercises": [
                {
                  "title": "Setup Your First Git Repository",
                  "description": "Create a complete Git repository with proper configuration and initial commit.",
                  "checkpoints": [
                    "Install Git and verify the installation with 'git --version'",
                    "Configure your global Git settings (name, email, default branch)",
                    "Initialize a new repository and create a README.md file",
                    "Make your first commit and view the project history"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Beginner",
              "tags": [
                "Git",
                "GitHub",
                "Version Control"
              ],
              "lastUpdated": "2025-10-01T06:42:16.316Z",
              "version": "1.0.0"
            },
            {
              "id": "version-control-lesson-2",
              "moduleSlug": "version-control",
              "title": "Branching and Merging",
              "order": 2,
              "objectives": [
                "Create and switch between Git branches effectively",
                "Merge branches and resolve basic conflicts",
                "Understand different branching strategies and workflows"
              ],
              "intro": "Branching is one of Git's most powerful features, allowing developers to work on different features simultaneously without interfering with each other's code. Understanding branching is essential for professional development workflows.\n\nIn this lesson, you'll learn how branches allow you to experiment with new features, fix bugs, or try different approaches while keeping your main codebase stable. Each branch represents an independent line of development that can be merged back when ready.\n\nMerging combines changes from different branches, and while Git handles most merges automatically, you'll learn to resolve conflicts when the same code is modified in different ways. This skill is crucial for team collaboration.\n\nYou'll explore different branching strategies used in the industry, from simple feature branches to more complex workflows like Git Flow. Understanding these patterns helps you choose the right approach for your projects.\n\nBy mastering branching and merging, you'll be able to work confidently on multiple features simultaneously, collaborate effectively with team members, and maintain a clean, organized project history that reflects your development process.",
              "code": {
                "example": "# Git Branching and Merging Workflow\n\n# View all branches (local and remote)\ngit branch -a\n\n# Create a new branch for feature development\ngit branch feature/user-authentication\n# OR create and switch in one command\ngit checkout -b feature/user-authentication\n# OR using newer syntax\ngit switch -c feature/user-authentication\n\n# Switch between branches\ngit checkout main\ngit switch feature/user-authentication\n\n# Make changes and commit on feature branch\necho \"function login() { /* TODO */ }\" > auth.js\ngit add auth.js\ngit commit -m \"Add basic authentication function\"\n\n# Switch back to main and create another branch\ngit switch main\ngit switch -c feature/user-profile\n\n# Make different changes\necho \"function getUserProfile() { /* TODO */ }\" > profile.js\ngit add profile.js\ngit commit -m \"Add user profile function\"\n\n# Merge feature branch into main\ngit switch main\ngit merge feature/user-authentication\n\n# If there's a merge conflict, you'll see something like:\n# <<<<<<< HEAD\n# Your changes\n# =======\n# Incoming changes\n# >>>>>>> feature/user-authentication\n\n# Resolve conflicts by editing the file, then:\ngit add <conflicted-file>\ngit commit -m \"Resolve merge conflict\"\n\n# Delete merged branch (optional)\ngit branch -d feature/user-authentication\n\n# View branch history with graph\ngit log --oneline --graph --all\n\n# Create a merge commit even for fast-forward merges\ngit merge --no-ff feature/user-profile\n\n# Rebase instead of merge (alternative workflow)\ngit switch feature/user-profile\ngit rebase main\ngit switch main\ngit merge feature/user-profile  # This will be fast-forward\n\n# Undo a merge (if needed)\ngit reset --hard HEAD~1\n\n# View differences between branches\ngit diff main..feature/user-profile",
                "explanation": "This example demonstrates the complete branching workflow including creating branches, making commits, merging, and handling conflicts. Notice the different merge strategies and how to maintain a clean project history.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Working directly on the main branch for all changes",
                  "solution": "Create feature branches for new work and keep main stable and deployable",
                  "severity": "high"
                },
                {
                  "mistake": "Force pushing to shared branches",
                  "solution": "Never use 'git push --force' on branches that others are working on",
                  "severity": "high"
                },
                {
                  "mistake": "Not testing merged code before pushing",
                  "solution": "Always test the merged result before pushing to ensure functionality",
                  "severity": "medium"
                }
              ],
              "exercises": [
                {
                  "title": "Feature Branch Workflow",
                  "description": "Practice the complete feature branch workflow with merge conflict resolution.",
                  "checkpoints": [
                    "Create two feature branches with conflicting changes to the same file",
                    "Merge the first branch successfully into main",
                    "Attempt to merge the second branch and resolve the conflict",
                    "View the project history with git log --graph to see the branch structure"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Beginner",
              "tags": [
                "Git",
                "GitHub",
                "Version Control"
              ],
              "lastUpdated": "2025-10-01T06:42:16.316Z",
              "version": "1.0.0"
            },
            {
              "id": "version-control-lesson-3",
              "moduleSlug": "version-control",
              "title": "Getting Started",
              "order": 3,
              "objectives": [
                "Apply advanced Git techniques",
                "Optimize performance and efficiency",
                "Integrate with external systems"
              ],
              "intro": "Welcome to Getting Started in the Version Control with Git module. \n\nThis lesson is part of the foundational tier, designed for beginner level learners. Throughout this lesson, you'll explore essential concepts and practical applications that form the foundation of modern devops development.\n\nGit workflows, branching, merging, and collaboration This lesson builds upon previous concepts while introducing new techniques that will enhance your understanding and practical skills.\n\nBy the end of this lesson, you'll have hands-on experience with Git and GitHub, along with best practices for implementing these technologies in real-world scenarios. The knowledge gained here will prepare you for more advanced topics in subsequent lessons.\n\nKey areas we'll cover include practical implementation techniques, common challenges developers face, and proven solutions that industry professionals use daily. This lesson balances theoretical understanding with practical application, ensuring you can immediately apply what you learn.",
              "code": {
                "example": "// Example Git implementation\n// TODO: Add specific code example for Version Control with Git\n\nfunction example() {\n    // Placeholder implementation\n    console.log('Version Control with Git example');\n}\n\nexport default example;",
                "explanation": "This example demonstrates the key concepts covered in this lesson.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following Git best practices",
                  "solution": "Review official documentation and established patterns for Git",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling in implementation",
                  "solution": "Always implement proper error handling and validation",
                  "severity": "high"
                },
                {
                  "mistake": "Ignoring performance implications",
                  "solution": "Consider performance impact of your implementation choices",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice Getting Started",
                  "description": "Apply the concepts learned in this lesson through hands-on practice.",
                  "checkpoints": [
                    "Complete the basic implementation",
                    "Test your solution",
                    "Identify areas for improvement"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Beginner",
              "tags": [
                "Git",
                "GitHub",
                "Version Control"
              ],
              "lastUpdated": "2025-10-01T06:42:16.316Z",
              "version": "1.0.0"
            },
            {
              "id": "version-control-lesson-4",
              "moduleSlug": "version-control",
              "title": "Core Fundamentals",
              "order": 4,
              "objectives": [
                "Apply advanced Git techniques",
                "Optimize performance and efficiency",
                "Integrate with external systems"
              ],
              "intro": "Welcome to Core Fundamentals in the Version Control with Git module. \n\nThis lesson is part of the foundational tier, designed for beginner level learners. Throughout this lesson, you'll explore essential concepts and practical applications that form the foundation of modern devops development.\n\nGit workflows, branching, merging, and collaboration This lesson builds upon previous concepts while introducing new techniques that will enhance your understanding and practical skills.\n\nBy the end of this lesson, you'll have hands-on experience with Git and GitHub, along with best practices for implementing these technologies in real-world scenarios. The knowledge gained here will prepare you for more advanced topics in subsequent lessons.\n\nKey areas we'll cover include practical implementation techniques, common challenges developers face, and proven solutions that industry professionals use daily. This lesson balances theoretical understanding with practical application, ensuring you can immediately apply what you learn.",
              "code": {
                "example": "// Example Git implementation\n// TODO: Add specific code example for Version Control with Git\n\nfunction example() {\n    // Placeholder implementation\n    console.log('Version Control with Git example');\n}\n\nexport default example;",
                "explanation": "This example demonstrates the key concepts covered in this lesson.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following Git best practices",
                  "solution": "Review official documentation and established patterns for Git",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling in implementation",
                  "solution": "Always implement proper error handling and validation",
                  "severity": "high"
                },
                {
                  "mistake": "Ignoring performance implications",
                  "solution": "Consider performance impact of your implementation choices",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice Core Fundamentals",
                  "description": "Apply the concepts learned in this lesson through hands-on practice.",
                  "checkpoints": [
                    "Complete the basic implementation",
                    "Test your solution",
                    "Identify areas for improvement"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Beginner",
              "tags": [
                "Git",
                "GitHub",
                "Version Control"
              ],
              "lastUpdated": "2025-10-01T06:42:16.316Z",
              "version": "1.0.0"
            },
            {
              "id": "version-control-lesson-5",
              "moduleSlug": "version-control",
              "title": "Essential Patterns",
              "order": 5,
              "objectives": [
                "Apply advanced Git techniques",
                "Optimize performance and efficiency",
                "Integrate with external systems"
              ],
              "intro": "Welcome to Essential Patterns in the Version Control with Git module. \n\nThis lesson is part of the foundational tier, designed for beginner level learners. Throughout this lesson, you'll explore essential concepts and practical applications that form the foundation of modern devops development.\n\nGit workflows, branching, merging, and collaboration This lesson builds upon previous concepts while introducing new techniques that will enhance your understanding and practical skills.\n\nBy the end of this lesson, you'll have hands-on experience with Git and GitHub, along with best practices for implementing these technologies in real-world scenarios. The knowledge gained here will prepare you for more advanced topics in subsequent lessons.\n\nKey areas we'll cover include practical implementation techniques, common challenges developers face, and proven solutions that industry professionals use daily. This lesson balances theoretical understanding with practical application, ensuring you can immediately apply what you learn.",
              "code": {
                "example": "// Example Git implementation\n// TODO: Add specific code example for Version Control with Git\n\nfunction example() {\n    // Placeholder implementation\n    console.log('Version Control with Git example');\n}\n\nexport default example;",
                "explanation": "This example demonstrates the key concepts covered in this lesson.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following Git best practices",
                  "solution": "Review official documentation and established patterns for Git",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling in implementation",
                  "solution": "Always implement proper error handling and validation",
                  "severity": "high"
                },
                {
                  "mistake": "Ignoring performance implications",
                  "solution": "Consider performance impact of your implementation choices",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice Essential Patterns",
                  "description": "Apply the concepts learned in this lesson through hands-on practice.",
                  "checkpoints": [
                    "Complete the basic implementation",
                    "Test your solution",
                    "Identify areas for improvement"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Beginner",
              "tags": [
                "Git",
                "GitHub",
                "Version Control"
              ],
              "lastUpdated": "2025-10-01T06:42:16.316Z",
              "version": "1.0.0"
            },
            {
              "id": "version-control-lesson-6",
              "moduleSlug": "version-control",
              "title": "Building Blocks",
              "order": 6,
              "objectives": [
                "Apply advanced Git techniques",
                "Optimize performance and efficiency",
                "Integrate with external systems"
              ],
              "intro": "Welcome to Building Blocks in the Version Control with Git module. \n\nThis lesson is part of the foundational tier, designed for beginner level learners. Throughout this lesson, you'll explore essential concepts and practical applications that form the foundation of modern devops development.\n\nGit workflows, branching, merging, and collaboration This lesson builds upon previous concepts while introducing new techniques that will enhance your understanding and practical skills.\n\nBy the end of this lesson, you'll have hands-on experience with Git and GitHub, along with best practices for implementing these technologies in real-world scenarios. The knowledge gained here will prepare you for more advanced topics in subsequent lessons.\n\nKey areas we'll cover include practical implementation techniques, common challenges developers face, and proven solutions that industry professionals use daily. This lesson balances theoretical understanding with practical application, ensuring you can immediately apply what you learn.",
              "code": {
                "example": "// Example Git implementation\n// TODO: Add specific code example for Version Control with Git\n\nfunction example() {\n    // Placeholder implementation\n    console.log('Version Control with Git example');\n}\n\nexport default example;",
                "explanation": "This example demonstrates the key concepts covered in this lesson.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following Git best practices",
                  "solution": "Review official documentation and established patterns for Git",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling in implementation",
                  "solution": "Always implement proper error handling and validation",
                  "severity": "high"
                },
                {
                  "mistake": "Ignoring performance implications",
                  "solution": "Consider performance impact of your implementation choices",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice Building Blocks",
                  "description": "Apply the concepts learned in this lesson through hands-on practice.",
                  "checkpoints": [
                    "Complete the basic implementation",
                    "Test your solution",
                    "Identify areas for improvement"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Beginner",
              "tags": [
                "Git",
                "GitHub",
                "Version Control"
              ],
              "lastUpdated": "2025-10-01T06:42:16.316Z",
              "version": "1.0.0"
            },
            {
              "id": "version-control-lesson-7",
              "moduleSlug": "version-control",
              "title": "First Steps",
              "order": 7,
              "objectives": [
                "Apply advanced Git techniques",
                "Optimize performance and efficiency",
                "Integrate with external systems"
              ],
              "intro": "Welcome to First Steps in the Version Control with Git module. \n\nThis lesson is part of the foundational tier, designed for beginner level learners. Throughout this lesson, you'll explore essential concepts and practical applications that form the foundation of modern devops development.\n\nGit workflows, branching, merging, and collaboration This lesson builds upon previous concepts while introducing new techniques that will enhance your understanding and practical skills.\n\nBy the end of this lesson, you'll have hands-on experience with Git and GitHub, along with best practices for implementing these technologies in real-world scenarios. The knowledge gained here will prepare you for more advanced topics in subsequent lessons.\n\nKey areas we'll cover include practical implementation techniques, common challenges developers face, and proven solutions that industry professionals use daily. This lesson balances theoretical understanding with practical application, ensuring you can immediately apply what you learn.",
              "code": {
                "example": "// Example Git implementation\n// TODO: Add specific code example for Version Control with Git\n\nfunction example() {\n    // Placeholder implementation\n    console.log('Version Control with Git example');\n}\n\nexport default example;",
                "explanation": "This example demonstrates the key concepts covered in this lesson.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following Git best practices",
                  "solution": "Review official documentation and established patterns for Git",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling in implementation",
                  "solution": "Always implement proper error handling and validation",
                  "severity": "high"
                },
                {
                  "mistake": "Ignoring performance implications",
                  "solution": "Consider performance impact of your implementation choices",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice First Steps",
                  "description": "Apply the concepts learned in this lesson through hands-on practice.",
                  "checkpoints": [
                    "Complete the basic implementation",
                    "Test your solution",
                    "Identify areas for improvement"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Beginner",
              "tags": [
                "Git",
                "GitHub",
                "Version Control"
              ],
              "lastUpdated": "2025-10-01T06:42:16.316Z",
              "version": "1.0.0"
            },
            {
              "id": "version-control-lesson-8",
              "moduleSlug": "version-control",
              "title": "Understanding Basics",
              "order": 8,
              "objectives": [
                "Apply advanced Git techniques",
                "Optimize performance and efficiency",
                "Integrate with external systems"
              ],
              "intro": "Welcome to Understanding Basics in the Version Control with Git module. \n\nThis lesson is part of the foundational tier, designed for beginner level learners. Throughout this lesson, you'll explore essential concepts and practical applications that form the foundation of modern devops development.\n\nGit workflows, branching, merging, and collaboration This lesson builds upon previous concepts while introducing new techniques that will enhance your understanding and practical skills.\n\nBy the end of this lesson, you'll have hands-on experience with Git and GitHub, along with best practices for implementing these technologies in real-world scenarios. The knowledge gained here will prepare you for more advanced topics in subsequent lessons.\n\nKey areas we'll cover include practical implementation techniques, common challenges developers face, and proven solutions that industry professionals use daily. This lesson balances theoretical understanding with practical application, ensuring you can immediately apply what you learn.",
              "code": {
                "example": "// Example Git implementation\n// TODO: Add specific code example for Version Control with Git\n\nfunction example() {\n    // Placeholder implementation\n    console.log('Version Control with Git example');\n}\n\nexport default example;",
                "explanation": "This example demonstrates the key concepts covered in this lesson.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following Git best practices",
                  "solution": "Review official documentation and established patterns for Git",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling in implementation",
                  "solution": "Always implement proper error handling and validation",
                  "severity": "high"
                },
                {
                  "mistake": "Ignoring performance implications",
                  "solution": "Consider performance impact of your implementation choices",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice Understanding Basics",
                  "description": "Apply the concepts learned in this lesson through hands-on practice.",
                  "checkpoints": [
                    "Complete the basic implementation",
                    "Test your solution",
                    "Identify areas for improvement"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Beginner",
              "tags": [
                "Git",
                "GitHub",
                "Version Control"
              ],
              "lastUpdated": "2025-10-01T06:42:16.316Z",
              "version": "1.0.0"
            },
            {
              "id": "version-control-lesson-9",
              "moduleSlug": "version-control",
              "title": "Key Concepts",
              "order": 9,
              "objectives": [
                "Apply advanced Git techniques",
                "Optimize performance and efficiency",
                "Integrate with external systems"
              ],
              "intro": "Welcome to Key Concepts in the Version Control with Git module. \n\nThis lesson is part of the foundational tier, designed for beginner level learners. Throughout this lesson, you'll explore essential concepts and practical applications that form the foundation of modern devops development.\n\nGit workflows, branching, merging, and collaboration This lesson builds upon previous concepts while introducing new techniques that will enhance your understanding and practical skills.\n\nBy the end of this lesson, you'll have hands-on experience with Git and GitHub, along with best practices for implementing these technologies in real-world scenarios. The knowledge gained here will prepare you for more advanced topics in subsequent lessons.\n\nKey areas we'll cover include practical implementation techniques, common challenges developers face, and proven solutions that industry professionals use daily. This lesson balances theoretical understanding with practical application, ensuring you can immediately apply what you learn.",
              "code": {
                "example": "// Example Git implementation\n// TODO: Add specific code example for Version Control with Git\n\nfunction example() {\n    // Placeholder implementation\n    console.log('Version Control with Git example');\n}\n\nexport default example;",
                "explanation": "This example demonstrates the key concepts covered in this lesson.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following Git best practices",
                  "solution": "Review official documentation and established patterns for Git",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling in implementation",
                  "solution": "Always implement proper error handling and validation",
                  "severity": "high"
                },
                {
                  "mistake": "Ignoring performance implications",
                  "solution": "Consider performance impact of your implementation choices",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice Key Concepts",
                  "description": "Apply the concepts learned in this lesson through hands-on practice.",
                  "checkpoints": [
                    "Complete the basic implementation",
                    "Test your solution",
                    "Identify areas for improvement"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Beginner",
              "tags": [
                "Git",
                "GitHub",
                "Version Control"
              ],
              "lastUpdated": "2025-10-01T06:42:16.316Z",
              "version": "1.0.0"
            },
            {
              "id": "version-control-lesson-10",
              "moduleSlug": "version-control",
              "title": "Foundation Knowledge",
              "order": 10,
              "objectives": [
                "Apply advanced Git techniques",
                "Optimize performance and efficiency",
                "Integrate with external systems"
              ],
              "intro": "Welcome to Foundation Knowledge in the Version Control with Git module. \n\nThis lesson is part of the foundational tier, designed for beginner level learners. Throughout this lesson, you'll explore essential concepts and practical applications that form the foundation of modern devops development.\n\nGit workflows, branching, merging, and collaboration This lesson builds upon previous concepts while introducing new techniques that will enhance your understanding and practical skills.\n\nBy the end of this lesson, you'll have hands-on experience with Git and GitHub, along with best practices for implementing these technologies in real-world scenarios. The knowledge gained here will prepare you for more advanced topics in subsequent lessons.\n\nKey areas we'll cover include practical implementation techniques, common challenges developers face, and proven solutions that industry professionals use daily. This lesson balances theoretical understanding with practical application, ensuring you can immediately apply what you learn.",
              "code": {
                "example": "// Example Git implementation\n// TODO: Add specific code example for Version Control with Git\n\nfunction example() {\n    // Placeholder implementation\n    console.log('Version Control with Git example');\n}\n\nexport default example;",
                "explanation": "This example demonstrates the key concepts covered in this lesson.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following Git best practices",
                  "solution": "Review official documentation and established patterns for Git",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling in implementation",
                  "solution": "Always implement proper error handling and validation",
                  "severity": "high"
                },
                {
                  "mistake": "Ignoring performance implications",
                  "solution": "Consider performance impact of your implementation choices",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice Foundation Knowledge",
                  "description": "Apply the concepts learned in this lesson through hands-on practice.",
                  "checkpoints": [
                    "Complete the basic implementation",
                    "Test your solution",
                    "Identify areas for improvement"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Beginner",
              "tags": [
                "Git",
                "GitHub",
                "Version Control"
              ],
              "lastUpdated": "2025-10-01T06:42:16.316Z",
              "version": "1.0.0"
            }
          ],
          "issues": []
        },
        "quiz": {
          "exists": true,
          "count": 15,
          "questions": [
            {
              "id": "version-control-q1",
              "question": "Which command is used to create a new Git repository in the current directory?",
              "topic": "Git",
              "difficulty": "Beginner",
              "choices": [
                "git init",
                "git create",
                "git new",
                "git start"
              ],
              "correctIndex": 0,
              "explanation": "The 'git init' command initializes a new Git repository in the current directory, creating a .git folder that contains all the repository metadata. This is the first step in version controlling any project.",
              "industryContext": "Every software project should be version controlled from the start. 'git init' is often the first command developers run when starting a new project.",
              "tags": [
                "foundational",
                "beginner"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "version-control-q2",
              "question": "What is the correct workflow to commit changes in Git?",
              "topic": "Git",
              "difficulty": "Beginner",
              "choices": [
                "git add  git commit",
                "git commit  git add",
                "git push  git commit",
                "git commit only (no add needed)"
              ],
              "correctIndex": 0,
              "explanation": "The correct Git workflow is to first stage changes with 'git add' (adding them to the staging area), then commit them with 'git commit'. This two-step process allows you to carefully control which changes are included in each commit.",
              "industryContext": "The staging area is a key feature that sets Git apart from other version control systems, allowing developers to craft precise, logical commits.",
              "tags": [
                "foundational",
                "beginner"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "version-control-q3",
              "question": "Which command creates a new branch AND switches to it immediately?",
              "topic": "Git",
              "difficulty": "Intermediate",
              "choices": [
                "git checkout -b feature-branch",
                "git branch feature-branch",
                "git switch feature-branch",
                "git create feature-branch"
              ],
              "correctIndex": 0,
              "explanation": "'git checkout -b feature-branch' creates a new branch called 'feature-branch' and immediately switches to it. The newer equivalent is 'git switch -c feature-branch'. Option B only creates the branch without switching to it.",
              "industryContext": "Feature branches are essential for team development, allowing developers to work on different features simultaneously without interfering with each other's code.",
              "tags": [
                "foundational",
                "intermediate"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "version-control-q4",
              "question": "What happens when you encounter a merge conflict in Git?",
              "topic": "Git",
              "difficulty": "Intermediate",
              "choices": [
                "Git stops the merge and requires manual resolution",
                "Git automatically chooses the newer version",
                "Git automatically chooses the older version",
                "Git creates two separate files"
              ],
              "correctIndex": 0,
              "explanation": "When Git encounters a merge conflict (same lines modified in different ways), it stops the merge process and marks the conflicted sections in the files. You must manually edit the files to resolve conflicts, then add and commit the resolved files.",
              "industryContext": "Merge conflicts are common in team development. Learning to resolve them efficiently is a crucial skill for collaborative software development.",
              "tags": [
                "foundational",
                "intermediate"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "version-control-q5",
              "question": "Which file is used to specify which files Git should ignore?",
              "topic": "Git",
              "difficulty": "Beginner",
              "choices": [
                ".gitignore",
                ".gitexclude",
                "ignore.txt",
                ".ignore"
              ],
              "correctIndex": 0,
              "explanation": "The '.gitignore' file contains patterns for files and directories that Git should not track. This is essential for excluding build artifacts, dependencies, IDE files, and sensitive information from version control.",
              "industryContext": "Every project should have a .gitignore file to prevent accidentally committing temporary files, build outputs, or sensitive information like API keys.",
              "tags": [
                "foundational",
                "beginner"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "version-control-q6",
              "question": "How do you implement Git in a production environment?",
              "topic": "Git",
              "difficulty": "Intermediate",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of Git concepts. The correct answer demonstrates proper implementation of Version Control with Git principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding Git is crucial for building scalable and maintainable applications.",
              "tags": [
                "foundational",
                "intermediate"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "version-control-q7",
              "question": "Which of the following is a key feature of Version Control with Git?",
              "topic": "GitHub",
              "difficulty": "Beginner",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of Git concepts. The correct answer demonstrates proper implementation of Version Control with Git principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding Git is crucial for building scalable and maintainable applications.",
              "tags": [
                "foundational",
                "beginner"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "version-control-q8",
              "question": "Which pattern is most effective for Git architecture?",
              "topic": "Version Control",
              "difficulty": "Intermediate",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of Git concepts. The correct answer demonstrates proper implementation of Version Control with Git principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding Git is crucial for building scalable and maintainable applications.",
              "tags": [
                "foundational",
                "intermediate"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "version-control-q9",
              "question": "What is the primary purpose of Git?",
              "topic": "Git",
              "difficulty": "Beginner",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of Git concepts. The correct answer demonstrates proper implementation of Version Control with Git principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding Git is crucial for building scalable and maintainable applications.",
              "tags": [
                "foundational",
                "beginner"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "version-control-q10",
              "question": "What are the trade-offs between different Git approaches?",
              "topic": "GitHub",
              "difficulty": "Advanced",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of Git concepts. The correct answer demonstrates proper implementation of Version Control with Git principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding Git is crucial for building scalable and maintainable applications.",
              "tags": [
                "foundational",
                "advanced"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "version-control-q11",
              "question": "When should you use Git in development?",
              "topic": "Version Control",
              "difficulty": "Beginner",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of Git concepts. The correct answer demonstrates proper implementation of Version Control with Git principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding Git is crucial for building scalable and maintainable applications.",
              "tags": [
                "foundational",
                "beginner"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "version-control-q12",
              "question": "What is the primary purpose of Git?",
              "topic": "Git",
              "difficulty": "Beginner",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of Git concepts. The correct answer demonstrates proper implementation of Version Control with Git principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding Git is crucial for building scalable and maintainable applications.",
              "tags": [
                "foundational",
                "beginner"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "version-control-q13",
              "question": "Which of the following is a key feature of Version Control with Git?",
              "topic": "GitHub",
              "difficulty": "Beginner",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of Git concepts. The correct answer demonstrates proper implementation of Version Control with Git principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding Git is crucial for building scalable and maintainable applications.",
              "tags": [
                "foundational",
                "beginner"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "version-control-q14",
              "question": "When should you use Git in development?",
              "topic": "Version Control",
              "difficulty": "Beginner",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of Git concepts. The correct answer demonstrates proper implementation of Version Control with Git principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding Git is crucial for building scalable and maintainable applications.",
              "tags": [
                "foundational",
                "beginner"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "version-control-q15",
              "question": "What is the primary purpose of Git?",
              "topic": "Git",
              "difficulty": "Beginner",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of Git concepts. The correct answer demonstrates proper implementation of Version Control with Git principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding Git is crucial for building scalable and maintainable applications.",
              "tags": [
                "foundational",
                "beginner"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            }
          ],
          "issues": []
        },
        "meetsThresholds": true,
        "issues": []
      },
      "dotnet-fundamentals": {
        "slug": "dotnet-fundamentals",
        "title": ".NET Core Fundamentals",
        "tier": "core",
        "track": "Backend",
        "difficulty": "Intermediate",
        "thresholds": {
          "requiredLessons": 18,
          "requiredQuestions": 25
        },
        "lessons": {
          "exists": true,
          "count": 18,
          "lessons": [
            {
              "id": "dotnet-fundamentals-lesson-1",
              "moduleSlug": "dotnet-fundamentals",
              "title": "Introduction to .NET and C#",
              "order": 1,
              "objectives": [
                "Understand the history and evolution of .NET platform",
                "Explain the key features of C# programming language",
                "Set up a development environment for .NET development"
              ],
              "intro": "The .NET platform, initially released by Microsoft in 2002, represents a revolutionary approach to software development that provides a managed execution environment, simplifying application development and deployment. .NET Framework was the original implementation, primarily for Windows, while .NET Core (released in 2016) was a cross-platform, open-source reimplementation that later evolved into .NET 5, 6, and 7.\n\nC# (pronounced \"C Sharp\") is a modern, object-oriented programming language designed specifically for the .NET platform. Created by Anders Hejlsberg, C# combines the power of C++ with the simplicity of Visual Basic. The language has continuously evolved, with C# 11 (released in November 2022) being the latest version at the time of this writing.\n\nUnderstanding .NET and C# is fundamental for modern software development, as they power everything from web applications to cloud services, desktop applications, and mobile apps. According to the Stack Overflow Developer Survey 2022, C# consistently ranks among the top 10 most popular programming languages, with .NET Core/.NET 5+ being among the most loved frameworks.",
              "code": {
                "example": "using System;\n\nnamespace DotNetIntroduction\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            // Basic console output\n            Console.WriteLine(\"Welcome to .NET Development!\");\n            \n            // String interpolation (C# 6.0+)\n            string name = \"Developer\";\n            Console.WriteLine($\"Hello, {name}! Today is {DateTime.Now:MMMM dd, yyyy}\");\n            \n            // Basic variable declaration and usage\n            int version = 7;\n            Console.WriteLine($\"You're learning .NET {version}\");\n            \n            // Simple method call\n            DisplayFrameworkFeatures();\n        }\n        \n        static void DisplayFrameworkFeatures()\n        {\n            string[] features = {\n                \"Cross-platform support\",\n                \"High performance\",\n                \"Automatic memory management\",\n                \"Rich class library\"\n            };\n            \n            Console.WriteLine(\"\\nKey .NET Features:\");\n            foreach (string feature in features)\n            {\n                Console.WriteLine($\" {feature}\");\n            }\n        }\n    }\n}",
                "explanation": "This example demonstrates several fundamental concepts of C# and .NET:\n\n1. **Namespace Declaration**: Organizes code into logical groups\n2. **Class and Method Structure**: The Main method is the entry point of all C# applications\n3. **String Interpolation**: Using $\"\" syntax for embedding expressions in strings (C# 6.0+)\n4. **DateTime Formatting**: Displaying dates in a human-readable format\n5. **Array Declaration and Usage**: Creating and iterating through arrays\n6. **foreach Loop**: Modern iteration syntax for collections\n7. **Static Methods**: Methods that belong to the class rather than an instance\n\nWhen executed, this program produces output similar to:\n```\nWelcome to .NET Development!\nHello, Developer! Today is October 02, 2025\nYou're learning .NET 7\n\nKey .NET Features:\n Cross-platform support\n High performance\n Automatic memory management\n Rich class library\n```",
                "language": "csharp"
              },
              "pitfalls": [
                {
                  "mistake": "Using outdated .NET Framework syntax in new .NET projects",
                  "solution": "Always use the latest .NET (Core) syntax and project structure. For example, use <Project Sdk=\"Microsoft.NET.Sdk\"> in project files rather than the older .NET Framework project format.",
                  "severity": "medium"
                },
                {
                  "mistake": "Not understanding the difference between .NET Framework, .NET Core, and .NET 5+",
                  "solution": "Recognize that .NET 5+ is the unified future of .NET development. .NET Framework is legacy and only supported on Windows, while .NET Core evolved into modern .NET.",
                  "severity": "high"
                },
                {
                  "mistake": "Ignoring the importance of the Common Language Runtime (CLR)",
                  "solution": "Understand that the CLR provides automatic memory management, exception handling, and security - key benefits of managed code execution.",
                  "severity": "medium"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Environment Setup and First Application",
                  "description": "Install the .NET SDK and create your first console application",
                  "checkpoints": [
                    "Install the latest .NET SDK from https://dotnet.microsoft.com/download",
                    "Create a new console application using 'dotnet new console'",
                    "Modify the program to display your name and the current date/time",
                    "Add a method that lists three technologies you want to learn"
                  ]
                }
              ],
              "next": [
                "dotnet-fundamentals-lesson-2"
              ],
              "estimatedMinutes": 30,
              "difficulty": "Beginner",
              "tags": [
                "Introduction",
                "dotnet",
                "C#",
                "Setup"
              ],
              "sources": [
                {
                  "title": "Microsoft .NET Documentation",
                  "url": "https://learn.microsoft.com/en-us/dotnet/"
                },
                {
                  "title": "C# Programming Guide",
                  "url": "https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/"
                }
              ],
              "lastUpdated": "2025-10-02T10:00:00.000Z",
              "version": "1.0.1"
            },
            {
              "id": "dotnet-fundamentals-lesson-2",
              "moduleSlug": "dotnet-fundamentals",
              "title": "Variables and Data Types",
              "order": 2,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Getting Started.\n\nUnderstand different data types in C# including value types, reference types, and how to declare and initialize variables.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "using System;\n\nclass Program\n{\n    static void Main()\n    {\n        // Value types\n        int age = 25;\n        double salary = 75000.50;\n        bool isEmployed = true;\n        char grade = 'A';\n        \n        // Reference types\n        string name = \"John Doe\";\n        \n        Console.WriteLine($\"Name: {name}\");\n        Console.WriteLine($\"Age: {age}\");\n        Console.WriteLine($\"Salary: {salary:C}\");\n        Console.WriteLine($\"Is Employed: {isEmployed}\");\n        Console.WriteLine($\"Grade: {grade}\");\n    }\n}",
                "explanation": "This example produces: Name: John Doe\nAge: 25\nSalary: $75,000.50\nIs Employed: True\nGrade: A\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "csharp"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Variables and Data Types",
                  "description": "Apply the concepts from this lesson on Getting Started",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Getting Started",
                "dotnet"
              ],
              "legacy": {
                "originalId": 2,
                "originalTopic": "Getting Started",
                "migrated": "2025-10-01T06:41:13.479Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.479Z",
              "version": "1.0.0"
            },
            {
              "id": "dotnet-fundamentals-lesson-3",
              "moduleSlug": "dotnet-fundamentals",
              "title": "Control Flow - Conditional Statements",
              "order": 3,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Core Concepts.\n\nLearn about conditional statements in C# including if-else, switch statements, and ternary operators for decision making.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "using System;\n\nclass Program\n{\n    static void Main()\n    {\n        int score = 85;\n        \n        // If-else statement\n        if (score >= 90)\n        {\n            Console.WriteLine(\"Grade: A\");\n        }\n        else if (score >= 80)\n        {\n            Console.WriteLine(\"Grade: B\");\n        }\n        else if (score >= 70)\n        {\n            Console.WriteLine(\"Grade: C\");\n        }\n        else\n        {\n            Console.WriteLine(\"Grade: F\");\n        }\n        \n        // Ternary operator\n        string result = score >= 60 ? \"Pass\" : \"Fail\";\n        Console.WriteLine($\"Result: {result}\");\n        \n        // Switch statement\n        DayOfWeek today = DateTime.Now.DayOfWeek;\n        switch (today)\n        {\n            case DayOfWeek.Monday:\n                Console.WriteLine(\"Start of work week!\");\n                break;\n            case DayOfWeek.Friday:\n                Console.WriteLine(\"TGIF!\");\n                break;\n            default:\n                Console.WriteLine($\"It's {today}\");\n                break;\n        }\n    }\n}",
                "explanation": "This example produces: Grade: B\nResult: Pass\nIt's [Current Day]\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "csharp"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Control Flow - Conditional Statements",
                  "description": "Apply the concepts from this lesson on Core Concepts",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Core Concepts",
                "dotnet"
              ],
              "legacy": {
                "originalId": 3,
                "originalTopic": "Core Concepts",
                "migrated": "2025-10-01T06:41:13.479Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.479Z",
              "version": "1.0.0"
            },
            {
              "id": "dotnet-fundamentals-lesson-4",
              "moduleSlug": "dotnet-fundamentals",
              "title": "Loops and Iteration",
              "order": 4,
              "objectives": [
                "Build foundational understanding",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Core Concepts.\n\nMaster different loop constructs in C# including for, while, do-while, and foreach loops for repetitive tasks.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "using System;\nusing System.Collections.Generic;\n\nclass Program\n{\n    static void Main()\n    {\n        // For loop\n        Console.WriteLine(\"For loop:\");\n        for (int i = 1; i <= 5; i++)\n        {\n            Console.WriteLine($\"Count: {i}\");\n        }\n        \n        // While loop\n        Console.WriteLine(\"\\nWhile loop:\");\n        int j = 1;\n        while (j <= 3)\n        {\n            Console.WriteLine($\"While iteration: {j}\");\n            j++;\n        }\n        \n        // Foreach loop\n        Console.WriteLine(\"\\nForeach loop:\");\n        List<string> fruits = new List<string> { \"Apple\", \"Banana\", \"Orange\" };\n        foreach (string fruit in fruits)\n        {\n            Console.WriteLine($\"Fruit: {fruit}\");\n        }\n    }\n}",
                "explanation": "This example produces: For loop:\nCount: 1\nCount: 2\nCount: 3\nCount: 4\nCount: 5\n\nWhile loop:\nWhile iteration: 1\nWhile iteration: 2\nWhile iteration: 3\n\nForeach loop:\nFruit: Apple\nFruit: Banana\nFruit: Orange\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "csharp"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Loops and Iteration",
                  "description": "Apply the concepts from this lesson on Core Concepts",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Core Concepts",
                "dotnet"
              ],
              "legacy": {
                "originalId": 4,
                "originalTopic": "Core Concepts",
                "migrated": "2025-10-01T06:41:13.479Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.479Z",
              "version": "1.0.0"
            },
            {
              "id": "dotnet-fundamentals-lesson-5",
              "moduleSlug": "dotnet-fundamentals",
              "title": "Classes and Objects",
              "order": 5,
              "objectives": [
                "Build foundational understanding",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Object-Oriented Programming.\n\nIntroduction to object-oriented programming concepts including classes, objects, constructors, and access modifiers.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "using System;\n\npublic class Person\n{\n    // Fields\n    private string name;\n    private int age;\n    \n    // Constructor\n    public Person(string name, int age)\n    {\n        this.name = name;\n        this.age = age;\n    }\n    \n    // Properties\n    public string Name\n    {\n        get { return name; }\n        set { name = value; }\n    }\n    \n    public int Age\n    {\n        get { return age; }\n        set { age = value >= 0 ? value : 0; }\n    }\n    \n    // Method\n    public void Introduce()\n    {\n        Console.WriteLine($\"Hi, I'm {name} and I'm {age} years old.\");\n    }\n}\n\nclass Program\n{\n    static void Main()\n    {\n        Person person1 = new Person(\"Alice\", 30);\n        Person person2 = new Person(\"Bob\", 25);\n        \n        person1.Introduce();\n        person2.Introduce();\n        \n        // Using properties\n        person1.Age = 31;\n        Console.WriteLine($\"Updated age: {person1.Age}\");\n    }\n}",
                "explanation": "This example produces: Hi, I'm Alice and I'm 30 years old.\nHi, I'm Bob and I'm 25 years old.\nUpdated age: 31\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "csharp"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Classes and Objects",
                  "description": "Apply the concepts from this lesson on Object-Oriented Programming",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Beginner",
              "tags": [
                "Object-Oriented Programming",
                "dotnet"
              ],
              "legacy": {
                "originalId": 5,
                "originalTopic": "Object-Oriented Programming",
                "migrated": "2025-10-01T06:41:13.479Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.479Z",
              "version": "1.0.0"
            },
            {
              "id": "dotnet-fundamentals-lesson-6",
              "moduleSlug": "dotnet-fundamentals",
              "title": "Inheritance and Polymorphism",
              "order": 6,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Object-Oriented Programming.\n\nLearn about inheritance, method overriding, virtual methods, and polymorphism in C# to create extensible and maintainable code.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "using System;\n\npublic abstract class Animal\n{\n    public string Name { get; set; }\n    \n    public Animal(string name)\n    {\n        Name = name;\n    }\n    \n    public virtual void MakeSound()\n    {\n        Console.WriteLine($\"{Name} makes a sound\");\n    }\n    \n    public abstract void Move();\n}\n\npublic class Dog : Animal\n{\n    public Dog(string name) : base(name) { }\n    \n    public override void MakeSound()\n    {\n        Console.WriteLine($\"{Name} barks: Woof!\");\n    }\n    \n    public override void Move()\n    {\n        Console.WriteLine($\"{Name} runs on four legs\");\n    }\n}\n\npublic class Bird : Animal\n{\n    public Bird(string name) : base(name) { }\n    \n    public override void MakeSound()\n    {\n        Console.WriteLine($\"{Name} chirps: Tweet!\");\n    }\n    \n    public override void Move()\n    {\n        Console.WriteLine($\"{Name} flies with wings\");\n    }\n}\n\nclass Program\n{\n    static void Main()\n    {\n        Animal[] animals = { new Dog(\"Buddy\"), new Bird(\"Tweety\") };\n        \n        foreach (Animal animal in animals)\n        {\n            animal.MakeSound();\n            animal.Move();\n            Console.WriteLine();\n        }\n    }\n}",
                "explanation": "This example produces: Buddy barks: Woof!\nBuddy runs on four legs\n\nTweety chirps: Tweet!\nTweety flies with wings\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "csharp"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Inheritance and Polymorphism",
                  "description": "Apply the concepts from this lesson on Object-Oriented Programming",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Object-Oriented Programming",
                "dotnet"
              ],
              "legacy": {
                "originalId": 6,
                "originalTopic": "Object-Oriented Programming",
                "migrated": "2025-10-01T06:41:13.479Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.479Z",
              "version": "1.0.0"
            },
            {
              "id": "dotnet-fundamentals-lesson-7",
              "moduleSlug": "dotnet-fundamentals",
              "title": "Working with Collections",
              "order": 7,
              "objectives": [
                "Build foundational understanding",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Collections and LINQ.\n\nExplore various collection types in C# including Arrays, Lists, Dictionaries, and their common operations.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    static void Main()\n    {\n        // List<T>\n        List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };\n        numbers.Add(6);\n        Console.WriteLine($\"List count: {numbers.Count}\");\n        \n        // Dictionary<TKey, TValue>\n        Dictionary<string, int> ages = new Dictionary<string, int>\n        {\n            { \"Alice\", 30 },\n            { \"Bob\", 25 },\n            { \"Charlie\", 35 }\n        };\n        \n        Console.WriteLine($\"Alice's age: {ages[\"Alice\"]}\");\n        \n        // Array\n        string[] names = { \"Alice\", \"Bob\", \"Charlie\" };\n        Console.WriteLine($\"Array length: {names.Length}\");\n        \n        // Iterating through collections\n        Console.WriteLine(\"\\nNames in dictionary:\");\n        foreach (var kvp in ages)\n        {\n            Console.WriteLine($\"{kvp.Key}: {kvp.Value}\");\n        }\n    }\n}",
                "explanation": "This example produces: List count: 6\nAlice's age: 30\nArray length: 3\n\nNames in dictionary:\nAlice: 30\nBob: 25\nCharlie: 35\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "csharp"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Working with Collections",
                  "description": "Apply the concepts from this lesson on Collections and LINQ",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Collections and LINQ",
                "dotnet"
              ],
              "legacy": {
                "originalId": 7,
                "originalTopic": "Collections and LINQ",
                "migrated": "2025-10-01T06:41:13.479Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.479Z",
              "version": "1.0.0"
            },
            {
              "id": "dotnet-fundamentals-lesson-8",
              "moduleSlug": "dotnet-fundamentals",
              "title": "LINQ (Language Integrated Query)",
              "order": 8,
              "objectives": [
                "Build foundational understanding",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Collections and LINQ.\n\nMaster LINQ for querying and manipulating data collections using method syntax and query syntax.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class Student\n{\n    public string Name { get; set; }\n    public int Grade { get; set; }\n    public string Subject { get; set; }\n}\n\nclass Program\n{\n    static void Main()\n    {\n        List<Student> students = new List<Student>\n        {\n            new Student { Name = \"Alice\", Grade = 85, Subject = \"Math\" },\n            new Student { Name = \"Bob\", Grade = 92, Subject = \"Science\" },\n            new Student { Name = \"Charlie\", Grade = 78, Subject = \"Math\" },\n            new Student { Name = \"Diana\", Grade = 96, Subject = \"Science\" }\n        };\n        \n        // LINQ Method Syntax\n        var highGrades = students\n            .Where(s => s.Grade >= 90)\n            .Select(s => s.Name)\n            .ToList();\n        \n        Console.WriteLine(\"Students with grades >= 90:\");\n        foreach (var name in highGrades)\n        {\n            Console.WriteLine(name);\n        }\n        \n        // LINQ Query Syntax\n        var mathStudents = from student in students\n                          where student.Subject == \"Math\"\n                          orderby student.Grade descending\n                          select student;\n        \n        Console.WriteLine(\"\\nMath students (by grade):\");\n        foreach (var student in mathStudents)\n        {\n            Console.WriteLine($\"{student.Name}: {student.Grade}\");\n        }\n        \n        // Aggregation\n        double averageGrade = students.Average(s => s.Grade);\n        Console.WriteLine($\"\\nAverage grade: {averageGrade:F1}\");\n    }\n}",
                "explanation": "This example produces: Students with grades >= 90:\nBob\nDiana\n\nMath students (by grade):\nAlice: 85\nCharlie: 78\n\nAverage grade: 87.8\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "csharp"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: LINQ (Language Integrated Query)",
                  "description": "Apply the concepts from this lesson on Collections and LINQ",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Collections and LINQ",
                "dotnet"
              ],
              "legacy": {
                "originalId": 8,
                "originalTopic": "Collections and LINQ",
                "migrated": "2025-10-01T06:41:13.479Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.479Z",
              "version": "1.0.0"
            },
            {
              "id": "dotnet-fundamentals-lesson-9",
              "moduleSlug": "dotnet-fundamentals",
              "title": "Exception Handling with Try-Catch",
              "order": 9,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Exception Handling.\n\nLearn how to handle exceptions gracefully using try-catch-finally blocks and custom exceptions.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "using System;\n\nclass Program\n{\n    static void Main()\n    {\n        try\n        {\n            Console.Write(\"Enter a number: \");\n            string input = \"10\"; // Simulated input\n            int number = int.Parse(input);\n            \n            Console.Write(\"Enter divisor: \");\n            string divisorInput = \"0\"; // Simulated input\n            int divisor = int.Parse(divisorInput);\n            \n            int result = Divide(number, divisor);\n            Console.WriteLine($\"Result: {result}\");\n        }\n        catch (DivideByZeroException ex)\n        {\n            Console.WriteLine($\"Error: {ex.Message}\");\n        }\n        catch (FormatException ex)\n        {\n            Console.WriteLine($\"Invalid input format: {ex.Message}\");\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine($\"Unexpected error: {ex.Message}\");\n        }\n        finally\n        {\n            Console.WriteLine(\"Operation completed.\");\n        }\n    }\n    \n    static int Divide(int a, int b)\n    {\n        if (b == 0)\n            throw new DivideByZeroException(\"Cannot divide by zero!\");\n        return a / b;\n    }\n}",
                "explanation": "This example produces: Enter a number: Enter divisor: Error: Cannot divide by zero!\nOperation completed.\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "csharp"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Exception Handling with Try-Catch",
                  "description": "Apply the concepts from this lesson on Exception Handling",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Advanced",
              "tags": [
                "Exception Handling",
                "dotnet"
              ],
              "legacy": {
                "originalId": 9,
                "originalTopic": "Exception Handling",
                "migrated": "2025-10-01T06:41:13.479Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.479Z",
              "version": "1.0.0"
            },
            {
              "id": "dotnet-fundamentals-lesson-10",
              "moduleSlug": "dotnet-fundamentals",
              "title": "File Operations",
              "order": 10,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on File I/O.\n\nLearn how to read from and write to files using various file I/O operations in C#.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "using System;\nusing System.IO;\n\nclass Program\n{\n    static void Main()\n    {\n        string fileName = \"sample.txt\";\n        \n        try\n        {\n            // Writing to file\n            string[] lines = {\n                \"Hello, World!\",\n                \"This is a sample file.\",\n                \"Created with C#\"\n            };\n            \n            File.WriteAllLines(fileName, lines);\n            Console.WriteLine($\"File '{fileName}' created successfully.\");\n            \n            // Reading from file\n            if (File.Exists(fileName))\n            {\n                string[] readLines = File.ReadAllLines(fileName);\n                Console.WriteLine(\"\\nFile contents:\");\n                for (int i = 0; i < readLines.Length; i++)\n                {\n                    Console.WriteLine($\"Line {i + 1}: {readLines[i]}\");\n                }\n            }\n            \n            // File information\n            FileInfo fileInfo = new FileInfo(fileName);\n            Console.WriteLine($\"\\nFile size: {fileInfo.Length} bytes\");\n            Console.WriteLine($\"Created: {fileInfo.CreationTime}\");\n        }\n        catch (IOException ex)\n        {\n            Console.WriteLine($\"File operation error: {ex.Message}\");\n        }\n    }\n}",
                "explanation": "This example produces: File 'sample.txt' created successfully.\n\nFile contents:\nLine 1: Hello, World!\nLine 2: This is a sample file.\nLine 3: Created with C#\n\nFile size: 54 bytes\nCreated: [Current DateTime]\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "csharp"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: File Operations",
                  "description": "Apply the concepts from this lesson on File I/O",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "File I/O",
                "dotnet"
              ],
              "legacy": {
                "originalId": 10,
                "originalTopic": "File I/O",
                "migrated": "2025-10-01T06:41:13.479Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.479Z",
              "version": "1.0.0"
            },
            {
              "id": "dotnet-fundamentals-lesson-11",
              "moduleSlug": "dotnet-fundamentals",
              "title": "Asynchronous Programming with async/await",
              "order": 11,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Async Programming.\n\nUnderstand asynchronous programming patterns using async/await keywords for non-blocking operations.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "using System;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nclass Program\n{\n    static async Task Main(string[] args)\n    {\n        Console.WriteLine(\"Starting async operations...\");\n        \n        // Simulating multiple async operations\n        Task<string> task1 = SimulateWorkAsync(\"Task 1\", 2000);\n        Task<string> task2 = SimulateWorkAsync(\"Task 2\", 1000);\n        Task<string> task3 = SimulateWorkAsync(\"Task 3\", 1500);\n        \n        // Wait for all tasks to complete\n        string[] results = await Task.WhenAll(task1, task2, task3);\n        \n        Console.WriteLine(\"\\nAll tasks completed:\");\n        foreach (string result in results)\n        {\n            Console.WriteLine(result);\n        }\n        \n        // Sequential vs parallel execution example\n        DateTime start = DateTime.Now;\n        await SequentialExecution();\n        TimeSpan sequentialTime = DateTime.Now - start;\n        \n        start = DateTime.Now;\n        await ParallelExecution();\n        TimeSpan parallelTime = DateTime.Now - start;\n        \n        Console.WriteLine($\"\\nSequential time: {sequentialTime.TotalMilliseconds}ms\");\n        Console.WriteLine($\"Parallel time: {parallelTime.TotalMilliseconds}ms\");\n    }\n    \n    static async Task<string> SimulateWorkAsync(string taskName, int delayMs)\n    {\n        Console.WriteLine($\"{taskName} started\");\n        await Task.Delay(delayMs);\n        Console.WriteLine($\"{taskName} completed\");\n        return $\"{taskName} result\";\n    }\n    \n    static async Task SequentialExecution()\n    {\n        await Task.Delay(500);\n        await Task.Delay(500);\n    }\n    \n    static async Task ParallelExecution()\n    {\n        Task t1 = Task.Delay(500);\n        Task t2 = Task.Delay(500);\n        await Task.WhenAll(t1, t2);\n    }\n}",
                "explanation": "This example produces: Starting async operations...\nTask 1 started\nTask 2 started\nTask 3 started\nTask 2 completed\nTask 3 completed\nTask 1 completed\n\nAll tasks completed:\nTask 1 result\nTask 2 result\nTask 3 result\n\nSequential time: 1000ms\nParallel time: 500ms\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "csharp"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Asynchronous Programming with async/await",
                  "description": "Apply the concepts from this lesson on Async Programming",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Async Programming",
                "dotnet"
              ],
              "legacy": {
                "originalId": 11,
                "originalTopic": "Async Programming",
                "migrated": "2025-10-01T06:41:13.479Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.479Z",
              "version": "1.0.0"
            },
            {
              "id": "dotnet-fundamentals-lesson-12",
              "moduleSlug": "dotnet-fundamentals",
              "title": "Delegates and Events",
              "order": 12,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Advanced Features.\n\nLearn about delegates, events, and functional programming concepts in C# for creating flexible and decoupled code.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "using System;\n\n// Delegate declaration\npublic delegate void NotificationHandler(string message);\n\npublic class Publisher\n{\n    // Event based on delegate\n    public event NotificationHandler OnNotification;\n    \n    public void SendNotification(string message)\n    {\n        Console.WriteLine($\"Publishing: {message}\");\n        OnNotification?.Invoke(message);\n    }\n}\n\npublic class Subscriber\n{\n    public string Name { get; set; }\n    \n    public Subscriber(string name)\n    {\n        Name = name;\n    }\n    \n    public void HandleNotification(string message)\n    {\n        Console.WriteLine($\"{Name} received: {message}\");\n    }\n}\n\nclass Program\n{\n    static void Main()\n    {\n        Publisher publisher = new Publisher();\n        \n        Subscriber sub1 = new Subscriber(\"Alice\");\n        Subscriber sub2 = new Subscriber(\"Bob\");\n        \n        // Subscribe to event\n        publisher.OnNotification += sub1.HandleNotification;\n        publisher.OnNotification += sub2.HandleNotification;\n        \n        // Anonymous method\n        publisher.OnNotification += (msg) => Console.WriteLine($\"Anonymous: {msg}\");\n        \n        // Trigger events\n        publisher.SendNotification(\"Hello World!\");\n        publisher.SendNotification(\"Another message\");\n        \n        // Unsubscribe\n        publisher.OnNotification -= sub1.HandleNotification;\n        \n        Console.WriteLine(\"\\nAfter unsubscribing Alice:\");\n        publisher.SendNotification(\"Final message\");\n    }\n}",
                "explanation": "This example produces: Publishing: Hello World!\nAlice received: Hello World!\nBob received: Hello World!\nAnonymous: Hello World!\nPublishing: Another message\nAlice received: Another message\nBob received: Another message\nAnonymous: Another message\n\nAfter unsubscribing Alice:\nPublishing: Final message\nBob received: Final message\nAnonymous: Final message\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "csharp"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Delegates and Events",
                  "description": "Apply the concepts from this lesson on Advanced Features",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Advanced Features",
                "dotnet"
              ],
              "legacy": {
                "originalId": 12,
                "originalTopic": "Advanced Features",
                "migrated": "2025-10-01T06:41:13.479Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.479Z",
              "version": "1.0.0"
            },
            {
              "id": "dotnet-fundamentals-lesson-13",
              "moduleSlug": "dotnet-fundamentals",
              "title": "Methods and Functions",
              "order": 13,
              "objectives": [
                "Understand method declaration and invocation",
                "Learn about parameters, return types, and overloading",
                "Implement static and instance methods"
              ],
              "intro": "Welcome to this comprehensive lesson on Methods and Functions in .NET.\n\nMethods are fundamental building blocks of C# programming that allow you to organize code into reusable units. In this lesson, you'll learn how to create, call, and optimize methods for better code organization.\n\nThroughout this lesson, you'll gain hands-on experience with method signatures, parameter passing, return values, and method overloading. We'll explore both static and instance methods, understanding when to use each approach.\n\nThis lesson builds upon previous concepts of data types and control flow, showing how to encapsulate logic into maintainable functions. By the end, you'll be able to design clean, reusable methods that follow C# best practices.",
              "code": {
                "example": "using System;\n\nclass Calculator\n{\n    public static int Add(int a, int b)\n    {\n        return a + b;\n    }\n    \n    public double CalculateArea(double radius)\n    {\n        return Math.PI * radius * radius;\n    }\n}\n\nclass Program\n{\n    static void Main()\n    {\n        int sum = Calculator.Add(5, 3);\n        Console.WriteLine($\"Sum: {sum}\");\n        \n        Calculator calc = new Calculator();\n        double area = calc.CalculateArea(5.0);\n        Console.WriteLine($\"Area: {area:F2}\");\n    }\n}",
                "explanation": "This example demonstrates method declaration and invocation. The output shows: Sum: 8, Area: 78.54",
                "language": "csharp"
              },
              "pitfalls": [
                {
                  "mistake": "Creating methods that do too much",
                  "solution": "Break large methods into smaller, focused methods",
                  "severity": "medium"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Methods and Functions",
                  "description": "Create utility methods for mathematical operations",
                  "checkpoints": [
                    "Create static methods for basic math operations",
                    "Implement instance methods with validation"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Intermediate",
              "tags": [
                "Methods",
                "Functions",
                "dotnet"
              ],
              "lastUpdated": "2025-10-01T18:00:00.000Z",
              "version": "1.0.0"
            },
            {
              "id": "dotnet-fundamentals-lesson-14",
              "moduleSlug": "dotnet-fundamentals",
              "title": "Object-Oriented Programming Basics",
              "order": 14,
              "objectives": [
                "Understand classes, objects, and instantiation",
                "Learn about properties, fields, and encapsulation",
                "Implement constructors and object lifecycle"
              ],
              "intro": "Welcome to Object-Oriented Programming Basics in .NET.\n\nObject-Oriented Programming (OOP) is a fundamental paradigm in C# that allows you to model real-world entities as objects with properties and behaviors. This lesson introduces the core concepts of classes and objects.\n\nYou'll learn how to design classes, create objects, and implement encapsulation through properties and access modifiers. Understanding OOP is crucial for building maintainable and scalable applications.",
              "code": {
                "example": "using System;\n\nclass Person\n{\n    private string _name;\n    private int _age;\n    \n    public string Name\n    {\n        get { return _name; }\n        set { _name = value; }\n    }\n    \n    public int Age\n    {\n        get { return _age; }\n        set { _age = value; }\n    }\n    \n    public Person(string name, int age)\n    {\n        Name = name;\n        Age = age;\n    }\n    \n    public void Introduce()\n    {\n        Console.WriteLine($\"Hi, I'm {Name}, {Age} years old.\");\n    }\n}\n\nclass Program\n{\n    static void Main()\n    {\n        Person person = new Person(\"Alice\", 25);\n        person.Introduce();\n    }\n}",
                "explanation": "This example demonstrates class definition, properties, constructors, and object instantiation.",
                "language": "csharp"
              },
              "pitfalls": [
                {
                  "mistake": "Making all fields public",
                  "solution": "Use private fields with public properties",
                  "severity": "high"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Object-Oriented Programming",
                  "description": "Create a BankAccount class with proper encapsulation",
                  "checkpoints": [
                    "Design a class with private fields and public properties",
                    "Implement constructors with validation"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 35,
              "difficulty": "Intermediate",
              "tags": [
                "OOP",
                "Classes",
                "Objects",
                "dotnet"
              ],
              "lastUpdated": "2025-10-01T18:00:00.000Z",
              "version": "1.0.0"
            },
            {
              "id": "dotnet-fundamentals-lesson-15",
              "moduleSlug": "dotnet-fundamentals",
              "title": "Collections and Arrays",
              "order": 15,
              "objectives": [
                "Master arrays and their operations",
                "Understand List<T> and generic collections",
                "Learn Dictionary and specialized collections"
              ],
              "intro": "Welcome to Collections and Arrays in .NET.\n\nCollections are essential for storing and manipulating groups of related data. This lesson covers arrays, generic collections, and specialized data structures.\n\nYou'll learn about different collection types, their performance characteristics, and when to use each one. Collections are fundamental to most real-world applications.",
              "code": {
                "example": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    static void Main()\n    {\n        int[] numbers = { 1, 2, 3, 4, 5 };\n        \n        List<string> fruits = new List<string>();\n        fruits.Add(\"Apple\");\n        fruits.Add(\"Banana\");\n        \n        Dictionary<string, int> ages = new Dictionary<string, int>\n        {\n            { \"Alice\", 25 },\n            { \"Bob\", 30 }\n        };\n        \n        var evenNumbers = numbers.Where(n => n % 2 == 0).ToList();\n        Console.WriteLine($\"Even numbers: {string.Join(\", \", evenNumbers)}\");\n    }\n}",
                "explanation": "This example demonstrates arrays, List<T>, Dictionary, and LINQ operations.",
                "language": "csharp"
              },
              "pitfalls": [
                {
                  "mistake": "Using arrays when List<T> would be better",
                  "solution": "Use List<T> for dynamic collections",
                  "severity": "medium"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Collections and Arrays",
                  "description": "Build a student management system using collections",
                  "checkpoints": [
                    "Use arrays for fixed data and List<T> for dynamic data",
                    "Apply LINQ operations for data filtering"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 40,
              "difficulty": "Intermediate",
              "tags": [
                "Collections",
                "Arrays",
                "LINQ",
                "dotnet"
              ],
              "lastUpdated": "2025-10-01T18:00:00.000Z",
              "version": "1.0.0"
            },
            {
              "id": "dotnet-fundamentals-lesson-16",
              "moduleSlug": "dotnet-fundamentals",
              "title": "Exception Handling",
              "order": 16,
              "objectives": [
                "Understand exception types and hierarchy",
                "Implement try-catch-finally blocks",
                "Create custom exceptions"
              ],
              "intro": "Welcome to Exception Handling in .NET.\n\nException handling is crucial for building robust applications that can gracefully handle errors. This lesson covers the .NET exception system and best practices.\n\nYou'll learn about different exception types, how to catch and handle them appropriately, and when to create custom exceptions.",
              "code": {
                "example": "using System;\n\nclass Program\n{\n    static void Main()\n    {\n        try\n        {\n            int result = 10 / 0;\n        }\n        catch (DivideByZeroException ex)\n        {\n            Console.WriteLine($\"Error: {ex.Message}\");\n        }\n        finally\n        {\n            Console.WriteLine(\"Cleanup completed\");\n        }\n        \n        try\n        {\n            ValidateAge(-5);\n        }\n        catch (ArgumentException ex)\n        {\n            Console.WriteLine($\"Validation error: {ex.Message}\");\n        }\n    }\n    \n    static void ValidateAge(int age)\n    {\n        if (age < 0)\n            throw new ArgumentException(\"Age cannot be negative\");\n    }\n}",
                "explanation": "This example demonstrates try-catch-finally blocks and custom exception throwing.",
                "language": "csharp"
              },
              "pitfalls": [
                {
                  "mistake": "Catching all exceptions generically",
                  "solution": "Catch specific exception types first",
                  "severity": "high"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Exception Handling",
                  "description": "Create a calculator with comprehensive error handling",
                  "checkpoints": [
                    "Handle division by zero and invalid input",
                    "Create custom exceptions for business rules"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 35,
              "difficulty": "Intermediate",
              "tags": [
                "Exception Handling",
                "Error Management",
                "dotnet"
              ],
              "lastUpdated": "2025-10-01T18:00:00.000Z",
              "version": "1.0.0"
            },
            {
              "id": "dotnet-fundamentals-lesson-17",
              "moduleSlug": "dotnet-fundamentals",
              "title": "File I/O and Streams",
              "order": 17,
              "objectives": [
                "Master file reading and writing operations",
                "Understand streams and their types",
                "Implement async file operations"
              ],
              "intro": "Welcome to File I/O and Streams in .NET.\n\nFile input/output operations are essential for applications that need to persist data or process external data sources. This lesson covers the .NET file system APIs.\n\nYou'll learn about different ways to read and write files, work with streams for efficient data processing, and implement asynchronous file operations.",
              "code": {
                "example": "using System;\nusing System.IO;\nusing System.Threading.Tasks;\n\nclass Program\n{\n    static async Task Main()\n    {\n        string filename = \"sample.txt\";\n        \n        // Writing to file\n        string[] lines = { \"Line 1\", \"Line 2\", \"Line 3\" };\n        await File.WriteAllLinesAsync(filename, lines);\n        \n        // Reading from file\n        if (File.Exists(filename))\n        {\n            string content = await File.ReadAllTextAsync(filename);\n            Console.WriteLine($\"File content:\\n{content}\");\n        }\n        \n        // Working with streams\n        using (StreamWriter writer = new StreamWriter(\"stream.txt\"))\n        {\n            await writer.WriteLineAsync(\"Stream content\");\n        }\n    }\n}",
                "explanation": "This example demonstrates file I/O operations including async methods and stream usage.",
                "language": "csharp"
              },
              "pitfalls": [
                {
                  "mistake": "Not disposing file streams properly",
                  "solution": "Always use 'using' statements for resource management",
                  "severity": "high"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: File I/O and Streams",
                  "description": "Build a log file analyzer",
                  "checkpoints": [
                    "Read large files using streams efficiently",
                    "Implement async file operations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 40,
              "difficulty": "Intermediate",
              "tags": [
                "File I/O",
                "Streams",
                "Async",
                "dotnet"
              ],
              "lastUpdated": "2025-10-01T18:00:00.000Z",
              "version": "1.0.0"
            },
            {
              "id": "dotnet-fundamentals-lesson-18",
              "moduleSlug": "dotnet-fundamentals",
              "title": "Introduction to ASP.NET Core",
              "order": 18,
              "objectives": [
                "Understand ASP.NET Core architecture",
                "Create your first web application",
                "Learn about MVC pattern and routing"
              ],
              "intro": "Welcome to ASP.NET Core web development - a transformative journey into modern, cross-platform web application development with Microsoft's most advanced framework. ASP.NET Core represents a complete reimagining of web development on the .NET platform, offering unprecedented performance, flexibility, and developer productivity.\n\nASP.NET Core is built from the ground up as a high-performance, cross-platform framework that runs on Windows, macOS, and Linux. Unlike its predecessor ASP.NET Framework, ASP.NET Core is modular, lightweight, and designed for cloud-native applications. This architectural shift enables developers to build applications that scale efficiently and deploy anywhere.\n\nIn this comprehensive lesson, you'll master the fundamental concepts that make ASP.NET Core exceptional: the Model-View-Controller (MVC) pattern, dependency injection, middleware pipeline, and routing system. These concepts form the backbone of professional web development and are essential for building maintainable, testable applications.\n\nThe MVC pattern separates concerns beautifully - Models handle data and business logic, Views manage presentation, and Controllers coordinate user interactions. This separation enables teams to work efficiently and makes applications easier to test and maintain. You'll see how ASP.NET Core's implementation of MVC provides powerful features while maintaining simplicity.\n\nBy the end of this lesson, you'll confidently create web applications, implement routing strategies, handle HTTP requests and responses, and understand the request pipeline that makes ASP.NET Core applications so performant. This knowledge forms the foundation for building everything from simple websites to complex enterprise applications.",
              "code": {
                "example": "using Microsoft.AspNetCore.Mvc;\n\nnamespace WebApp.Controllers\n{\n    public class HomeController : Controller\n    {\n        public IActionResult Index()\n        {\n            ViewBag.Message = \"Welcome to ASP.NET Core!\";\n            return View();\n        }\n        \n        public IActionResult About()\n        {\n            return View();\n        }\n        \n        [HttpPost]\n        public IActionResult Contact(string name, string email)\n        {\n            ViewBag.Name = name;\n            ViewBag.Email = email;\n            return View();\n        }\n    }\n}\n\n// Program.cs\nvar builder = WebApplication.CreateBuilder(args);\nbuilder.Services.AddControllersWithViews();\n\nvar app = builder.Build();\napp.UseRouting();\napp.MapControllerRoute(\n    name: \"default\",\n    pattern: \"{controller=Home}/{action=Index}/{id?}\");\n\napp.Run();",
                "explanation": "This example shows a basic ASP.NET Core MVC controller with actions and routing configuration.",
                "language": "csharp"
              },
              "pitfalls": [
                {
                  "mistake": "Not understanding the request pipeline",
                  "solution": "Learn about middleware and the ASP.NET Core pipeline",
                  "severity": "medium"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: ASP.NET Core Basics",
                  "description": "Create a simple web application with multiple pages",
                  "checkpoints": [
                    "Set up a new ASP.NET Core project",
                    "Create controllers and views for different pages"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 45,
              "difficulty": "Intermediate",
              "tags": [
                "ASP.NET Core",
                "Web Development",
                "MVC",
                "dotnet"
              ],
              "lastUpdated": "2025-10-01T18:00:00.000Z",
              "version": "1.0.0"
            }
          ],
          "issues": []
        },
        "quiz": {
          "exists": true,
          "count": 25,
          "questions": [
            {
              "id": "dotnet-fundamentals-q1",
              "question": "What is the difference between .NET Framework and .NET Core?",
              "topic": "General",
              "difficulty": "Beginner",
              "choices": [
                "Open-ended question - no multiple choice",
                "This is a conceptual question",
                "Answer requires explanation",
                "Multiple approaches possible"
              ],
              "correctIndex": 0,
              "explanation": ".NET Core is a cross-platform, open-source framework that can run on Windows, macOS, and Linux, while .NET Framework is Windows-only and proprietary.",
              "industryContext": ".NET is a powerful platform for enterprise and cloud applications.",
              "tags": [
                "beginner",
                "dotnet"
              ],
              "questionType": "open-ended",
              "estimatedTime": 180,
              "legacy": {
                "originalId": 1,
                "migrated": "2025-10-01T06:41:13.481Z"
              }
            },
            {
              "id": "dotnet-fundamentals-q2",
              "question": "Which keyword is used to declare a constant in C#?",
              "topic": "General",
              "difficulty": "Intermediate",
              "choices": [
                "Open-ended question - no multiple choice",
                "This is a conceptual question",
                "Answer requires explanation",
                "Multiple approaches possible"
              ],
              "correctIndex": 0,
              "explanation": "The 'const' keyword is used to declare compile-time constants in C#. The value must be assigned at declaration and cannot be changed.",
              "industryContext": ".NET is a powerful platform for enterprise and cloud applications.",
              "tags": [
                "intermediate",
                "dotnet"
              ],
              "questionType": "open-ended",
              "estimatedTime": 180,
              "legacy": {
                "originalId": 2,
                "migrated": "2025-10-01T06:41:13.481Z"
              }
            },
            {
              "id": "dotnet-fundamentals-q3",
              "question": "What is the correct way to declare a nullable integer in C#?",
              "topic": "General",
              "difficulty": "Beginner",
              "choices": [
                "Open-ended question - no multiple choice",
                "This is a conceptual question",
                "Answer requires explanation",
                "Multiple approaches possible"
              ],
              "correctIndex": 0,
              "explanation": "int? is the shorthand syntax for Nullable<int>, which allows value types to hold null values.",
              "industryContext": ".NET is a powerful platform for enterprise and cloud applications.",
              "tags": [
                "beginner",
                "dotnet"
              ],
              "questionType": "open-ended",
              "estimatedTime": 180,
              "legacy": {
                "originalId": 3,
                "migrated": "2025-10-01T06:41:13.481Z"
              }
            },
            {
              "id": "dotnet-fundamentals-q4",
              "question": "Which access modifier makes a member accessible only within the same class?",
              "topic": "General",
              "difficulty": "Intermediate",
              "choices": [
                "Open-ended question - no multiple choice",
                "This is a conceptual question",
                "Answer requires explanation",
                "Multiple approaches possible"
              ],
              "correctIndex": 0,
              "explanation": "The 'private' access modifier restricts access to the member only within the same class where it's declared.",
              "industryContext": ".NET is a powerful platform for enterprise and cloud applications.",
              "tags": [
                "intermediate",
                "dotnet"
              ],
              "questionType": "open-ended",
              "estimatedTime": 180,
              "legacy": {
                "originalId": 4,
                "migrated": "2025-10-01T06:41:13.481Z"
              }
            },
            {
              "id": "dotnet-fundamentals-q5",
              "question": "What does the 'virtual' keyword indicate in C#?",
              "topic": "General",
              "difficulty": "Intermediate",
              "choices": [
                "Open-ended question - no multiple choice",
                "This is a conceptual question",
                "Answer requires explanation",
                "Multiple approaches possible"
              ],
              "correctIndex": 0,
              "explanation": "The 'virtual' keyword allows a method to be overridden in derived classes using the 'override' keyword, enabling polymorphism.",
              "industryContext": ".NET is a powerful platform for enterprise and cloud applications.",
              "tags": [
                "intermediate",
                "dotnet"
              ],
              "questionType": "open-ended",
              "estimatedTime": 180,
              "legacy": {
                "originalId": 5,
                "migrated": "2025-10-01T06:41:13.481Z"
              }
            },
            {
              "id": "dotnet-fundamentals-q6",
              "question": "Which LINQ method would you use to filter a collection?",
              "topic": "General",
              "difficulty": "Intermediate",
              "choices": [
                "Open-ended question - no multiple choice",
                "This is a conceptual question",
                "Answer requires explanation",
                "Multiple approaches possible"
              ],
              "correctIndex": 0,
              "explanation": "The 'Where' method is used to filter collections based on a specified condition, returning only elements that match the criteria.",
              "industryContext": ".NET is a powerful platform for enterprise and cloud applications.",
              "tags": [
                "intermediate",
                "dotnet"
              ],
              "questionType": "open-ended",
              "estimatedTime": 180,
              "legacy": {
                "originalId": 6,
                "migrated": "2025-10-01T06:41:13.481Z"
              }
            },
            {
              "id": "dotnet-fundamentals-q7",
              "question": "What is the purpose of the 'using' statement in C#?",
              "topic": "General",
              "difficulty": "Beginner",
              "choices": [
                "Open-ended question - no multiple choice",
                "This is a conceptual question",
                "Answer requires explanation",
                "Multiple approaches possible"
              ],
              "correctIndex": 0,
              "explanation": "The 'using' statement ensures that IDisposable objects are properly disposed of when they go out of scope, even if an exception occurs.",
              "industryContext": ".NET is a powerful platform for enterprise and cloud applications.",
              "tags": [
                "beginner",
                "dotnet"
              ],
              "questionType": "open-ended",
              "estimatedTime": 180,
              "legacy": {
                "originalId": 7,
                "migrated": "2025-10-01T06:41:13.481Z"
              }
            },
            {
              "id": "dotnet-fundamentals-q8",
              "question": "Which keyword is used to prevent inheritance of a class in C#?",
              "topic": "General",
              "difficulty": "Intermediate",
              "choices": [
                "Open-ended question - no multiple choice",
                "This is a conceptual question",
                "Answer requires explanation",
                "Multiple approaches possible"
              ],
              "correctIndex": 0,
              "explanation": "The 'sealed' keyword prevents a class from being inherited by other classes, making it the final class in the inheritance hierarchy.",
              "industryContext": ".NET is a powerful platform for enterprise and cloud applications.",
              "tags": [
                "intermediate",
                "dotnet"
              ],
              "questionType": "open-ended",
              "estimatedTime": 180,
              "legacy": {
                "originalId": 8,
                "migrated": "2025-10-01T06:41:13.481Z"
              }
            },
            {
              "id": "dotnet-fundamentals-q9",
              "question": "What is the difference between IEnumerable and IQueryable?",
              "topic": "General",
              "difficulty": "Beginner",
              "choices": [
                "Open-ended question - no multiple choice",
                "This is a conceptual question",
                "Answer requires explanation",
                "Multiple approaches possible"
              ],
              "correctIndex": 0,
              "explanation": "IEnumerable is for in-memory collections and executes queries locally, while IQueryable is designed for remote data sources and can translate queries to other formats like SQL.",
              "industryContext": ".NET is a powerful platform for enterprise and cloud applications.",
              "tags": [
                "beginner",
                "dotnet"
              ],
              "questionType": "open-ended",
              "estimatedTime": 180,
              "legacy": {
                "originalId": 9,
                "migrated": "2025-10-01T06:41:13.481Z"
              }
            },
            {
              "id": "dotnet-fundamentals-q10",
              "question": "In async programming, what does 'await' do?",
              "topic": "General",
              "difficulty": "Intermediate",
              "choices": [
                "Open-ended question - no multiple choice",
                "This is a conceptual question",
                "Answer requires explanation",
                "Multiple approaches possible"
              ],
              "correctIndex": 0,
              "explanation": "'await' asynchronously waits for the task to complete, returning control to the caller and resuming execution when the task finishes, without blocking the thread.",
              "industryContext": ".NET is a powerful platform for enterprise and cloud applications.",
              "tags": [
                "intermediate",
                "dotnet"
              ],
              "questionType": "open-ended",
              "estimatedTime": 180,
              "legacy": {
                "originalId": 10,
                "migrated": "2025-10-01T06:41:13.481Z"
              }
            },
            {
              "id": "dotnet-fundamentals-q11",
              "question": "What is the purpose of the 'yield' keyword in C#?",
              "topic": "General",
              "difficulty": "Beginner",
              "choices": [
                "Open-ended question - no multiple choice",
                "This is a conceptual question",
                "Answer requires explanation",
                "Multiple approaches possible"
              ],
              "correctIndex": 0,
              "explanation": "The 'yield' keyword is used to create iterator methods that return IEnumerable or IEnumerator, allowing lazy evaluation of sequences.",
              "industryContext": ".NET is a powerful platform for enterprise and cloud applications.",
              "tags": [
                "beginner",
                "dotnet"
              ],
              "questionType": "open-ended",
              "estimatedTime": 180,
              "legacy": {
                "originalId": 11,
                "migrated": "2025-10-01T06:41:13.481Z"
              }
            },
            {
              "id": "dotnet-fundamentals-q12",
              "question": "Which design pattern is commonly used for dependency injection in .NET?",
              "topic": "General",
              "difficulty": "Intermediate",
              "choices": [
                "Open-ended question - no multiple choice",
                "This is a conceptual question",
                "Answer requires explanation",
                "Multiple approaches possible"
              ],
              "correctIndex": 0,
              "explanation": "IoC containers implement the Inversion of Control principle for dependency injection, managing object creation and dependency resolution automatically.",
              "industryContext": ".NET is a powerful platform for enterprise and cloud applications.",
              "tags": [
                "intermediate",
                "dotnet"
              ],
              "questionType": "open-ended",
              "estimatedTime": 180,
              "legacy": {
                "originalId": 12,
                "migrated": "2025-10-01T06:41:13.481Z"
              }
            },
            {
              "id": "dotnet-fundamentals-q13",
              "question": "What is the difference between 'ref' and 'out' parameters?",
              "topic": "General",
              "difficulty": "Beginner",
              "choices": [
                "Open-ended question - no multiple choice",
                "This is a conceptual question",
                "Answer requires explanation",
                "Multiple approaches possible"
              ],
              "correctIndex": 0,
              "explanation": "'ref' parameters must be initialized before being passed to a method, while 'out' parameters don't need initialization but must be assigned a value within the method.",
              "industryContext": ".NET is a powerful platform for enterprise and cloud applications.",
              "tags": [
                "beginner",
                "dotnet"
              ],
              "questionType": "open-ended",
              "estimatedTime": 180,
              "legacy": {
                "originalId": 13,
                "migrated": "2025-10-01T06:41:13.481Z"
              }
            },
            {
              "id": "dotnet-fundamentals-q14",
              "question": "Which collection type provides the best performance for frequent insertions and deletions at arbitrary positions?",
              "topic": "General",
              "difficulty": "Advanced",
              "choices": [
                "Open-ended question - no multiple choice",
                "This is a conceptual question",
                "Answer requires explanation",
                "Multiple approaches possible"
              ],
              "correctIndex": 0,
              "explanation": "LinkedList<T> provides O(1) insertion and deletion at arbitrary positions when you have a reference to the node, unlike List<T> which requires O(n) for insertions/deletions in the middle.",
              "industryContext": ".NET is a powerful platform for enterprise and cloud applications.",
              "tags": [
                "advanced",
                "dotnet"
              ],
              "questionType": "open-ended",
              "estimatedTime": 180,
              "legacy": {
                "originalId": 14,
                "migrated": "2025-10-01T06:41:13.481Z"
              }
            },
            {
              "id": "dotnet-fundamentals-q15",
              "question": "What is the purpose of the 'ConfigureAwait(false)' method?",
              "topic": "General",
              "difficulty": "Beginner",
              "choices": [
                "Open-ended question - no multiple choice",
                "This is a conceptual question",
                "Answer requires explanation",
                "Multiple approaches possible"
              ],
              "correctIndex": 0,
              "explanation": "ConfigureAwait(false) prevents capturing the current synchronization context, which can help avoid deadlocks in library code and improve performance.",
              "industryContext": ".NET is a powerful platform for enterprise and cloud applications.",
              "tags": [
                "beginner",
                "dotnet"
              ],
              "questionType": "open-ended",
              "estimatedTime": 180,
              "legacy": {
                "originalId": 15,
                "migrated": "2025-10-01T06:41:13.481Z"
              }
            },
            {
              "id": "dotnet-fundamentals-q16",
              "question": "Which attribute is used to specify that a property should be serialized with a different name in JSON?",
              "topic": "General",
              "difficulty": "Intermediate",
              "choices": [
                "Open-ended question - no multiple choice",
                "This is a conceptual question",
                "Answer requires explanation",
                "Multiple approaches possible"
              ],
              "correctIndex": 0,
              "explanation": "In System.Text.Json, [JsonPropertyName] is used to specify a different property name during JSON serialization/deserialization.",
              "industryContext": ".NET is a powerful platform for enterprise and cloud applications.",
              "tags": [
                "intermediate",
                "dotnet"
              ],
              "questionType": "open-ended",
              "estimatedTime": 180,
              "legacy": {
                "originalId": 16,
                "migrated": "2025-10-01T06:41:13.481Z"
              }
            },
            {
              "id": "dotnet-fundamentals-q17",
              "question": "What is the difference between 'var' and 'dynamic' in C#?",
              "topic": "General",
              "difficulty": "Beginner",
              "choices": [
                "Open-ended question - no multiple choice",
                "This is a conceptual question",
                "Answer requires explanation",
                "Multiple approaches possible"
              ],
              "correctIndex": 0,
              "explanation": "'var' uses compile-time type inference where the type is determined at compile time, while 'dynamic' defers type checking to runtime.",
              "industryContext": ".NET is a powerful platform for enterprise and cloud applications.",
              "tags": [
                "beginner",
                "dotnet"
              ],
              "questionType": "open-ended",
              "estimatedTime": 180,
              "legacy": {
                "originalId": 17,
                "migrated": "2025-10-01T06:41:13.481Z"
              }
            },
            {
              "id": "dotnet-fundamentals-q18",
              "question": "Which method is called when an object is about to be garbage collected?",
              "topic": "General",
              "difficulty": "Intermediate",
              "choices": [
                "Open-ended question - no multiple choice",
                "This is a conceptual question",
                "Answer requires explanation",
                "Multiple approaches possible"
              ],
              "correctIndex": 0,
              "explanation": "The Finalize() method (implemented via destructor syntax ~ClassName()) is called by the garbage collector before an object is collected.",
              "industryContext": ".NET is a powerful platform for enterprise and cloud applications.",
              "tags": [
                "intermediate",
                "dotnet"
              ],
              "questionType": "open-ended",
              "estimatedTime": 180,
              "legacy": {
                "originalId": 18,
                "migrated": "2025-10-01T06:41:13.481Z"
              }
            },
            {
              "id": "dotnet-fundamentals-q19",
              "question": "What is the purpose of the 'lock' statement in C#?",
              "topic": "General",
              "difficulty": "Beginner",
              "choices": [
                "Open-ended question - no multiple choice",
                "This is a conceptual question",
                "Answer requires explanation",
                "Multiple approaches possible"
              ],
              "correctIndex": 0,
              "explanation": "The 'lock' statement provides mutual exclusion, ensuring that only one thread can execute the locked code block at a time, preventing race conditions.",
              "industryContext": ".NET is a powerful platform for enterprise and cloud applications.",
              "tags": [
                "beginner",
                "dotnet"
              ],
              "questionType": "open-ended",
              "estimatedTime": 180,
              "legacy": {
                "originalId": 19,
                "migrated": "2025-10-01T06:41:13.481Z"
              }
            },
            {
              "id": "dotnet-fundamentals-q20",
              "question": "Which interface should a class implement to support the 'foreach' loop?",
              "topic": "General",
              "difficulty": "Intermediate",
              "choices": [
                "Open-ended question - no multiple choice",
                "This is a conceptual question",
                "Answer requires explanation",
                "Multiple approaches possible"
              ],
              "correctIndex": 0,
              "explanation": "A class must implement IEnumerable (or IEnumerable<T>) to support iteration with foreach loops, providing the GetEnumerator() method.",
              "industryContext": ".NET is a powerful platform for enterprise and cloud applications.",
              "tags": [
                "intermediate",
                "dotnet"
              ],
              "questionType": "open-ended",
              "estimatedTime": 180,
              "legacy": {
                "originalId": 20,
                "migrated": "2025-10-01T06:41:13.481Z"
              }
            },
            {
              "id": "dotnet-fundamentals-q21",
              "question": "What is the difference between 'ref' and 'out' parameters in C#?",
              "topic": "Parameters",
              "difficulty": "Intermediate",
              "choices": [
                "ref requires initialization before passing, out does not require initialization",
                "out requires initialization before passing, ref does not require initialization",
                "Both require initialization before passing",
                "Neither requires initialization before passing"
              ],
              "correctIndex": 0,
              "explanation": "The 'ref' keyword requires the variable to be initialized before passing to the method, while 'out' parameters are considered unassigned and must be assigned a value within the method before returning.",
              "industryContext": "Understanding parameter passing is crucial for method design and performance optimization in .NET applications.",
              "tags": [
                "intermediate",
                "dotnet"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 120
            },
            {
              "id": "dotnet-fundamentals-q22",
              "question": "Which collection should you use for fast key-based lookups in C#?",
              "topic": "Collections",
              "difficulty": "Beginner",
              "choices": [
                "List<T>",
                "Array",
                "Dictionary<TKey, TValue>",
                "Queue<T>"
              ],
              "correctIndex": 2,
              "explanation": "Dictionary<TKey, TValue> provides O(1) average time complexity for lookups, making it the best choice for fast key-based data retrieval.",
              "industryContext": "Choosing the right collection type is essential for application performance and memory efficiency.",
              "tags": [
                "beginner",
                "dotnet"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90
            },
            {
              "id": "dotnet-fundamentals-q23",
              "question": "What is the purpose of the 'async' and 'await' keywords in C#?",
              "topic": "Async Programming",
              "difficulty": "Intermediate",
              "choices": [
                "To create multi-threaded applications",
                "To enable asynchronous programming and non-blocking operations",
                "To improve application security",
                "To handle exceptions automatically"
              ],
              "correctIndex": 1,
              "explanation": "The 'async' and 'await' keywords enable asynchronous programming, allowing methods to yield control back to the caller while waiting for long-running operations, improving application responsiveness.",
              "industryContext": "Asynchronous programming is essential for building responsive web applications and efficient I/O operations.",
              "tags": [
                "intermediate",
                "dotnet"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 150
            },
            {
              "id": "dotnet-fundamentals-q24",
              "question": "Which statement about value types and reference types is correct?",
              "topic": "Types",
              "difficulty": "Intermediate",
              "choices": [
                "Value types are stored on the heap, reference types on the stack",
                "Value types are stored on the stack, reference types on the heap",
                "Both value types and reference types are stored on the heap",
                "Both value types and reference types are stored on the stack"
              ],
              "correctIndex": 1,
              "explanation": "Value types (like int, bool, struct) are typically stored on the stack and contain their data directly, while reference types (like classes, arrays) are stored on the heap and variables contain references to the actual data.",
              "industryContext": "Understanding memory allocation is crucial for performance optimization and avoiding memory leaks in .NET applications.",
              "tags": [
                "intermediate",
                "dotnet"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 120
            },
            {
              "id": "dotnet-fundamentals-q25",
              "question": "What is the primary benefit of using Entity Framework in .NET applications?",
              "topic": "Entity Framework",
              "difficulty": "Beginner",
              "choices": [
                "It improves application security",
                "It provides an Object-Relational Mapping (ORM) layer for database operations",
                "It makes applications run faster",
                "It reduces memory usage"
              ],
              "correctIndex": 1,
              "explanation": "Entity Framework is an Object-Relational Mapping (ORM) framework that allows developers to work with databases using .NET objects instead of writing raw SQL queries, increasing productivity and maintainability.",
              "industryContext": "Entity Framework is widely used in enterprise .NET applications for data access, making database operations more intuitive and maintainable.",
              "tags": [
                "beginner",
                "dotnet"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90
            }
          ],
          "issues": []
        },
        "meetsThresholds": true,
        "issues": []
      },
      "react-fundamentals": {
        "slug": "react-fundamentals",
        "title": "React Development",
        "tier": "core",
        "track": "Frontend",
        "difficulty": "Intermediate",
        "thresholds": {
          "requiredLessons": 15,
          "requiredQuestions": 20
        },
        "lessons": {
          "exists": true,
          "count": 15,
          "lessons": [
            {
              "id": "react-fundamentals-lesson-1",
              "moduleSlug": "react-fundamentals",
              "title": "React Components Basics",
              "order": 1,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to the revolutionary world of React components - the building blocks that have transformed modern web development into a more intuitive, reusable, and maintainable practice. React's component-based architecture represents a paradigm shift from traditional DOM manipulation to declarative programming, where user interfaces are composed of independent, encapsulated pieces that manage their own state and logic.\n\nComponents in React function as custom HTML elements that encapsulate both structure and behavior, enabling developers to create complex applications from simple, reusable pieces. This approach promotes code reusability, easier testing, and better organization of large-scale applications, making React the preferred choice for companies ranging from startups to Fortune 500 enterprises.\n\nIn this foundational lesson, you'll discover how React components transform static HTML into dynamic, interactive user interfaces through the power of JSX syntax and component composition. You'll learn to think in terms of component hierarchy, data flow, and the unidirectional data pattern that makes React applications predictable and debuggable.\n\nThe component concepts you master here form the cornerstone of React development, enabling you to build everything from simple interactive widgets to complex single-page applications. Understanding components is essential for modern frontend development, as similar patterns have been adopted across frameworks like Vue, Angular, and even native mobile development.\n\nBy the end of this lesson, you'll confidently create, compose, and manage React components, understanding how to structure applications that are both performant and maintainable while following React's core principles of composition over inheritance.",
              "code": {
                "example": "function Welcome(props) {\n  return <h1>Hello, {props.name}</h1>;\n}\n\nfunction App() {\n  return (\n    <div>\n      <Welcome name=\"Sara\" />\n      <Welcome name=\"Cahal\" />\n      <Welcome name=\"Edite\" />\n    </div>\n  );\n}",
                "explanation": "This example produces: Hello, Sara\nHello, Cahal\nHello, Edite\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not using keys in lists",
                  "solution": "Always provide unique keys for list items",
                  "severity": "high"
                },
                {
                  "mistake": "Mutating props directly",
                  "solution": "Props are read-only, create new objects for updates",
                  "severity": "medium"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: React Components Basics",
                  "description": "Apply the concepts from this lesson on Components",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Beginner",
              "tags": [
                "Components",
                "react"
              ],
              "legacy": {
                "originalId": 1,
                "originalTopic": "Components",
                "migrated": "2025-10-01T06:41:13.466Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.474Z",
              "version": "1.0.0"
            },
            {
              "id": "react-fundamentals-lesson-2",
              "moduleSlug": "react-fundamentals",
              "title": "Component State and Lifecycle",
              "order": 2,
              "objectives": [
                "Master component creation and usage",
                "Understand state management and lifecycle",
                "Implement practical solutions"
              ],
              "intro": "Welcome to this comprehensive lesson on Components.\n\nLearn how to manage state and handle component lifecycle events in React.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "class Clock extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {date: new Date()};\n  }\n\n  componentDidMount() {\n    this.timerID = setInterval(\n      () => this.tick(),\n      1000\n    );\n  }\n\n  componentWillUnmount() {\n    clearInterval(this.timerID);\n  }\n\n  tick() {\n    this.setState({\n      date: new Date()\n    });\n  }\n\n  render() {\n    return (\n      <div>\n        <h1>Hello, world!</h1>\n        <h2>It is {this.state.date.toLocaleTimeString()}.</h2>\n      </div>\n    );\n  }\n}",
                "explanation": "This example produces: Hello, world!\nIt is [current time]\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not using keys in lists",
                  "solution": "Always provide unique keys for list items",
                  "severity": "high"
                },
                {
                  "mistake": "Mutating props directly",
                  "solution": "Props are read-only, create new objects for updates",
                  "severity": "medium"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Component State and Lifecycle",
                  "description": "Apply the concepts from this lesson on Components",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Components",
                "react"
              ],
              "legacy": {
                "originalId": 2,
                "originalTopic": "Components",
                "migrated": "2025-10-01T06:41:13.474Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.474Z",
              "version": "1.0.0"
            },
            {
              "id": "react-fundamentals-lesson-3",
              "moduleSlug": "react-fundamentals",
              "title": "Introduction to React Hooks",
              "order": 3,
              "objectives": [
                "Understand state management and lifecycle",
                "Apply hooks for state and effects",
                "Implement practical solutions"
              ],
              "intro": "Welcome to this comprehensive lesson on Hooks.\n\nLearn how to use React Hooks to manage state and side effects in functional components.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "import React, { useState, useEffect } from 'react';\n\nfunction Example() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    document.title = `You clicked ${count} times`;\n  });\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>\n        Click me\n      </button>\n    </div>\n  );\n}",
                "explanation": "This example produces: You clicked 0 times\n[Button: Click me]\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Calling hooks conditionally",
                  "solution": "Always call hooks at the top level",
                  "severity": "high"
                },
                {
                  "mistake": "Missing dependencies in useEffect",
                  "solution": "Include all used variables in dependency array",
                  "severity": "medium"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Introduction to React Hooks",
                  "description": "Apply the concepts from this lesson on Hooks",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Beginner",
              "tags": [
                "Hooks",
                "react"
              ],
              "legacy": {
                "originalId": 3,
                "originalTopic": "Hooks",
                "migrated": "2025-10-01T06:41:13.474Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.474Z",
              "version": "1.0.0"
            },
            {
              "id": "react-fundamentals-lesson-4",
              "moduleSlug": "react-fundamentals",
              "title": "Custom Hooks",
              "order": 4,
              "objectives": [
                "Apply hooks for state and effects",
                "Implement practical solutions"
              ],
              "intro": "Welcome to this comprehensive lesson on Hooks.\n\nLearn how to create custom hooks to reuse stateful logic between components.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "import { useState, useEffect } from 'react';\n\nfunction useFriendStatus(friendID) {\n  const [isOnline, setIsOnline] = useState(null);\n\n  useEffect(() => {\n    function handleStatusChange(status) {\n      setIsOnline(status.isOnline);\n    }\n\n    ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);\n    return () => {\n      ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);\n    };\n  });\n\n  return isOnline;\n}\n\nfunction FriendStatus(props) {\n  const isOnline = useFriendStatus(props.friend.id);\n\n  if (isOnline === null) {\n    return 'Loading...';\n  }\n  return isOnline ? 'Online' : 'Offline';\n}",
                "explanation": "This example produces: Loading... or Online/Offline based on friend status\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Calling hooks conditionally",
                  "solution": "Always call hooks at the top level",
                  "severity": "high"
                },
                {
                  "mistake": "Missing dependencies in useEffect",
                  "solution": "Include all used variables in dependency array",
                  "severity": "medium"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Custom Hooks",
                  "description": "Apply the concepts from this lesson on Hooks",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Advanced",
              "tags": [
                "Hooks",
                "react"
              ],
              "legacy": {
                "originalId": 4,
                "originalTopic": "Hooks",
                "migrated": "2025-10-01T06:41:13.474Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.474Z",
              "version": "1.0.0"
            },
            {
              "id": "react-fundamentals-lesson-5",
              "moduleSlug": "react-fundamentals",
              "title": "React Context API",
              "order": 5,
              "objectives": [
                "Master component creation and usage",
                "Implement practical solutions"
              ],
              "intro": "Welcome to this comprehensive lesson on Context.\n\nLearn how to use React Context to share data between components without prop drilling.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "const themes = {\n  light: {\n    foreground: '#000000',\n    background: '#eeeeee',\n  },\n  dark: {\n    foreground: '#ffffff',\n    background: '#222222',\n  },\n};\n\nconst ThemeContext = React.createContext(themes.light);\n\nfunction App() {\n  return (\n    <ThemeContext.Provider value={themes.dark}>\n      <Toolbar />\n    </ThemeContext.Provider>\n  );\n}\n\nfunction Toolbar(props) {\n  return (\n    <div>\n      <ThemedButton />\n    </div>\n  );\n}\n\nfunction ThemedButton() {\n  const theme = React.useContext(ThemeContext);\n  return (\n    <button style={{ background: theme.background, color: theme.foreground }}>\n      I am styled by theme context!\n    </button>\n  );\n}",
                "explanation": "This example produces: Button with dark theme styling\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: React Context API",
                  "description": "Apply the concepts from this lesson on Context",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Context",
                "react"
              ],
              "legacy": {
                "originalId": 5,
                "originalTopic": "Context",
                "migrated": "2025-10-01T06:41:13.474Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.474Z",
              "version": "1.0.0"
            },
            {
              "id": "react-fundamentals-lesson-6",
              "moduleSlug": "react-fundamentals",
              "title": "Event Handling in React",
              "order": 6,
              "objectives": [
                "Master component creation and usage",
                "Implement practical solutions"
              ],
              "intro": "Welcome to this comprehensive lesson on Event Handling.\n\nLearn how to handle events in React components and understand synthetic events.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "import React, { useState } from 'react';\n\nfunction EventHandling() {\n  const [name, setName] = useState('');\n  const [submittedName, setSubmittedName] = useState('');\n\n  const handleInputChange = (event) => {\n    setName(event.target.value);\n  };\n\n  const handleSubmit = (event) => {\n    event.preventDefault();\n    setSubmittedName(name);\n    setName('');\n  };\n\n  const handleButtonClick = (event) => {\n    console.log('Button clicked!', event.type);\n  };\n\n  return (\n    <div>\n      <form onSubmit={handleSubmit}>\n        <input\n          type=\"text\"\n          value={name}\n          onChange={handleInputChange}\n          placeholder=\"Enter your name\"\n        />\n        <button type=\"submit\">Submit</button>\n      </form>\n      <button onClick={handleButtonClick}>Click me</button>\n      {submittedName && <p>Hello, {submittedName}!</p>}\n    </div>\n  );\n}",
                "explanation": "This example produces: Form with input field and buttons, displays greeting when submitted\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Event Handling in React",
                  "description": "Apply the concepts from this lesson on Event Handling",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Event Handling",
                "react"
              ],
              "legacy": {
                "originalId": 6,
                "originalTopic": "Event Handling",
                "migrated": "2025-10-01T06:41:13.474Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.474Z",
              "version": "1.0.0"
            },
            {
              "id": "react-fundamentals-lesson-7",
              "moduleSlug": "react-fundamentals",
              "title": "Forms and Controlled Components",
              "order": 7,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Forms.\n\nLearn how to create forms and manage form data using controlled components.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "import React, { useState } from 'react';\n\nfunction ContactForm() {\n  const [formData, setFormData] = useState({\n    name: '',\n    email: '',\n    message: '',\n    category: 'general'\n  });\n\n  const [errors, setErrors] = useState({});\n\n  const handleChange = (event) => {\n    const { name, value } = event.target;\n    setFormData(prev => ({\n      ...prev,\n      [name]: value\n    }));\n  };\n\n  const validateForm = () => {\n    const newErrors = {};\n    if (!formData.name.trim()) newErrors.name = 'Name is required';\n    if (!formData.email.trim()) newErrors.email = 'Email is required';\n    if (!formData.message.trim()) newErrors.message = 'Message is required';\n    return newErrors;\n  };\n\n  const handleSubmit = (event) => {\n    event.preventDefault();\n    const formErrors = validateForm();\n    if (Object.keys(formErrors).length === 0) {\n      console.log('Form submitted:', formData);\n      // Reset form\n      setFormData({ name: '', email: '', message: '', category: 'general' });\n    } else {\n      setErrors(formErrors);\n    }\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <input\n        name=\"name\"\n        value={formData.name}\n        onChange={handleChange}\n        placeholder=\"Name\"\n      />\n      {errors.name && <span>{errors.name}</span>}\n      \n      <input\n        name=\"email\"\n        type=\"email\"\n        value={formData.email}\n        onChange={handleChange}\n        placeholder=\"Email\"\n      />\n      {errors.email && <span>{errors.email}</span>}\n      \n      <select name=\"category\" value={formData.category} onChange={handleChange}>\n        <option value=\"general\">General</option>\n        <option value=\"support\">Support</option>\n        <option value=\"sales\">Sales</option>\n      </select>\n      \n      <textarea\n        name=\"message\"\n        value={formData.message}\n        onChange={handleChange}\n        placeholder=\"Message\"\n      />\n      {errors.message && <span>{errors.message}</span>}\n      \n      <button type=\"submit\">Submit</button>\n    </form>\n  );\n}",
                "explanation": "This example produces: Contact form with validation that displays errors for empty required fields\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Forms and Controlled Components",
                  "description": "Apply the concepts from this lesson on Forms",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Forms",
                "react"
              ],
              "legacy": {
                "originalId": 7,
                "originalTopic": "Forms",
                "migrated": "2025-10-01T06:41:13.474Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.474Z",
              "version": "1.0.0"
            },
            {
              "id": "react-fundamentals-lesson-8",
              "moduleSlug": "react-fundamentals",
              "title": "React Router for Navigation",
              "order": 8,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Routing.\n\nLearn how to implement client-side routing in React applications using React Router.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "import React from 'react';\nimport { BrowserRouter as Router, Route, Routes, Link, useParams } from 'react-router-dom';\n\nfunction Home() {\n  return <h2>Home Page</h2>;\n}\n\nfunction About() {\n  return <h2>About Page</h2>;\n}\n\nfunction UserProfile() {\n  const { id } = useParams();\n  return <h2>User Profile: {id}</h2>;\n}\n\nfunction Navigation() {\n  return (\n    <nav>\n      <ul>\n        <li><Link to=\"/\">Home</Link></li>\n        <li><Link to=\"/about\">About</Link></li>\n        <li><Link to=\"/user/123\">User 123</Link></li>\n      </ul>\n    </nav>\n  );\n}\n\nfunction App() {\n  return (\n    <Router>\n      <div>\n        <Navigation />\n        <Routes>\n          <Route path=\"/\" element={<Home />} />\n          <Route path=\"/about\" element={<About />} />\n          <Route path=\"/user/:id\" element={<UserProfile />} />\n        </Routes>\n      </div>\n    </Router>\n  );\n}",
                "explanation": "This example produces: Navigation menu with routes for Home, About, and User Profile pages\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: React Router for Navigation",
                  "description": "Apply the concepts from this lesson on Routing",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Routing",
                "react"
              ],
              "legacy": {
                "originalId": 8,
                "originalTopic": "Routing",
                "migrated": "2025-10-01T06:41:13.474Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.474Z",
              "version": "1.0.0"
            },
            {
              "id": "react-fundamentals-lesson-9",
              "moduleSlug": "react-fundamentals",
              "title": "State Management with useReducer",
              "order": 9,
              "objectives": [
                "Understand state management and lifecycle",
                "Implement practical solutions"
              ],
              "intro": "Welcome to this comprehensive lesson on State Management.\n\nLearn how to manage complex state logic using the useReducer hook.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "import React, { useReducer } from 'react';\n\nconst initialState = {\n  count: 0,\n  history: []\n};\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case 'increment':\n      return {\n        count: state.count + 1,\n        history: [...state.history, `Incremented to ${state.count + 1}`]\n      };\n    case 'decrement':\n      return {\n        count: state.count - 1,\n        history: [...state.history, `Decremented to ${state.count - 1}`]\n      };\n    case 'reset':\n      return {\n        count: 0,\n        history: [...state.history, 'Reset to 0']\n      };\n    default:\n      throw new Error('Unknown action type');\n  }\n}\n\nfunction Counter() {\n  const [state, dispatch] = useReducer(reducer, initialState);\n\n  return (\n    <div>\n      <p>Count: {state.count}</p>\n      <button onClick={() => dispatch({ type: 'increment' })}>+</button>\n      <button onClick={() => dispatch({ type: 'decrement' })}>-</button>\n      <button onClick={() => dispatch({ type: 'reset' })}>Reset</button>\n      \n      <h3>History:</h3>\n      <ul>\n        {state.history.map((item, index) => (\n          <li key={index}>{item}</li>\n        ))}\n      </ul>\n    </div>\n  );\n}",
                "explanation": "This example produces: Counter with increment/decrement buttons and action history\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: State Management with useReducer",
                  "description": "Apply the concepts from this lesson on State Management",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Advanced",
              "tags": [
                "State Management",
                "react"
              ],
              "legacy": {
                "originalId": 9,
                "originalTopic": "State Management",
                "migrated": "2025-10-01T06:41:13.474Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.474Z",
              "version": "1.0.0"
            },
            {
              "id": "react-fundamentals-lesson-10",
              "moduleSlug": "react-fundamentals",
              "title": "Fetching Data with useEffect",
              "order": 10,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on API Integration.\n\nLearn how to fetch data from APIs and handle loading states in React.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "import React, { useState, useEffect } from 'react';\n\nfunction UserList() {\n  const [users, setUsers] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    const fetchUsers = async () => {\n      try {\n        setLoading(true);\n        const response = await fetch('https://jsonplaceholder.typicode.com/users');\n        if (!response.ok) {\n          throw new Error('Failed to fetch users');\n        }\n        const userData = await response.json();\n        setUsers(userData);\n      } catch (err) {\n        setError(err.message);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchUsers();\n  }, []);\n\n  if (loading) return <div>Loading users...</div>;\n  if (error) return <div>Error: {error}</div>;\n\n  return (\n    <div>\n      <h2>Users</h2>\n      <ul>\n        {users.map(user => (\n          <li key={user.id}>\n            <h3>{user.name}</h3>\n            <p>Email: {user.email}</p>\n            <p>Phone: {user.phone}</p>\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n\n// Custom hook for data fetching\nfunction useApi(url) {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    fetch(url)\n      .then(response => response.json())\n      .then(setData)\n      .catch(setError)\n      .finally(() => setLoading(false));\n  }, [url]);\n\n  return { data, loading, error };\n}",
                "explanation": "This example produces: Loading users...\n[Then displays list of users with names, emails, and phone numbers]\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Fetching Data with useEffect",
                  "description": "Apply the concepts from this lesson on API Integration",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "API Integration",
                "react"
              ],
              "legacy": {
                "originalId": 10,
                "originalTopic": "API Integration",
                "migrated": "2025-10-01T06:41:13.474Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.474Z",
              "version": "1.0.0"
            },
            {
              "id": "react-fundamentals-lesson-11",
              "moduleSlug": "react-fundamentals",
              "title": "Performance Optimization with React.memo and useMemo",
              "order": 11,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Performance.\n\nLearn how to optimize React applications using memoization techniques.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "import React, { useState, useMemo, useCallback, memo } from 'react';\n\n// Memoized child component\nconst ExpensiveComponent = memo(({ data, onItemClick }) => {\n  console.log('ExpensiveComponent rendered');\n  \n  return (\n    <div>\n      <h3>Expensive Component</h3>\n      {data.map(item => (\n        <div key={item.id} onClick={() => onItemClick(item)}>\n          {item.name} - {item.value}\n        </div>\n      ))}\n    </div>\n  );\n});\n\nfunction App() {\n  const [count, setCount] = useState(0);\n  const [items, setItems] = useState([\n    { id: 1, name: 'Item 1', value: 10 },\n    { id: 2, name: 'Item 2', value: 20 },\n    { id: 3, name: 'Item 3', value: 30 }\n  ]);\n\n  // Expensive calculation that we want to memoize\n  const expensiveValue = useMemo(() => {\n    console.log('Calculating expensive value...');\n    return items.reduce((sum, item) => sum + item.value, 0) * 1.2;\n  }, [items]);\n\n  // Memoized callback to prevent unnecessary re-renders\n  const handleItemClick = useCallback((item) => {\n    console.log('Item clicked:', item);\n  }, []);\n\n  return (\n    <div>\n      <h1>Performance Optimization Demo</h1>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment Count</button>\n      \n      <p>Expensive Value: {expensiveValue}</p>\n      \n      <ExpensiveComponent \n        data={items} \n        onItemClick={handleItemClick} \n      />\n    </div>\n  );\n}",
                "explanation": "This example produces: Performance optimized app with memoized components and calculations\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Performance Optimization with React.memo and useMemo",
                  "description": "Apply the concepts from this lesson on Performance",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Advanced",
              "tags": [
                "Performance",
                "react"
              ],
              "legacy": {
                "originalId": 11,
                "originalTopic": "Performance",
                "migrated": "2025-10-01T06:41:13.474Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.474Z",
              "version": "1.0.0"
            },
            {
              "id": "react-fundamentals-lesson-12",
              "moduleSlug": "react-fundamentals",
              "title": "Testing React Components",
              "order": 12,
              "objectives": [
                "Master component creation and usage",
                "Implement practical solutions"
              ],
              "intro": "Welcome to this comprehensive lesson on Testing.\n\nLearn how to write tests for React components using React Testing Library.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "import React from 'react';\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport '@testing-library/jest-dom';\n\n// Component to test\nfunction Counter({ initialCount = 0 }) {\n  const [count, setCount] = React.useState(initialCount);\n  \n  return (\n    <div>\n      <h1>Count: {count}</h1>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n      <button onClick={() => setCount(count - 1)}>Decrement</button>\n      <button onClick={() => setCount(0)}>Reset</button>\n    </div>\n  );\n}\n\n// Test file\ndescribe('Counter Component', () => {\n  test('renders with initial count', () => {\n    render(<Counter initialCount={5} />);\n    expect(screen.getByText('Count: 5')).toBeInTheDocument();\n  });\n\n  test('increments count when increment button is clicked', () => {\n    render(<Counter />);\n    const incrementButton = screen.getByText('Increment');\n    fireEvent.click(incrementButton);\n    expect(screen.getByText('Count: 1')).toBeInTheDocument();\n  });\n\n  test('decrements count when decrement button is clicked', () => {\n    render(<Counter initialCount={5} />);\n    const decrementButton = screen.getByText('Decrement');\n    fireEvent.click(decrementButton);\n    expect(screen.getByText('Count: 4')).toBeInTheDocument();\n  });\n\n  test('resets count when reset button is clicked', () => {\n    render(<Counter initialCount={10} />);\n    const resetButton = screen.getByText('Reset');\n    fireEvent.click(resetButton);\n    expect(screen.getByText('Count: 0')).toBeInTheDocument();\n  });\n\n  test('handles multiple interactions', async () => {\n    render(<Counter />);\n    const incrementButton = screen.getByText('Increment');\n    \n    fireEvent.click(incrementButton);\n    fireEvent.click(incrementButton);\n    \n    await waitFor(() => {\n      expect(screen.getByText('Count: 2')).toBeInTheDocument();\n    });\n  });\n});",
                "explanation": "This example produces:  renders with initial count\n increments count when increment button is clicked\n decrements count when decrement button is clicked\n resets count when reset button is clicked\n handles multiple interactions\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Testing React Components",
                  "description": "Apply the concepts from this lesson on Testing",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Testing",
                "react"
              ],
              "legacy": {
                "originalId": 12,
                "originalTopic": "Testing",
                "migrated": "2025-10-01T06:41:13.474Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.474Z",
              "version": "1.0.0"
            },
            {
              "id": "react-fundamentals-lesson-13",
              "moduleSlug": "react-fundamentals",
              "title": "Error Boundaries and Error Handling",
              "order": 13,
              "objectives": [
                "Understand React Error Boundaries and their purpose",
                "Implement comprehensive error handling strategies",
                "Learn error logging and user experience best practices"
              ],
              "intro": "Welcome to this comprehensive lesson on Error Boundaries and Error Handling.\n\nLearn how to gracefully handle errors in React applications and provide robust user experiences.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "import React from 'react';\n\n// Error Boundary Component\nclass ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false, error: null, errorInfo: null };\n  }\n\n  static getDerivedStateFromError(error) {\n    // Update state to trigger fallback UI\n    return { hasError: true };\n  }\n\n  componentDidCatch(error, errorInfo) {\n    // Log error details\n    console.error('Error caught by boundary:', error, errorInfo);\n    \n    // Store error details in state\n    this.setState({\n      error: error,\n      errorInfo: errorInfo\n    });\n\n    // Report to error tracking service\n    // this.logErrorToService(error, errorInfo);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      // Fallback UI\n      return (\n        <div className=\"error-boundary\">\n          <h2>Something went wrong!</h2>\n          <details style={{ whiteSpace: 'pre-wrap' }}>\n            <summary>Click for error details</summary>\n            {this.state.error && this.state.error.toString()}\n            <br />\n            {this.state.errorInfo.componentStack}\n          </details>\n        </div>\n      );\n    }\n\n    return this.props.children;\n  }\n}\n\n// Component that might throw an error\nfunction ProblematicComponent({ shouldThrow }) {\n  if (shouldThrow) {\n    throw new Error('This is a deliberate error for testing!');\n  }\n  return <div>Component loaded successfully!</div>;\n}\n\n// Main App with Error Boundary\nfunction App() {\n  const [shouldThrow, setShouldThrow] = React.useState(false);\n\n  return (\n    <div>\n      <h1>Error Boundary Demo</h1>\n      <button onClick={() => setShouldThrow(!shouldThrow)}>\n        {shouldThrow ? 'Fix Component' : 'Break Component'}\n      </button>\n      \n      <ErrorBoundary>\n        <ProblematicComponent shouldThrow={shouldThrow} />\n      </ErrorBoundary>\n    </div>\n  );\n}",
                "explanation": "This example demonstrates a complete error boundary implementation that catches errors in child components and displays a user-friendly fallback UI. Click 'Break Component' to see the error boundary in action.\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not implementing error boundaries for async operations",
                  "solution": "Error boundaries only catch errors in render, lifecycle methods, and constructors. Use try-catch for async operations",
                  "severity": "high"
                },
                {
                  "mistake": "Not providing meaningful error messages to users",
                  "solution": "Always show user-friendly error messages instead of technical stack traces",
                  "severity": "medium"
                },
                {
                  "mistake": "Not logging errors for debugging",
                  "solution": "Implement proper error logging and reporting to track issues in production",
                  "severity": "medium"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Error Boundaries and Error Handling",
                  "description": "Create error boundaries for different parts of your application and implement comprehensive error handling strategies",
                  "checkpoints": [
                    "Implement an Error Boundary component",
                    "Create fallback UI for different error scenarios",
                    "Add error logging and reporting",
                    "Test error handling in development and production"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 35,
              "difficulty": "Advanced",
              "tags": [
                "Error Handling",
                "Error Boundaries",
                "react"
              ],
              "lastUpdated": "2025-10-01T06:41:13.474Z",
              "version": "1.0.0"
            },
            {
              "id": "react-fundamentals-lesson-14",
              "moduleSlug": "react-fundamentals",
              "title": "Code Splitting and Lazy Loading",
              "order": 14,
              "objectives": [
                "Understand code splitting concepts and benefits",
                "Implement lazy loading with React.lazy and Suspense",
                "Optimize bundle size and loading performance"
              ],
              "intro": "Welcome to this comprehensive lesson on Code Splitting and Lazy Loading.\n\nLearn how to optimize your React application's performance by splitting code and loading components on demand.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "import React, { Suspense, useState } from 'react';\n\n// Lazy loaded components\nconst LazyDashboard = React.lazy(() => import('./Dashboard'));\nconst LazyProfile = React.lazy(() => import('./Profile'));\nconst LazySettings = React.lazy(() => import('./Settings'));\n\n// Loading component\nfunction LoadingSpinner() {\n  return (\n    <div className=\"loading-spinner\">\n      <div className=\"spinner\"></div>\n      <p>Loading...</p>\n    </div>\n  );\n}\n\n// Error fallback component\nfunction ErrorFallback({ error, resetError }) {\n  return (\n    <div className=\"error-fallback\">\n      <h2>Something went wrong loading this component</h2>\n      <p>{error.message}</p>\n      <button onClick={resetError}>Try again</button>\n    </div>\n  );\n}\n\n// Main App with code splitting\nfunction App() {\n  const [currentView, setCurrentView] = useState('home');\n\n  const renderCurrentView = () => {\n    switch (currentView) {\n      case 'dashboard':\n        return <LazyDashboard />;\n      case 'profile':\n        return <LazyProfile />;\n      case 'settings':\n        return <LazySettings />;\n      default:\n        return <div>Welcome to the Home Page!</div>;\n    }\n  };\n\n  return (\n    <div className=\"app\">\n      <nav>\n        <button onClick={() => setCurrentView('home')}>Home</button>\n        <button onClick={() => setCurrentView('dashboard')}>Dashboard</button>\n        <button onClick={() => setCurrentView('profile')}>Profile</button>\n        <button onClick={() => setCurrentView('settings')}>Settings</button>\n      </nav>\n\n      <main>\n        <Suspense fallback={<LoadingSpinner />}>\n          {renderCurrentView()}\n        </Suspense>\n      </main>\n    </div>\n  );\n}\n\n// Example of a lazy-loaded component with its own lazy dependencies\nfunction Dashboard() {\n  const [showChart, setShowChart] = useState(false);\n\n  // Nested lazy loading\n  const LazyChart = React.lazy(() => import('./Chart'));\n\n  return (\n    <div>\n      <h1>Dashboard</h1>\n      <button onClick={() => setShowChart(!showChart)}>\n        {showChart ? 'Hide Chart' : 'Show Chart'}\n      </button>\n      \n      {showChart && (\n        <Suspense fallback={<div>Loading chart...</div>}>\n          <LazyChart />\n        </Suspense>\n      )}\n    </div>\n  );\n}\n\n// Route-based code splitting example\nimport { Route, Routes } from 'react-router-dom';\n\nfunction AppWithRouting() {\n  return (\n    <Routes>\n      <Route path=\"/\" element={<HomePage />} />\n      <Route \n        path=\"/dashboard\" \n        element={\n          <Suspense fallback={<LoadingSpinner />}>\n            <LazyDashboard />\n          </Suspense>\n        } \n      />\n      <Route \n        path=\"/profile\" \n        element={\n          <Suspense fallback={<LoadingSpinner />}>\n            <LazyProfile />\n          </Suspense>\n        } \n      />\n    </Routes>\n  );\n}",
                "explanation": "This example demonstrates comprehensive code splitting strategies including component-level lazy loading, route-based splitting, and nested lazy loading. Components are loaded only when needed, reducing initial bundle size.\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Over-splitting code into too many small chunks",
                  "solution": "Balance between bundle size and number of network requests. Group related functionality together",
                  "severity": "medium"
                },
                {
                  "mistake": "Not handling loading states properly",
                  "solution": "Always provide meaningful loading indicators and error boundaries for lazy-loaded components",
                  "severity": "high"
                },
                {
                  "mistake": "Not preloading critical resources",
                  "solution": "Use resource hints and strategic preloading for components likely to be needed soon",
                  "severity": "medium"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Code Splitting and Lazy Loading",
                  "description": "Implement code splitting in a React application to optimize loading performance",
                  "checkpoints": [
                    "Convert existing components to lazy-loaded components",
                    "Implement route-based code splitting",
                    "Add proper loading states and error boundaries",
                    "Measure and optimize bundle sizes"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 40,
              "difficulty": "Advanced",
              "tags": [
                "Performance",
                "Code Splitting",
                "Lazy Loading",
                "react"
              ],
              "lastUpdated": "2025-10-01T06:41:13.474Z",
              "version": "1.0.0"
            },
            {
              "id": "react-fundamentals-lesson-15",
              "moduleSlug": "react-fundamentals",
              "title": "Deployment and Production Best Practices",
              "order": 15,
              "objectives": [
                "Understand React application deployment strategies",
                "Learn production optimization and security best practices",
                "Implement monitoring and error tracking in production"
              ],
              "intro": "Welcome to this comprehensive lesson on Deployment and Production Best Practices.\n\nLearn how to deploy React applications to production and implement best practices for performance, security, and monitoring.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "// Production build optimization\n// package.json build script\n{\n  \"scripts\": {\n    \"build\": \"react-scripts build\",\n    \"build:analyze\": \"npm run build && npx webpack-bundle-analyzer build/static/js/*.js\",\n    \"build:production\": \"NODE_ENV=production npm run build\"\n  }\n}\n\n// Environment configuration\n// .env.production\nREACT_APP_API_URL=https://api.production.com\nREACT_APP_ENVIRONMENT=production\nREACT_APP_SENTRY_DSN=your-sentry-dsn\nGENERATE_SOURCEMAP=false\n\n// Production configuration component\nimport React from 'react';\n\n// Error tracking setup\nimport * as Sentry from '@sentry/react';\n\nif (process.env.NODE_ENV === 'production') {\n  Sentry.init({\n    dsn: process.env.REACT_APP_SENTRY_DSN,\n    environment: process.env.REACT_APP_ENVIRONMENT,\n    integrations: [\n      new Sentry.BrowserTracing(),\n    ],\n    tracesSampleRate: 0.1,\n  });\n}\n\n// Service Worker registration\nif ('serviceWorker' in navigator && process.env.NODE_ENV === 'production') {\n  window.addEventListener('load', () => {\n    navigator.serviceWorker.register('/sw.js')\n      .then((registration) => {\n        console.log('SW registered: ', registration);\n      })\n      .catch((registrationError) => {\n        console.log('SW registration failed: ', registrationError);\n      });\n  });\n}\n\n// Performance monitoring\nfunction performanceMonitor() {\n  // Core Web Vitals\n  if (typeof window !== 'undefined' && 'performance' in window) {\n    // First Contentful Paint\n    new PerformanceObserver((list) => {\n      for (const entry of list.getEntries()) {\n        if (entry.name === 'first-contentful-paint') {\n          console.log('FCP:', entry.startTime);\n          // Send to analytics\n        }\n      }\n    }).observe({ entryTypes: ['paint'] });\n\n    // Largest Contentful Paint\n    new PerformanceObserver((list) => {\n      const entries = list.getEntries();\n      const lastEntry = entries[entries.length - 1];\n      console.log('LCP:', lastEntry.startTime);\n      // Send to analytics\n    }).observe({ entryTypes: ['largest-contentful-paint'] });\n  }\n}\n\n// Security headers (server configuration example)\n/*\n// nginx.conf or .htaccess\nHeader always set X-Content-Type-Options nosniff\nHeader always set X-Frame-Options DENY\nHeader always set X-XSS-Protection \"1; mode=block\"\nHeader always set Strict-Transport-Security \"max-age=63072000; includeSubDomains; preload\"\nHeader always set Content-Security-Policy \"default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'\"\n*/\n\n// Production-ready App component\nfunction App() {\n  React.useEffect(() => {\n    performanceMonitor();\n  }, []);\n\n  return (\n    <Sentry.ErrorBoundary fallback={ErrorFallback} showDialog>\n      <div className=\"app\">\n        {/* Your app content */}\n      </div>\n    </Sentry.ErrorBoundary>\n  );\n}\n\n// Docker deployment example\n/*\n# Dockerfile\nFROM node:16-alpine as build\nWORKDIR /app\nCOPY package*.json ./\nRUN npm ci --only=production\nCOPY . .\nRUN npm run build\n\nFROM nginx:alpine\nCOPY --from=build /app/build /usr/share/nginx/html\nCOPY nginx.conf /etc/nginx/nginx.conf\nEXPOSE 80\nCMD [\"nginx\", \"-g\", \"daemon off;\"]\n*/\n\n// CI/CD pipeline example (GitHub Actions)\n/*\nname: Deploy to Production\non:\n  push:\n    branches: [main]\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v2\n    - name: Setup Node.js\n      uses: actions/setup-node@v2\n      with:\n        node-version: '16'\n    - name: Install dependencies\n      run: npm ci\n    - name: Run tests\n      run: npm test -- --coverage --watchAll=false\n    - name: Build\n      run: npm run build\n    - name: Deploy to S3\n      run: aws s3 sync build/ s3://your-bucket --delete\n*/",
                "explanation": "This example demonstrates a comprehensive production deployment setup including error tracking, performance monitoring, security headers, Docker containerization, and CI/CD pipeline configuration.\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not optimizing bundle size for production",
                  "solution": "Use webpack-bundle-analyzer, tree shaking, and code splitting to minimize bundle size",
                  "severity": "high"
                },
                {
                  "mistake": "Missing security headers and CSP",
                  "solution": "Implement comprehensive security headers and Content Security Policy for production",
                  "severity": "high"
                },
                {
                  "mistake": "Not monitoring application performance",
                  "solution": "Implement Core Web Vitals monitoring and error tracking with tools like Sentry",
                  "severity": "medium"
                },
                {
                  "mistake": "Including source maps in production",
                  "solution": "Disable source maps in production or serve them separately for debugging",
                  "severity": "medium"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Deployment and Production Best Practices",
                  "description": "Deploy a React application to production with proper optimization and monitoring",
                  "checkpoints": [
                    "Optimize build for production deployment",
                    "Implement error tracking and performance monitoring",
                    "Configure security headers and CSP",
                    "Set up CI/CD pipeline for automated deployment",
                    "Test application in production environment"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 45,
              "difficulty": "Advanced",
              "tags": [
                "Deployment",
                "Production",
                "Performance",
                "Security",
                "react"
              ],
              "lastUpdated": "2025-10-01T06:41:13.474Z",
              "version": "1.0.0"
            }
          ],
          "issues": []
        },
        "quiz": {
          "exists": true,
          "count": 20,
          "questions": [
            {
              "id": "react-fundamentals-q1",
              "question": "What is the correct way to create a React component?",
              "topic": "Components",
              "difficulty": "Beginner",
              "choices": [
                "function MyComponent() { return <div>Hello</div>; }",
                "class MyComponent { render() { return <div>Hello</div>; } }",
                "MyComponent() => { return <div>Hello</div>; }",
                "const MyComponent = { <div>Hello</div> }"
              ],
              "correctIndex": 0,
              "explanation": "In modern React, functional components are the preferred way to create components. They are simpler and can use hooks for state and side effects.",
              "industryContext": "React is widely used in enterprise applications for building scalable user interfaces.",
              "tags": [
                "Components",
                "beginner",
                "react"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 1,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.477Z"
              }
            },
            {
              "id": "react-fundamentals-q2",
              "question": "How do you pass data to a React component?",
              "topic": "Components",
              "difficulty": "Beginner",
              "choices": [
                "Using props",
                "Using state",
                "Using context",
                "Using refs"
              ],
              "correctIndex": 0,
              "explanation": "Props are used to pass data from a parent component to a child component in React.",
              "industryContext": "React is widely used in enterprise applications for building scalable user interfaces.",
              "tags": [
                "Components",
                "beginner",
                "react"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 2,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.477Z"
              }
            },
            {
              "id": "react-fundamentals-q3",
              "question": "What are React Hooks and why were they introduced?",
              "topic": "Hooks",
              "difficulty": "Intermediate",
              "choices": [
                "Open-ended question - no multiple choice",
                "This is a conceptual question",
                "Answer requires explanation",
                "Multiple approaches possible"
              ],
              "correctIndex": 0,
              "explanation": "React Hooks are functions that let you 'hook into' React state and lifecycle features from function components. They were introduced to allow using state and other React features without writing a class, making components simpler and easier to reuse.",
              "industryContext": "React is widely used in enterprise applications for building scalable user interfaces.",
              "tags": [
                "Hooks",
                "intermediate",
                "react"
              ],
              "questionType": "open-ended",
              "estimatedTime": 180,
              "legacy": {
                "originalId": 3,
                "originalType": "open-ended",
                "migrated": "2025-10-01T06:41:13.477Z"
              }
            },
            {
              "id": "react-fundamentals-q4",
              "question": "Which hook is used to manage state in a functional component?",
              "topic": "Hooks",
              "difficulty": "Intermediate",
              "choices": [
                "useState",
                "useEffect",
                "useContext",
                "useReducer"
              ],
              "correctIndex": 0,
              "explanation": "The useState hook is used to add state to functional components in React.",
              "industryContext": "React is widely used in enterprise applications for building scalable user interfaces.",
              "tags": [
                "Hooks",
                "intermediate",
                "react"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 4,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.477Z"
              }
            },
            {
              "id": "react-fundamentals-q5",
              "question": "What is the purpose of React Context?",
              "topic": "Context",
              "difficulty": "Beginner",
              "choices": [
                "To share data between components without prop drilling",
                "To manage component state",
                "To handle side effects",
                "To optimize component performance"
              ],
              "correctIndex": 0,
              "explanation": "React Context provides a way to pass data through the component tree without having to pass props down manually at every level.",
              "industryContext": "React is widely used in enterprise applications for building scalable user interfaces.",
              "tags": [
                "Context",
                "beginner",
                "react"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 5,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.477Z"
              }
            },
            {
              "id": "react-fundamentals-q6",
              "question": "Which method is called after a component is rendered for the first time?",
              "topic": "Lifecycle",
              "difficulty": "Intermediate",
              "choices": [
                "componentDidMount",
                "componentDidUpdate",
                "componentWillUnmount",
                "render"
              ],
              "correctIndex": 0,
              "explanation": "componentDidMount is called immediately after a component is mounted (inserted into the tree).",
              "industryContext": "React is widely used in enterprise applications for building scalable user interfaces.",
              "tags": [
                "Lifecycle",
                "intermediate",
                "react"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 6,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.477Z"
              }
            },
            {
              "id": "react-fundamentals-q7",
              "question": "What is the virtual DOM and how does it improve React performance?",
              "topic": "Rendering",
              "difficulty": "Beginner",
              "choices": [
                "Open-ended question - no multiple choice",
                "This is a conceptual question",
                "Answer requires explanation",
                "Multiple approaches possible"
              ],
              "correctIndex": 0,
              "explanation": "The virtual DOM is a lightweight JavaScript representation of the actual DOM. React uses it to optimize updates by comparing the virtual DOM with the real DOM and only updating the parts that have changed, reducing expensive DOM operations.",
              "industryContext": "React is widely used in enterprise applications for building scalable user interfaces.",
              "tags": [
                "Rendering",
                "beginner",
                "react"
              ],
              "questionType": "open-ended",
              "estimatedTime": 180,
              "legacy": {
                "originalId": 7,
                "originalType": "open-ended",
                "migrated": "2025-10-01T06:41:13.477Z"
              }
            },
            {
              "id": "react-fundamentals-q8",
              "question": "How do you update state in a functional component?",
              "topic": "State",
              "difficulty": "Beginner",
              "choices": [
                "Using the setter function returned by useState",
                "Directly modifying the state variable",
                "Using this.setState",
                "Using forceUpdate"
              ],
              "correctIndex": 0,
              "explanation": "When using useState, you get a state variable and a setter function. You must use the setter function to update state.",
              "industryContext": "React is widely used in enterprise applications for building scalable user interfaces.",
              "tags": [
                "State",
                "beginner",
                "react"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 8,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.477Z"
              }
            },
            {
              "id": "react-fundamentals-q9",
              "question": "What is the purpose of useCallback hook?",
              "topic": "Hooks",
              "difficulty": "Beginner",
              "choices": [
                "Memoize functions to prevent unnecessary re-renders",
                "Cache API responses",
                "Handle user callbacks",
                "Create callback refs"
              ],
              "correctIndex": 0,
              "explanation": "useCallback memoizes functions to prevent unnecessary re-renders of child components when the parent re-renders, optimizing performance by maintaining referential equality.",
              "industryContext": "React is widely used in enterprise applications for building scalable user interfaces.",
              "tags": [
                "Hooks",
                "beginner",
                "react"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 9,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.477Z"
              }
            },
            {
              "id": "react-fundamentals-q10",
              "question": "What does React.memo() do?",
              "topic": "Performance",
              "difficulty": "Intermediate",
              "choices": [
                "Prevents re-renders if props haven't changed",
                "Memoizes state values",
                "Caches API calls",
                "Optimizes memory usage"
              ],
              "correctIndex": 0,
              "explanation": "React.memo() is a higher-order component that memoizes the component and only re-renders if its props have changed, improving performance.",
              "industryContext": "React is widely used in enterprise applications for building scalable user interfaces.",
              "tags": [
                "Performance",
                "intermediate",
                "react"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 10,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.477Z"
              }
            },
            {
              "id": "react-fundamentals-q11",
              "question": "When should you use useReducer instead of useState?",
              "topic": "State Management",
              "difficulty": "Intermediate",
              "choices": [
                "Open-ended question - no multiple choice",
                "This is a conceptual question",
                "Answer requires explanation",
                "Multiple approaches possible"
              ],
              "correctIndex": 0,
              "explanation": "Use useReducer when: state logic is complex with multiple sub-values, next state depends on previous state, you have complex state transitions, managing state that involves multiple actions, or when you need more predictable state updates.",
              "industryContext": "React is widely used in enterprise applications for building scalable user interfaces.",
              "tags": [
                "State Management",
                "intermediate",
                "react"
              ],
              "questionType": "open-ended",
              "estimatedTime": 180,
              "legacy": {
                "originalId": 11,
                "originalType": "open-ended",
                "migrated": "2025-10-01T06:41:13.477Z"
              }
            },
            {
              "id": "react-fundamentals-q12",
              "question": "Which library is commonly used for testing React components?",
              "topic": "Testing",
              "difficulty": "Intermediate",
              "choices": [
                "React Testing Library",
                "Selenium",
                "JUnit",
                "PHPUnit"
              ],
              "correctIndex": 0,
              "explanation": "React Testing Library is the most popular choice for testing React components, focusing on testing behavior rather than implementation details.",
              "industryContext": "React is widely used in enterprise applications for building scalable user interfaces.",
              "tags": [
                "Testing",
                "intermediate",
                "react"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 12,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.477Z"
              }
            },
            {
              "id": "react-fundamentals-q13",
              "question": "What is an Error Boundary in React?",
              "topic": "Error Handling",
              "difficulty": "Beginner",
              "choices": [
                "A component that catches JavaScript errors in child components",
                "A validation method for props",
                "A routing mechanism",
                "A state management tool"
              ],
              "correctIndex": 0,
              "explanation": "Error Boundaries are React components that catch JavaScript errors anywhere in their child component tree, log those errors, and display a fallback UI.",
              "industryContext": "React is widely used in enterprise applications for building scalable user interfaces.",
              "tags": [
                "Error Handling",
                "beginner",
                "react"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 13,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.477Z"
              }
            },
            {
              "id": "react-fundamentals-q14",
              "question": "What are React Portals and when would you use them?",
              "topic": "Advanced",
              "difficulty": "Intermediate",
              "choices": [
                "Open-ended question - no multiple choice",
                "This is a conceptual question",
                "Answer requires explanation",
                "Multiple approaches possible"
              ],
              "correctIndex": 0,
              "explanation": "React Portals provide a way to render children into a DOM node that exists outside the DOM hierarchy of the parent component. Use them for modals, tooltips, or dropdowns that need to escape parent containers with overflow:hidden or z-index stacking contexts.",
              "industryContext": "React is widely used in enterprise applications for building scalable user interfaces.",
              "tags": [
                "Advanced",
                "intermediate",
                "react"
              ],
              "questionType": "open-ended",
              "estimatedTime": 180,
              "legacy": {
                "originalId": 14,
                "originalType": "open-ended",
                "migrated": "2025-10-01T06:41:13.477Z"
              }
            },
            {
              "id": "react-fundamentals-q15",
              "question": "What is React Suspense used for?",
              "topic": "Concurrency",
              "difficulty": "Beginner",
              "choices": [
                "Handling loading states for async operations",
                "Suspending component updates",
                "Pausing animations",
                "Managing timeouts"
              ],
              "correctIndex": 0,
              "explanation": "React Suspense lets components 'wait' for something before rendering, typically used with lazy loading and data fetching to handle loading states declaratively.",
              "industryContext": "React is widely used in enterprise applications for building scalable user interfaces.",
              "tags": [
                "Concurrency",
                "beginner",
                "react"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 15,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.477Z"
              }
            },
            {
              "id": "react-fundamentals-q16",
              "question": "What is the difference between React.lazy() and dynamic imports in React?",
              "topic": "Code Splitting",
              "difficulty": "Advanced",
              "choices": [
                "React.lazy() is specifically for React components, dynamic imports are for any module",
                "React.lazy() works only with default exports, dynamic imports work with named exports",
                "React.lazy() requires Suspense, dynamic imports don't",
                "All of the above"
              ],
              "correctIndex": 3,
              "explanation": "All statements are correct: React.lazy() is designed specifically for React components and requires default exports, it must be wrapped with Suspense for loading states, while dynamic imports are more general-purpose for any module type.",
              "industryContext": "Code splitting is essential for large-scale React applications to improve loading performance and user experience.",
              "tags": [
                "Code Splitting",
                "advanced",
                "react"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 120
            },
            {
              "id": "react-fundamentals-q17",
              "question": "When implementing Error Boundaries, which lifecycle methods should you use?",
              "topic": "Error Handling",
              "difficulty": "Advanced",
              "choices": [
                "componentDidCatch() only",
                "getDerivedStateFromError() only",
                "Both getDerivedStateFromError() and componentDidCatch()",
                "componentDidMount() and componentDidUpdate()"
              ],
              "correctIndex": 2,
              "explanation": "Error Boundaries should use both getDerivedStateFromError() to update state and trigger fallback UI, and componentDidCatch() to log error information and perform side effects.",
              "industryContext": "Proper error handling is crucial for production React applications to provide good user experience and debugging capabilities.",
              "tags": [
                "Error Handling",
                "advanced",
                "react"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 120
            },
            {
              "id": "react-fundamentals-q18",
              "question": "What are the key considerations when deploying a React application to production?",
              "topic": "Deployment",
              "difficulty": "Advanced",
              "choices": [
                "Open-ended question - no multiple choice",
                "This is a conceptual question",
                "Answer requires explanation",
                "Multiple approaches possible"
              ],
              "correctIndex": 0,
              "explanation": "Key considerations include: optimizing bundle size (code splitting, tree shaking), implementing security headers and CSP, setting up error tracking and monitoring, configuring proper caching strategies, disabling source maps, implementing CI/CD pipelines, and ensuring performance meets Core Web Vitals standards.",
              "industryContext": "Production deployment requires careful consideration of performance, security, and monitoring to ensure reliable user experience.",
              "tags": [
                "Deployment",
                "advanced",
                "react"
              ],
              "questionType": "open-ended",
              "estimatedTime": 180
            },
            {
              "id": "react-fundamentals-q19",
              "question": "Which React feature allows you to render components outside their parent DOM hierarchy?",
              "topic": "Advanced",
              "difficulty": "Intermediate",
              "choices": [
                "React Portals",
                "React Context",
                "React Fragments",
                "React Suspense"
              ],
              "correctIndex": 0,
              "explanation": "React Portals provide a way to render children into a DOM node that exists outside the DOM hierarchy of the parent component, useful for modals, tooltips, and dropdowns.",
              "industryContext": "Portals are commonly used in enterprise applications for creating overlay components that need to escape parent container constraints.",
              "tags": [
                "Advanced",
                "intermediate",
                "react"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90
            },
            {
              "id": "react-fundamentals-q20",
              "question": "What is the purpose of React.StrictMode and when should you use it?",
              "topic": "Development Tools",
              "difficulty": "Intermediate",
              "choices": [
                "To enforce stricter TypeScript checking",
                "To identify side effects and deprecated features during development",
                "To improve performance in production",
                "To enable concurrent rendering features"
              ],
              "correctIndex": 1,
              "explanation": "React.StrictMode is a development tool that helps identify side effects, unsafe lifecycles, and deprecated features by intentionally double-invoking functions and methods during development.",
              "industryContext": "StrictMode is essential for maintaining code quality and preparing applications for future React features like concurrent rendering.",
              "tags": [
                "Development Tools",
                "intermediate",
                "react"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90
            }
          ],
          "issues": []
        },
        "meetsThresholds": true,
        "issues": []
      },
      "database-systems": {
        "slug": "database-systems",
        "title": "Database Systems",
        "tier": "core",
        "track": "Backend",
        "difficulty": "Intermediate",
        "thresholds": {
          "requiredLessons": 16,
          "requiredQuestions": 22
        },
        "lessons": {
          "exists": true,
          "count": 16,
          "lessons": [
            {
              "id": "database-systems-lesson-1",
              "moduleSlug": "database-systems",
              "title": "Relational Model and Normalization",
              "order": 1,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to the fundamental world of database design and relational data modeling - the cornerstone of data-driven applications that power everything from e-commerce platforms to social networks. Understanding the relational model is essential for creating efficient, scalable, and maintainable database systems that can handle real-world business requirements while ensuring data integrity and performance.\n\nThe relational model, introduced by Edgar F. Codd in 1970, revolutionized how we think about data storage and retrieval by organizing information into tables with clearly defined relationships. This approach provides a mathematical foundation for data operations while offering intuitive concepts that translate directly to business logic and application requirements.\n\nIn this comprehensive introduction, you'll master the essential concepts of primary keys, foreign keys, and referential integrity that ensure data consistency across your database. You'll explore normalization principles that eliminate data redundancy and update anomalies, learning to design schemas that balance efficiency with maintainability for various application scenarios.\n\nDatabase constraints and indexes form the backbone of data quality and performance optimization. Understanding how to properly implement these features prevents data corruption, enforces business rules at the database level, and ensures your applications can scale from hundreds to millions of records without performance degradation.\n\nBy the end of this lesson, you'll confidently design relational database schemas that reflect real-world business requirements, implement proper constraints for data integrity, and create efficient table structures that serve as the foundation for robust, scalable applications.",
              "code": {
                "example": "-- Creating a properly normalized table with constraints\nCREATE TABLE users (\n  id INT PRIMARY KEY AUTO_INCREMENT,\n  first_name VARCHAR(50) NOT NULL,\n  last_name VARCHAR(50) NOT NULL,\n  email VARCHAR(100) UNIQUE NOT NULL,\n  birth_date DATE,\n  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n  CHECK (email LIKE '%@%'),\n  INDEX idx_email (email),\n  INDEX idx_name (last_name, first_name)\n);\n\n-- Inserting data with proper validation\nINSERT INTO users (first_name, last_name, email, birth_date) VALUES \n('John', 'Doe', 'john@example.com', '1990-05-15'),\n('Jane', 'Smith', 'jane@example.com', '1985-12-03');\n\n-- Querying with joins and ordering\nSELECT first_name, last_name, email FROM users \nWHERE birth_date > '1980-01-01' \nORDER BY last_name, first_name;\n\n-- First Normal Form (1NF) - Atomic values\n-- Second Normal Form (2NF) - 1NF + no partial dependencies\n-- Third Normal Form (3NF) - 2NF + no transitive dependencies",
                "explanation": "This example produces: Properly normalized table with constraints, indexes, and sample data following database design best practices\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "sql"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Relational Model and Normalization",
                  "description": "Apply the concepts from this lesson on Database Fundamentals",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Database Fundamentals",
                "database"
              ],
              "legacy": {
                "originalId": 1,
                "originalTopic": "Database Fundamentals",
                "migrated": "2025-10-01T06:41:13.481Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.481Z",
              "version": "1.0.0"
            },
            {
              "id": "database-systems-lesson-2",
              "moduleSlug": "database-systems",
              "title": "Keys, Constraints, and Indexes",
              "order": 2,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Database Fundamentals.\n\nLearn about different types of keys, constraints for data integrity, and indexes for performance optimization.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "-- Primary key (unique identifier)\nCREATE TABLE products (\n  product_id INT PRIMARY KEY AUTO_INCREMENT,\n  sku VARCHAR(50) UNIQUE NOT NULL,\n  name VARCHAR(100) NOT NULL,\n  price DECIMAL(10, 2) NOT NULL CHECK (price >= 0),\n  category_id INT,\n  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\n-- Foreign key (relationship between tables)\nCREATE TABLE orders (\n  order_id INT PRIMARY KEY AUTO_INCREMENT,\n  user_id INT NOT NULL,\n  order_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n  status ENUM('pending', 'processing', 'shipped', 'delivered') DEFAULT 'pending',\n  total_amount DECIMAL(10, 2) NOT NULL CHECK (total_amount >= 0),\n  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,\n  INDEX idx_user_date (user_id, order_date),\n  INDEX idx_status (status)\n);\n\n-- Composite primary key\nCREATE TABLE order_items (\n  order_id INT,\n  product_id INT,\n  quantity INT NOT NULL CHECK (quantity > 0),\n  price_per_unit DECIMAL(10, 2) NOT NULL,\n  PRIMARY KEY (order_id, product_id),\n  FOREIGN KEY (order_id) REFERENCES orders(order_id) ON DELETE CASCADE,\n  FOREIGN KEY (product_id) REFERENCES products(product_id)\n);\n\n-- Check constraints for business rules\nALTER TABLE users \nADD CONSTRAINT chk_birth_date CHECK (birth_date <= CURDATE() AND birth_date >= '1900-01-01');",
                "explanation": "This example produces: Database schema with proper keys, constraints, and indexes for data integrity and performance\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "sql"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Keys, Constraints, and Indexes",
                  "description": "Apply the concepts from this lesson on Database Fundamentals",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Advanced",
              "tags": [
                "Database Fundamentals",
                "database"
              ],
              "legacy": {
                "originalId": 2,
                "originalTopic": "Database Fundamentals",
                "migrated": "2025-10-01T06:41:13.481Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.481Z",
              "version": "1.0.0"
            },
            {
              "id": "database-systems-lesson-3",
              "moduleSlug": "database-systems",
              "title": "Advanced Queries with Joins, Subqueries, and Set Operations",
              "order": 3,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on SQL.\n\nLearn how to write complex queries using different join types, subqueries, and set operations for data analysis.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "-- Different types of joins\n-- Inner join (only matching records)\nSELECT u.first_name, u.last_name, o.order_date, o.total_amount\nFROM users u\nINNER JOIN orders o ON u.id = o.user_id;\n\n-- Left join (all users, even without orders)\nSELECT u.first_name, u.last_name, COUNT(o.order_id) as order_count\nFROM users u\nLEFT JOIN orders o ON u.id = o.user_id\nGROUP BY u.id, u.first_name, u.last_name;\n\n-- Subqueries\n-- Correlated subquery\nSELECT first_name, last_name\nFROM users u\nWHERE EXISTS (\n  SELECT 1 FROM orders o \n  WHERE o.user_id = u.id AND o.total_amount > 1000\n);\n\n-- Subquery in SELECT\nSELECT first_name, last_name,\n  (SELECT COUNT(*) FROM orders WHERE user_id = users.id) as order_count\nFROM users;\n\n-- Set operations\n-- UNION (combines results, removes duplicates)\nSELECT first_name FROM users WHERE first_name LIKE 'J%'\nUNION\nSELECT name FROM products WHERE name LIKE 'J%';\n\n-- UNION ALL (combines results, keeps duplicates)\nSELECT email FROM users\nUNION ALL\nSELECT email FROM newsletter_subscribers;",
                "explanation": "This example produces: Complex queries demonstrating various join types, correlated and non-correlated subqueries, and set operations\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "sql"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Advanced Queries with Joins, Subqueries, and Set Operations",
                  "description": "Apply the concepts from this lesson on SQL",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Advanced",
              "tags": [
                "SQL",
                "database"
              ],
              "legacy": {
                "originalId": 3,
                "originalTopic": "SQL",
                "migrated": "2025-10-01T06:41:13.481Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.481Z",
              "version": "1.0.0"
            },
            {
              "id": "database-systems-lesson-4",
              "moduleSlug": "database-systems",
              "title": "ER Diagrams and Advanced Relationships",
              "order": 4,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Data Modeling.\n\nLearn how to create comprehensive Entity-Relationship diagrams and model complex relationships including inheritance and polymorphic associations.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "-- One-to-One relationship (User Profile)\nCREATE TABLE users (\n  id INT PRIMARY KEY AUTO_INCREMENT,\n  username VARCHAR(50) UNIQUE NOT NULL\n);\n\nCREATE TABLE profiles (\n  id INT PRIMARY KEY AUTO_INCREMENT,\n  user_id INT UNIQUE,  -- UNIQUE constraint makes it one-to-one\n  bio TEXT,\n  website VARCHAR(100),\n  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE\n);\n\n-- Many-to-Many with attributes (Enrollment with grades)\nCREATE TABLE students (\n  id INT PRIMARY KEY AUTO_INCREMENT,\n  name VARCHAR(100) NOT NULL\n);\n\nCREATE TABLE courses (\n  id INT PRIMARY KEY AUTO_INCREMENT,\n  title VARCHAR(100) NOT NULL,\n  credits INT DEFAULT 3\n);\n\nCREATE TABLE enrollments (\n  student_id INT,\n  course_id INT,\n  enrollment_date DATE,\n  grade CHAR(2),\n  PRIMARY KEY (student_id, course_id),\n  FOREIGN KEY (student_id) REFERENCES students(id) ON DELETE CASCADE,\n  FOREIGN KEY (course_id) REFERENCES courses(id) ON DELETE CASCADE\n);\n\n-- Hierarchical data (Adjacency List Model)\nCREATE TABLE categories (\n  id INT PRIMARY KEY AUTO_INCREMENT,\n  name VARCHAR(100) NOT NULL,\n  parent_id INT,\n  FOREIGN KEY (parent_id) REFERENCES categories(id)\n);\n\n-- Self-referencing relationship (Manager-Subordinate)\nCREATE TABLE employees (\n  id INT PRIMARY KEY AUTO_INCREMENT,\n  name VARCHAR(100) NOT NULL,\n  manager_id INT,\n  FOREIGN KEY (manager_id) REFERENCES employees(id)\n);",
                "explanation": "This example produces: Advanced database schema designs showing one-to-one relationships, many-to-many with attributes, and hierarchical data modeling\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "sql"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: ER Diagrams and Advanced Relationships",
                  "description": "Apply the concepts from this lesson on Data Modeling",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Advanced",
              "tags": [
                "Data Modeling",
                "database"
              ],
              "legacy": {
                "originalId": 4,
                "originalTopic": "Data Modeling",
                "migrated": "2025-10-01T06:41:13.481Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.481Z",
              "version": "1.0.0"
            },
            {
              "id": "database-systems-lesson-5",
              "moduleSlug": "database-systems",
              "title": "Entity Framework Core Advanced Patterns",
              "order": 5,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on ORM Integration.\n\nLearn advanced Entity Framework Core patterns including lazy loading, eager loading, and performance optimization techniques.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "// Entity classes with relationships\npublic class Blog\n{\n    public int BlogId { get; set; }\n    public string Url { get; set; } = string.Empty;\n    \n    // Navigation property for related posts\n    public List<Post> Posts { get; } = new();\n    \n    // One-to-one relationship\n    public BlogDetails? BlogDetails { get; set; }\n}\n\npublic class Post\n{\n    public int PostId { get; set; }\n    public string Title { get; set; } = string.Empty;\n    public string Content { get; set; } = string.Empty;\n    \n    // Foreign key\n    public int BlogId { get; set; }\n    \n    // Navigation property\n    public Blog Blog { get; set; } = null!;\n    \n    // Many-to-many relationship\n    public List<Tag> Tags { get; } = new();\n}\n\npublic class Tag\n{\n    public int TagId { get; set; }\n    public string Name { get; set; } = string.Empty;\n    \n    public List<Post> Posts { get; } = new();\n}\n\npublic class BlogDetails\n{\n    public int BlogDetailsId { get; set; }\n    public DateTime CreatedOn { get; set; }\n    public string Owner { get; set; } = string.Empty;\n    \n    public int BlogId { get; set; }\n    public Blog Blog { get; set; } = null!;\n}\n\n// DbContext with advanced configuration\npublic class BloggingContext : DbContext\n{\n    public DbSet<Blog> Blogs { get; set; }\n    public DbSet<Post> Posts { get; set; }\n    public DbSet<Tag> Tags { get; set; }\n    public DbSet<BlogDetails> BlogDetails { get; set; }\n    \n    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)\n    {\n        optionsBuilder.UseSqlServer(\n            @\"Server=(localdb)\\mssqllocaldb;Database=Blogging;Trusted_Connection=True\");\n    }\n    \n    protected override void OnModelCreating(ModelBuilder modelBuilder)\n    {\n        // Configure many-to-many relationship\n        modelBuilder.Entity<Post>()\n            .HasMany(p => p.Tags)\n            .WithMany(t => t.Posts)\n            .UsingEntity(j => j.ToTable(\"PostTags\"));\n            \n        // Configure indexes\n        modelBuilder.Entity<Blog>()\n            .HasIndex(b => b.Url)\n            .IsUnique();\n    }\n}\n\n// Query optimization examples\n// Eager loading to avoid N+1 problem\nvar blogs = context.Blogs\n    .Include(b => b.Posts)\n        .ThenInclude(p => p.Tags)\n    .ToList();\n    \n// Projection to load only needed data\nvar blogSummaries = context.Blogs\n    .Select(b => new { b.Url, PostCount = b.Posts.Count() })\n    .ToList();",
                "explanation": "This example produces: Advanced C# entity classes and DbContext configuration showing relationships, navigation properties, and performance optimization techniques\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "sql"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Entity Framework Core Advanced Patterns",
                  "description": "Apply the concepts from this lesson on ORM Integration",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Advanced",
              "tags": [
                "ORM Integration",
                "database"
              ],
              "legacy": {
                "originalId": 5,
                "originalTopic": "ORM Integration",
                "migrated": "2025-10-01T06:41:13.481Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.481Z",
              "version": "1.0.0"
            },
            {
              "id": "database-systems-lesson-6",
              "moduleSlug": "database-systems",
              "title": "ACID Properties and Transaction Management",
              "order": 6,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Transactions.\n\nLearn about ACID properties, transaction isolation levels, and managing concurrent database operations.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "-- Transaction with ACID properties\nSTART TRANSACTION;\n\n-- Atomicity: All operations succeed or all fail\nUPDATE accounts SET balance = balance - 100 WHERE id = 1;\nUPDATE accounts SET balance = balance + 100 WHERE id = 2;\n\n-- Check for errors and commit or rollback\nIF @@ERROR = 0\n  COMMIT;\nELSE\n  ROLLBACK;\n\n-- Isolation levels\nSET TRANSACTION ISOLATION LEVEL READ COMMITTED;\nSET TRANSACTION ISOLATION LEVEL REPEATABLE READ;\nSET TRANSACTION ISOLATION LEVEL SERIALIZABLE;\n\n-- Savepoints for partial rollbacks\nSTART TRANSACTION;\nINSERT INTO users (name, email) VALUES ('John', 'john@example.com');\nSAVEPOINT sp1;\nINSERT INTO orders (user_id, total) VALUES (1, 100);\n-- Rollback to savepoint if needed\nROLLBACK TO SAVEPOINT sp1;\nCOMMIT;",
                "explanation": "This example produces: Safe transaction handling with ACID compliance and rollback capabilities\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "sql"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: ACID Properties and Transaction Management",
                  "description": "Apply the concepts from this lesson on Transactions",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Transactions",
                "database"
              ],
              "legacy": {
                "originalId": 6,
                "originalTopic": "Transactions",
                "migrated": "2025-10-01T06:41:13.481Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.481Z",
              "version": "1.0.0"
            },
            {
              "id": "database-systems-lesson-7",
              "moduleSlug": "database-systems",
              "title": "Query Optimization and Execution Plans",
              "order": 7,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Performance.\n\nLearn how to analyze and optimize query performance using execution plans and indexing strategies.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "-- Analyze query execution plan\nEXPLAIN SELECT u.name, COUNT(o.id) as order_count\nFROM users u\nLEFT JOIN orders o ON u.id = o.user_id\nWHERE u.created_at > '2023-01-01'\nGROUP BY u.id, u.name\nHAVING COUNT(o.id) > 5;\n\n-- Create indexes for better performance\nCREATE INDEX idx_users_created_at ON users(created_at);\nCREATE INDEX idx_orders_user_id ON orders(user_id);\nCREATE INDEX idx_composite ON orders(user_id, created_at);\n\n-- Query optimization techniques\n-- 1. Use LIMIT for large datasets\nSELECT * FROM products ORDER BY price DESC LIMIT 10;\n\n-- 2. Use EXISTS instead of IN for subqueries\nSELECT * FROM users u\nWHERE EXISTS (SELECT 1 FROM orders o WHERE o.user_id = u.id);\n\n-- 3. Avoid SELECT * in production\nSELECT id, name, email FROM users WHERE active = 1;\n\n-- Partitioning for large tables\nCREATE TABLE sales (\n  id INT,\n  sale_date DATE,\n  amount DECIMAL(10,2)\n) PARTITION BY RANGE (YEAR(sale_date)) (\n  PARTITION p2022 VALUES LESS THAN (2023),\n  PARTITION p2023 VALUES LESS THAN (2024),\n  PARTITION p2024 VALUES LESS THAN (2025)\n);",
                "explanation": "This example produces: Optimized queries with proper indexing and execution plan analysis\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "sql"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Query Optimization and Execution Plans",
                  "description": "Apply the concepts from this lesson on Performance",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Advanced",
              "tags": [
                "Performance",
                "database"
              ],
              "legacy": {
                "originalId": 7,
                "originalTopic": "Performance",
                "migrated": "2025-10-01T06:41:13.481Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.481Z",
              "version": "1.0.0"
            },
            {
              "id": "database-systems-lesson-8",
              "moduleSlug": "database-systems",
              "title": "Stored Procedures and User-Defined Functions",
              "order": 8,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Functions.\n\nLearn how to create and use stored procedures and functions for business logic encapsulation.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "-- Stored procedure with parameters\nDELIMITER //\nCREATE PROCEDURE GetUserOrders(\n  IN userId INT,\n  IN fromDate DATE,\n  OUT totalOrders INT,\n  OUT totalAmount DECIMAL(10,2)\n)\nBEGIN\n  DECLARE EXIT HANDLER FOR SQLEXCEPTION\n  BEGIN\n    ROLLBACK;\n    RESIGNAL;\n  END;\n  \n  START TRANSACTION;\n  \n  SELECT COUNT(*), COALESCE(SUM(total_amount), 0)\n  INTO totalOrders, totalAmount\n  FROM orders\n  WHERE user_id = userId AND order_date >= fromDate;\n  \n  COMMIT;\nEND //\nDELIMITER ;\n\n-- Call stored procedure\nCALL GetUserOrders(1, '2023-01-01', @orders, @amount);\nSELECT @orders, @amount;\n\n-- User-defined function\nDELIMITER //\nCREATE FUNCTION CalculateDiscount(\n  orderAmount DECIMAL(10,2),\n  customerType VARCHAR(20)\n) RETURNS DECIMAL(10,2)\nREADS SQL DATA\nDETERMINISTIC\nBEGIN\n  DECLARE discount DECIMAL(10,2) DEFAULT 0;\n  \n  CASE customerType\n    WHEN 'premium' THEN SET discount = orderAmount * 0.15;\n    WHEN 'gold' THEN SET discount = orderAmount * 0.10;\n    WHEN 'silver' THEN SET discount = orderAmount * 0.05;\n    ELSE SET discount = 0;\n  END CASE;\n  \n  RETURN discount;\nEND //\nDELIMITER ;\n\n-- Use function in query\nSELECT *, \n  CalculateDiscount(total_amount, customer_type) as discount\nFROM orders;",
                "explanation": "This example produces: Reusable stored procedures and functions for complex business logic\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "sql"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Stored Procedures and User-Defined Functions",
                  "description": "Apply the concepts from this lesson on Functions",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Functions",
                "database"
              ],
              "legacy": {
                "originalId": 8,
                "originalTopic": "Functions",
                "migrated": "2025-10-01T06:41:13.481Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.481Z",
              "version": "1.0.0"
            },
            {
              "id": "database-systems-lesson-9",
              "moduleSlug": "database-systems",
              "title": "Document Databases and MongoDB",
              "order": 9,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on NoSQL.\n\nLearn about NoSQL concepts and working with document databases like MongoDB.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "// MongoDB document structure\n// Users collection\n{\n  \"_id\": ObjectId(\"507f1f77bcf86cd799439011\"),\n  \"name\": \"John Doe\",\n  \"email\": \"john@example.com\",\n  \"profile\": {\n    \"age\": 30,\n    \"interests\": [\"programming\", \"music\", \"travel\"],\n    \"address\": {\n      \"street\": \"123 Main St\",\n      \"city\": \"New York\",\n      \"zipcode\": \"10001\"\n    }\n  },\n  \"createdAt\": ISODate(\"2023-01-15T10:30:00Z\")\n}\n\n// MongoDB queries\n// Find documents\ndb.users.find({ \"profile.age\": { $gte: 18 } })\n\n// Complex query with multiple conditions\ndb.users.find({\n  $and: [\n    { \"profile.age\": { $gte: 25 } },\n    { \"profile.interests\": \"programming\" }\n  ]\n})\n\n// Update document\ndb.users.updateOne(\n  { \"_id\": ObjectId(\"507f1f77bcf86cd799439011\") },\n  { \n    $set: { \"profile.age\": 31 },\n    $push: { \"profile.interests\": \"reading\" }\n  }\n)\n\n// Aggregation pipeline\ndb.users.aggregate([\n  { $match: { \"profile.age\": { $gte: 25 } } },\n  { $group: {\n    _id: \"$profile.address.city\",\n    count: { $sum: 1 },\n    avgAge: { $avg: \"$profile.age\" }\n  }},\n  { $sort: { count: -1 } }\n])\n\n// Create index\ndb.users.createIndex({ \"email\": 1 }, { unique: true })\ndb.users.createIndex({ \"profile.age\": 1, \"profile.interests\": 1 })",
                "explanation": "This example produces: Flexible document storage with nested data structures and powerful querying capabilities\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "sql"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Document Databases and MongoDB",
                  "description": "Apply the concepts from this lesson on NoSQL",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "NoSQL",
                "database"
              ],
              "legacy": {
                "originalId": 9,
                "originalTopic": "NoSQL",
                "migrated": "2025-10-01T06:41:13.481Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.481Z",
              "version": "1.0.0"
            },
            {
              "id": "database-systems-lesson-10",
              "moduleSlug": "database-systems",
              "title": "Database Backup and Recovery Strategies",
              "order": 10,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Backup.\n\nLearn essential backup and recovery techniques to protect data integrity and business continuity.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "-- Full database backup\nmysqldump -u root -p --all-databases > full_backup.sql\n\n-- Backup specific database with structure and data\nmysqldump -u root -p --databases myapp > myapp_backup.sql\n\n-- Backup only structure (schema)\nmysqldump -u root -p --no-data myapp > schema_backup.sql\n\n-- Backup only data\nmysqldump -u root -p --no-create-info myapp > data_backup.sql\n\n-- Point-in-time recovery setup\n-- Enable binary logging in my.cnf\nlog-bin=mysql-bin\nserver-id=1\nbinlog-format=ROW\n\n-- Create incremental backup\nmysqlbinlog mysql-bin.000001 > incremental_backup.sql\n\n-- Restore from backup\nmysql -u root -p < full_backup.sql\n\n-- Restore specific database\nmysql -u root -p myapp < myapp_backup.sql\n\n-- Automated backup script (bash)\n#!/bin/bash\nBACKUP_DIR=\"/var/backups/mysql\"\nDATE=$(date +%Y%m%d_%H%M%S)\nBACKUP_FILE=\"$BACKUP_DIR/backup_$DATE.sql\"\n\n# Create backup directory if it doesn't exist\nmkdir -p $BACKUP_DIR\n\n# Perform backup\nmysqldump -u backup_user -p$BACKUP_PASSWORD --all-databases > $BACKUP_FILE\n\n# Compress backup\ngzip $BACKUP_FILE\n\n# Remove backups older than 7 days\nfind $BACKUP_DIR -name \"*.gz\" -mtime +7 -delete\n\necho \"Backup completed: $BACKUP_FILE.gz\"",
                "explanation": "This example produces: Comprehensive backup solution with full, incremental, and automated backup strategies\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "sql"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Database Backup and Recovery Strategies",
                  "description": "Apply the concepts from this lesson on Backup",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Backup",
                "database"
              ],
              "legacy": {
                "originalId": 10,
                "originalTopic": "Backup",
                "migrated": "2025-10-01T06:41:13.481Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.481Z",
              "version": "1.0.0"
            },
            {
              "id": "database-systems-lesson-11",
              "moduleSlug": "database-systems",
              "title": "Database Security and Access Control",
              "order": 11,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Security.\n\nLearn database security best practices including user management, encryption, and SQL injection prevention.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "-- User management and privileges\n-- Create database user\nCREATE USER 'app_user'@'localhost' IDENTIFIED BY 'SecurePassword123!';\n\n-- Grant specific privileges\nGRANT SELECT, INSERT, UPDATE ON myapp.* TO 'app_user'@'localhost';\nGRANT EXECUTE ON PROCEDURE myapp.GetUserOrders TO 'app_user'@'localhost';\n\n-- Create read-only user\nCREATE USER 'readonly_user'@'%' IDENTIFIED BY 'ReadOnlyPass456!';\nGRANT SELECT ON myapp.* TO 'readonly_user'@'%';\n\n-- Revoke privileges\nREVOKE INSERT ON myapp.users FROM 'app_user'@'localhost';\n\n-- Show user privileges\nSHOW GRANTS FOR 'app_user'@'localhost';\n\n-- SQL injection prevention (parameterized queries)\n-- Vulnerable code (DON'T DO THIS)\n-- query = \"SELECT * FROM users WHERE id = \" + userId;\n\n-- Safe parameterized query (C#)\nstring query = \"SELECT * FROM users WHERE id = @userId\";\nusing var command = new MySqlCommand(query, connection);\ncommand.Parameters.AddWithValue(\"@userId\", userId);\n\n-- Data encryption\n-- Encrypt sensitive columns\nCREATE TABLE users (\n  id INT PRIMARY KEY AUTO_INCREMENT,\n  email VARCHAR(255),\n  ssn VARBINARY(255), -- Encrypted field\n  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n\n-- Insert encrypted data\nINSERT INTO users (email, ssn) \nVALUES ('user@example.com', AES_ENCRYPT('123-45-6789', 'encryption_key'));\n\n-- Retrieve and decrypt\nSELECT email, AES_DECRYPT(ssn, 'encryption_key') as ssn_decrypted \nFROM users WHERE id = 1;\n\n-- Connection security\n-- Require SSL connections\nREQUIRE SSL;\nREQUIRE X509;\n\n-- Password policy\nSET GLOBAL validate_password.policy = STRONG;\nSET GLOBAL validate_password.length = 12;",
                "explanation": "This example produces: Secure database configuration with proper user privileges, encryption, and injection prevention\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "sql"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Database Security and Access Control",
                  "description": "Apply the concepts from this lesson on Security",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Security",
                "database"
              ],
              "legacy": {
                "originalId": 11,
                "originalTopic": "Security",
                "migrated": "2025-10-01T06:41:13.481Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.481Z",
              "version": "1.0.0"
            },
            {
              "id": "database-systems-lesson-12",
              "moduleSlug": "database-systems",
              "title": "Database Scaling and Replication",
              "order": 12,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Advanced.\n\nLearn about database scaling techniques including replication, sharding, and distributed databases.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "-- Master-Slave Replication Setup\n-- Master configuration (my.cnf)\nserver-id = 1\nlog-bin = mysql-bin\nbinlog-do-db = myapp\n\n-- Slave configuration (my.cnf)\nserver-id = 2\nrelay-log = mysql-relay-bin\nlog-slave-updates = 1\nread-only = 1\n\n-- Create replication user on master\nCREATE USER 'replicator'@'%' IDENTIFIED BY 'ReplicationPass123!';\nGRANT REPLICATION SLAVE ON *.* TO 'replicator'@'%';\nFLUSH PRIVILEGES;\n\n-- Get master status\nSHOW MASTER STATUS;\n\n-- Configure slave\nCHANGE MASTER TO\n  MASTER_HOST='master_ip',\n  MASTER_USER='replicator',\n  MASTER_PASSWORD='ReplicationPass123!',\n  MASTER_LOG_FILE='mysql-bin.000001',\n  MASTER_LOG_POS=154;\n\nSTART SLAVE;\nSHOW SLAVE STATUS\\G\n\n-- Horizontal partitioning (sharding) example\n-- Shard 1: Users with ID 1-1000\nCREATE TABLE users_shard1 (\n  id INT PRIMARY KEY CHECK (id BETWEEN 1 AND 1000),\n  name VARCHAR(100),\n  email VARCHAR(100)\n);\n\n-- Shard 2: Users with ID 1001-2000\nCREATE TABLE users_shard2 (\n  id INT PRIMARY KEY CHECK (id BETWEEN 1001 AND 2000),\n  name VARCHAR(100),\n  email VARCHAR(100)\n);\n\n-- Application-level sharding logic (pseudo-code)\nfunction getUserShard(userId) {\n  if (userId <= 1000) return 'shard1';\n  if (userId <= 2000) return 'shard2';\n  return 'shard3';\n}\n\n-- Read replica load balancing\n-- Write operations go to master\nINSERT INTO users (name, email) VALUES ('John', 'john@example.com');\n\n-- Read operations can use replicas\nSELECT * FROM users WHERE id = 123; -- Can be routed to read replica\n\n-- Connection pooling configuration\nmax_connections = 200\nmax_connect_errors = 100\nconnect_timeout = 10\nwait_timeout = 28800",
                "explanation": "This example produces: Scalable database architecture with replication, sharding, and load balancing for high availability\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "sql"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Database Scaling and Replication",
                  "description": "Apply the concepts from this lesson on Advanced",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Advanced",
                "database"
              ],
              "legacy": {
                "originalId": 12,
                "originalTopic": "Advanced",
                "migrated": "2025-10-01T06:41:13.481Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.481Z",
              "version": "1.0.0"
            },
            {
              "id": "database-systems-lesson-13",
              "moduleSlug": "database-systems",
              "title": "Database Security and Access Control",
              "order": 13,
              "objectives": [
                "Implement database security best practices",
                "Configure user roles and permissions",
                "Understand SQL injection prevention"
              ],
              "intro": "Database security is critical for protecting sensitive data and ensuring compliance with regulations. Understanding security principles helps prevent data breaches and unauthorized access.\n\nIn this lesson, you'll learn about authentication, authorization, and access control mechanisms in database systems. You'll understand how to create secure user accounts, assign appropriate permissions, and implement the principle of least privilege.\n\nSQL injection is one of the most common security vulnerabilities. You'll discover how to prevent injection attacks through parameterized queries, input validation, and secure coding practices that protect against malicious attacks.\n\nData encryption, both at rest and in transit, provides additional security layers. You'll learn when and how to implement encryption strategies that protect sensitive information while maintaining acceptable performance levels.",
              "code": {
                "example": "-- Creating database users with limited privileges\nCREATE USER 'app_read'@'localhost' IDENTIFIED BY 'secure_password123';\nCREATE USER 'app_write'@'localhost' IDENTIFIED BY 'secure_password456';\nCREATE USER 'admin_user'@'localhost' IDENTIFIED BY 'admin_password789';\n\n-- Granting specific permissions\nGRANT SELECT ON myapp.* TO 'app_read'@'localhost';\nGRANT SELECT, INSERT, UPDATE ON myapp.users TO 'app_write'@'localhost';\nGRANT ALL PRIVILEGES ON myapp.* TO 'admin_user'@'localhost';\n\n-- SQL injection prevention with prepared statements\n-- BAD: Vulnerable to SQL injection\n-- query = \"SELECT * FROM users WHERE email = '\" + email + \"'\";\n\n-- GOOD: Using parameterized queries\nPREPARE stmt FROM 'SELECT * FROM users WHERE email = ? AND active = ?';\nSET @email = 'user@example.com';\nSET @active = 1;\nEXECUTE stmt USING @email, @active;\nDEALLOCATE PREPARE stmt;\n\n-- Creating encrypted columns\nCREATE TABLE sensitive_data (\n  id INT PRIMARY KEY AUTO_INCREMENT,\n  user_id INT NOT NULL,\n  encrypted_ssn VARBINARY(255),\n  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n  FOREIGN KEY (user_id) REFERENCES users(id)\n);\n\n-- Inserting encrypted data\nINSERT INTO sensitive_data (user_id, encrypted_ssn) \nVALUES (1, AES_ENCRYPT('123-45-6789', 'encryption_key'));\n\n-- Retrieving and decrypting data\nSELECT user_id, AES_DECRYPT(encrypted_ssn, 'encryption_key') as ssn \nFROM sensitive_data WHERE user_id = 1;",
                "explanation": "This example demonstrates database security implementation including user privilege management, SQL injection prevention through parameterized queries, and data encryption techniques.",
                "language": "sql"
              },
              "pitfalls": [
                {
                  "mistake": "Using string concatenation for SQL queries",
                  "solution": "Always use parameterized queries or prepared statements to prevent SQL injection",
                  "severity": "high"
                },
                {
                  "mistake": "Granting excessive privileges to application users",
                  "solution": "Follow principle of least privilege - grant only necessary permissions",
                  "severity": "high"
                },
                {
                  "mistake": "Storing sensitive data in plain text",
                  "solution": "Encrypt sensitive data and use secure key management practices",
                  "severity": "high"
                }
              ],
              "exercises": [
                {
                  "title": "Database Security Implementation",
                  "description": "Implement comprehensive security measures for a database application.",
                  "checkpoints": [
                    "Create appropriate user roles with limited privileges",
                    "Write secure queries using parameterized statements",
                    "Implement data encryption for sensitive fields",
                    "Audit and test security measures"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 35,
              "difficulty": "Advanced",
              "tags": [
                "Security",
                "Access Control",
                "SQL Injection"
              ],
              "lastUpdated": "2025-10-01T12:00:00.000Z",
              "version": "1.0.0"
            },
            {
              "id": "database-systems-lesson-14",
              "moduleSlug": "database-systems",
              "title": "Database Performance Tuning",
              "order": 14,
              "objectives": [
                "Analyze and optimize database performance",
                "Understand query execution plans",
                "Implement effective indexing strategies"
              ],
              "intro": "Database performance optimization is essential for applications that handle large datasets and high user loads. Understanding performance principles helps create responsive, scalable database systems.\n\nIn this lesson, you'll learn to analyze query execution plans to identify performance bottlenecks. Execution plans reveal how the database processes queries and help optimize slow-running operations through better indexing and query structure.\n\nIndexing strategies significantly impact database performance. You'll discover when to create indexes, how to design composite indexes effectively, and understand the trade-offs between query speed and write performance in different scenarios.\n\nQuery optimization techniques include proper join ordering, avoiding unnecessary subqueries, and leveraging database-specific features. You'll learn to rewrite queries for better performance while maintaining correctness and readability.",
              "code": {
                "example": "-- Analyzing query performance\nEXPLAIN SELECT u.first_name, u.last_name, COUNT(o.id) as order_count\nFROM users u\nLEFT JOIN orders o ON u.id = o.user_id\nWHERE u.created_at > '2024-01-01'\nGROUP BY u.id, u.first_name, u.last_name\nORDER BY order_count DESC\nLIMIT 10;\n\n-- Creating optimized indexes\n-- Composite index for common query patterns\nCREATE INDEX idx_user_created_active ON users(created_at, active);\nCREATE INDEX idx_order_user_date ON orders(user_id, order_date);\n\n-- Covering index (includes all needed columns)\nCREATE INDEX idx_user_covering ON users(id, first_name, last_name, email);\n\n-- Performance optimization techniques\n-- Use EXISTS instead of IN for large subqueries\nSELECT first_name, last_name FROM users u\nWHERE EXISTS (\n  SELECT 1 FROM orders o \n  WHERE o.user_id = u.id AND o.total_amount > 1000\n);\n\n-- Optimize with LIMIT to avoid scanning entire table\nSELECT * FROM products \nWHERE category_id = 5 \nORDER BY created_at DESC \nLIMIT 20;\n\n-- Use proper data types to save space and improve performance\nALTER TABLE products \nMODIFY COLUMN active BOOLEAN DEFAULT TRUE,\nMODIFY COLUMN price DECIMAL(8,2);\n\n-- Partitioning for large tables\nCREATE TABLE orders_2024 (\n  order_id INT AUTO_INCREMENT,\n  user_id INT NOT NULL,\n  order_date DATE NOT NULL,\n  total_amount DECIMAL(10,2),\n  PRIMARY KEY (order_id, order_date)\n) PARTITION BY RANGE (YEAR(order_date)) (\n  PARTITION p2024 VALUES LESS THAN (2025),\n  PARTITION p2025 VALUES LESS THAN (2026)\n);",
                "explanation": "This example demonstrates performance optimization techniques including execution plan analysis, strategic indexing, query optimization, and table partitioning for large datasets.",
                "language": "sql"
              },
              "pitfalls": [
                {
                  "mistake": "Creating too many indexes on frequently updated tables",
                  "solution": "Balance read performance with write performance - avoid excessive indexing",
                  "severity": "medium"
                },
                {
                  "mistake": "Not analyzing execution plans before optimization",
                  "solution": "Always use EXPLAIN to understand query performance before making changes",
                  "severity": "high"
                },
                {
                  "mistake": "Optimizing for edge cases instead of common queries",
                  "solution": "Focus optimization efforts on frequently executed queries with real performance impact",
                  "severity": "medium"
                }
              ],
              "exercises": [
                {
                  "title": "Database Performance Analysis",
                  "description": "Analyze and optimize a slow-performing database application.",
                  "checkpoints": [
                    "Identify slow queries using execution plans",
                    "Create appropriate indexes to improve performance",
                    "Optimize query structure and joins",
                    "Measure and validate performance improvements"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 40,
              "difficulty": "Advanced",
              "tags": [
                "Performance",
                "Optimization",
                "Indexing"
              ],
              "lastUpdated": "2025-10-01T12:00:00.000Z",
              "version": "1.0.0"
            },
            {
              "id": "database-systems-lesson-15",
              "moduleSlug": "database-systems",
              "title": "NoSQL Databases and Document Stores",
              "order": 15,
              "objectives": [
                "Understand NoSQL database types and use cases",
                "Work with document databases like MongoDB",
                "Compare SQL vs NoSQL trade-offs"
              ],
              "intro": "NoSQL databases provide flexible, scalable alternatives to traditional relational databases for specific use cases. Understanding NoSQL principles helps choose the right database technology for different applications.\n\nDocument databases like MongoDB store data in flexible, JSON-like documents rather than rigid table structures. This approach works well for applications with evolving schemas, hierarchical data, or rapid development cycles requiring frequent changes.\n\nNoSQL databases excel at horizontal scaling, handling large volumes of unstructured data, and providing high availability through distributed architectures. You'll learn when these advantages outweigh the consistency guarantees of traditional SQL databases.\n\nCAP theorem explains the trade-offs between Consistency, Availability, and Partition tolerance in distributed systems. Understanding these concepts helps make informed decisions about database architecture for different application requirements.",
              "code": {
                "example": "// MongoDB document structure\n// Users collection with embedded documents\n{\n  \"_id\": ObjectId(\"507f1f77bcf86cd799439011\"),\n  \"firstName\": \"John\",\n  \"lastName\": \"Doe\",\n  \"email\": \"john@example.com\",\n  \"profile\": {\n    \"bio\": \"Software developer\",\n    \"website\": \"https://johndoe.com\",\n    \"location\": \"San Francisco, CA\"\n  },\n  \"orders\": [\n    {\n      \"orderId\": \"ORD-001\",\n      \"date\": ISODate(\"2024-01-15\"),\n      \"total\": 299.99,\n      \"items\": [\n        { \"productId\": \"PROD-123\", \"name\": \"Laptop\", \"price\": 299.99 }\n      ]\n    }\n  ],\n  \"preferences\": {\n    \"newsletter\": true,\n    \"notifications\": {\n      \"email\": true,\n      \"sms\": false\n    }\n  },\n  \"createdAt\": ISODate(\"2024-01-01\"),\n  \"updatedAt\": ISODate(\"2024-01-15\")\n}\n\n// MongoDB queries\n// Find users with orders over $200\ndb.users.find({\n  \"orders.total\": { $gt: 200 }\n});\n\n// Update nested document\ndb.users.updateOne(\n  { \"email\": \"john@example.com\" },\n  { \n    $set: { \n      \"profile.bio\": \"Senior Software Developer\",\n      \"updatedAt\": new Date()\n    }\n  }\n);\n\n// Aggregation pipeline\ndb.users.aggregate([\n  { $unwind: \"$orders\" },\n  { $group: {\n    _id: null,\n    totalRevenue: { $sum: \"$orders.total\" },\n    averageOrder: { $avg: \"$orders.total\" },\n    orderCount: { $sum: 1 }\n  }}\n]);\n\n// Creating indexes in MongoDB\ndb.users.createIndex({ \"email\": 1 }, { unique: true });\ndb.users.createIndex({ \"orders.date\": -1 });\ndb.users.createIndex({ \"profile.location\": 1, \"createdAt\": -1 });",
                "explanation": "This example demonstrates MongoDB document structure with embedded data, complex queries using MongoDB syntax, and aggregation operations for data analysis.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Over-embedding documents without considering query patterns",
                  "solution": "Design document structure based on how data will be accessed and updated",
                  "severity": "medium"
                },
                {
                  "mistake": "Ignoring eventual consistency implications",
                  "solution": "Understand consistency models and design application logic accordingly",
                  "severity": "high"
                },
                {
                  "mistake": "Not planning for data growth and scaling",
                  "solution": "Consider sharding strategies and data distribution from the beginning",
                  "severity": "medium"
                }
              ],
              "exercises": [
                {
                  "title": "NoSQL Database Design",
                  "description": "Design and implement a document-based data model for a real-world application.",
                  "checkpoints": [
                    "Choose appropriate document structure for the use case",
                    "Implement queries for common access patterns",
                    "Create indexes to optimize performance",
                    "Compare with equivalent relational design"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 35,
              "difficulty": "Intermediate",
              "tags": [
                "NoSQL",
                "MongoDB",
                "Document Database"
              ],
              "lastUpdated": "2025-10-01T12:00:00.000Z",
              "version": "1.0.0"
            },
            {
              "id": "database-systems-lesson-16",
              "moduleSlug": "database-systems",
              "title": "Database Administration and Monitoring",
              "order": 16,
              "objectives": [
                "Understand database administration responsibilities",
                "Implement backup and recovery strategies",
                "Monitor database health and performance"
              ],
              "intro": "Database administration ensures reliable, secure, and performant database systems in production environments. Understanding DBA responsibilities helps maintain data integrity and system availability.\n\nBackup and recovery strategies protect against data loss from hardware failures, human errors, or security incidents. You'll learn different backup types, recovery procedures, and how to test disaster recovery plans effectively.\n\nDatabase monitoring provides visibility into system health, performance trends, and potential issues before they impact users. Effective monitoring includes tracking key metrics, setting up alerts, and analyzing logs for troubleshooting.\n\nMaintenance tasks like index optimization, statistics updates, and capacity planning ensure continued database performance. You'll understand how to schedule and automate routine maintenance while minimizing disruption to applications.",
              "code": {
                "example": "-- Database backup strategies\n-- Full backup (complete database)\nBACKUP DATABASE myapp TO DISK = '/backups/myapp_full_20241001.bak'\nWITH FORMAT, COMPRESSION;\n\n-- Differential backup (changes since last full backup)\nBACKUP DATABASE myapp TO DISK = '/backups/myapp_diff_20241001.bak'\nWITH DIFFERENTIAL, COMPRESSION;\n\n-- Transaction log backup (for point-in-time recovery)\nBACKUP LOG myapp TO DISK = '/backups/myapp_log_20241001.trn';\n\n-- Database restoration\nRESTORE DATABASE myapp FROM DISK = '/backups/myapp_full_20241001.bak'\nWITH NORECOVERY;\nRESTORE DATABASE myapp FROM DISK = '/backups/myapp_diff_20241001.bak'\nWITH RECOVERY;\n\n-- Performance monitoring queries\n-- Check database size and growth\nSELECT \n  table_schema as 'Database',\n  table_name as 'Table',\n  ROUND(((data_length + index_length) / 1024 / 1024), 2) as 'Size (MB)'\nFROM information_schema.tables\nORDER BY (data_length + index_length) DESC;\n\n-- Monitor slow queries\nSELECT \n  query_time,\n  lock_time,\n  rows_sent,\n  rows_examined,\n  sql_text\nFROM mysql.slow_log\nWHERE start_time > DATE_SUB(NOW(), INTERVAL 1 HOUR)\nORDER BY query_time DESC;\n\n-- Check index usage\nSELECT \n  object_name,\n  index_name,\n  user_seeks,\n  user_scans,\n  user_lookups,\n  user_updates\nFROM sys.dm_db_index_usage_stats\nWHERE database_id = DB_ID('myapp');\n\n-- Database maintenance\n-- Update table statistics\nUPDATE STATISTICS users;\nUPDATE STATISTICS orders;\n\n-- Rebuild fragmented indexes\nALTER INDEX ALL ON users REBUILD;\n\n-- Check database integrity\nDBCC CHECKDB('myapp') WITH NO_INFOMSGS;",
                "explanation": "This example demonstrates database administration tasks including backup/recovery procedures, performance monitoring queries, and routine maintenance operations.",
                "language": "sql"
              },
              "pitfalls": [
                {
                  "mistake": "Not testing backup and recovery procedures regularly",
                  "solution": "Regularly test restore procedures to ensure backups are valid and recovery works",
                  "severity": "high"
                },
                {
                  "mistake": "Ignoring database growth and capacity planning",
                  "solution": "Monitor database growth trends and plan for capacity needs proactively",
                  "severity": "medium"
                },
                {
                  "mistake": "Not monitoring database performance metrics",
                  "solution": "Implement comprehensive monitoring with alerts for key performance indicators",
                  "severity": "high"
                }
              ],
              "exercises": [
                {
                  "title": "Database Administration Setup",
                  "description": "Implement comprehensive database administration procedures.",
                  "checkpoints": [
                    "Create automated backup schedule with full and incremental backups",
                    "Test database recovery procedures",
                    "Set up monitoring for key performance metrics",
                    "Create maintenance plan for routine database tasks"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 45,
              "difficulty": "Advanced",
              "tags": [
                "Administration",
                "Backup",
                "Monitoring"
              ],
              "lastUpdated": "2025-10-01T12:00:00.000Z",
              "version": "1.0.0"
            }
          ],
          "issues": []
        },
        "quiz": {
          "exists": true,
          "count": 22,
          "questions": [
            {
              "id": "database-systems-q1",
              "question": "What is a primary key in a relational database?",
              "topic": "Database Fundamentals",
              "difficulty": "Beginner",
              "choices": [
                "A unique identifier for each row in a table",
                "A key used to encrypt database records",
                "The first column in a table",
                "A key used for sorting records"
              ],
              "correctIndex": 0,
              "explanation": "A primary key is a column or set of columns that uniquely identifies each row in a table. It must contain unique values and cannot contain NULL values. Primary keys are essential for entity integrity and are used to establish relationships between tables.",
              "industryContext": "Database skills are fundamental for any backend developer role.",
              "tags": [
                "Database Fundamentals",
                "beginner",
                "database"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 1,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.482Z"
              }
            },
            {
              "id": "database-systems-q2",
              "question": "Which normal form eliminates transitive dependencies?",
              "topic": "Database Fundamentals",
              "difficulty": "Intermediate",
              "choices": [
                "Third Normal Form (3NF)",
                "First Normal Form (1NF)",
                "Second Normal Form (2NF)",
                "Boyce-Codd Normal Form (BCNF)"
              ],
              "correctIndex": 0,
              "explanation": "Third Normal Form (3NF) eliminates transitive dependencies, where non-key attributes depend on other non-key attributes. A table is in 3NF if it is in 2NF and all non-key attributes are functionally dependent only on the primary key.",
              "industryContext": "Database skills are fundamental for any backend developer role.",
              "tags": [
                "Database Fundamentals",
                "intermediate",
                "database"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 2,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.482Z"
              }
            },
            {
              "id": "database-systems-q3",
              "question": "What is the difference between INNER JOIN and LEFT JOIN? When would you use each?",
              "topic": "SQL",
              "difficulty": "Beginner",
              "choices": [
                "Open-ended question - no multiple choice",
                "This is a conceptual question",
                "Answer requires explanation",
                "Multiple approaches possible"
              ],
              "correctIndex": 0,
              "explanation": "INNER JOIN returns only rows that have matching values in both tables. LEFT JOIN returns all rows from the left table and matching rows from the right table. If there's no match, NULL values are returned for columns from the right table. Use INNER JOIN when you only want records that exist in both tables, and LEFT JOIN when you want all records from the first table regardless of whether they have matches in the second table.",
              "industryContext": "Database skills are fundamental for any backend developer role.",
              "tags": [
                "SQL",
                "beginner",
                "database"
              ],
              "questionType": "open-ended",
              "estimatedTime": 180,
              "legacy": {
                "originalId": 3,
                "originalType": "open-ended",
                "migrated": "2025-10-01T06:41:13.482Z"
              }
            },
            {
              "id": "database-systems-q4",
              "question": "What does an ER diagram represent?",
              "topic": "Data Modeling",
              "difficulty": "Intermediate",
              "choices": [
                "Entities, relationships, and attributes in a database",
                "Error reports in a database system",
                "Execution plans for database queries",
                "Encryption rules for database security"
              ],
              "correctIndex": 0,
              "explanation": "An Entity-Relationship (ER) diagram is a visual representation of data that describes how entities relate to each other within a database. It shows entities (tables), attributes (columns), and relationships (foreign keys) between entities, helping to design and understand database structure.",
              "industryContext": "Database skills are fundamental for any backend developer role.",
              "tags": [
                "Data Modeling",
                "intermediate",
                "database"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 4,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.482Z"
              }
            },
            {
              "id": "database-systems-q5",
              "question": "What is the purpose of a DbContext in Entity Framework Core?",
              "topic": "ORM Integration",
              "difficulty": "Beginner",
              "choices": [
                "To act as a bridge between the domain and the database",
                "To encrypt database connections",
                "To manage user authentication",
                "To optimize SQL queries"
              ],
              "correctIndex": 0,
              "explanation": "DbContext in Entity Framework Core acts as a bridge between your domain or entity classes and the database. It's responsible for database connections, querying, change tracking, and saving changes. It provides LINQ-to-Entities queries and manages the unit of work pattern.",
              "industryContext": "Database skills are fundamental for any backend developer role.",
              "tags": [
                "ORM Integration",
                "beginner",
                "database"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 5,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.482Z"
              }
            },
            {
              "id": "database-systems-q6",
              "question": "What is the N+1 query problem and how can it be avoided?",
              "topic": "Performance",
              "difficulty": "Beginner",
              "choices": [
                "Executing one query to get parent records and N queries to get related data for each parent; use eager loading",
                "A syntax error in SQL queries",
                "A problem with database indexing",
                "A network connectivity issue"
              ],
              "correctIndex": 0,
              "explanation": "The N+1 query problem occurs when you execute one query to get a set of parent records and then N additional queries to get related data for each parent record. This can be avoided by using eager loading (JOINs) to fetch all needed data in a single query, or by using techniques like batch loading.",
              "industryContext": "Database skills are fundamental for any backend developer role.",
              "tags": [
                "Performance",
                "beginner",
                "database"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 6,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.482Z"
              }
            },
            {
              "id": "database-systems-q7",
              "question": "Explain ACID properties in database transactions.",
              "topic": "Transactions",
              "difficulty": "Intermediate",
              "choices": [
                "Open-ended question - no multiple choice",
                "This is a conceptual question",
                "Answer requires explanation",
                "Multiple approaches possible"
              ],
              "correctIndex": 0,
              "explanation": "ACID stands for Atomicity, Consistency, Isolation, and Durability. Atomicity ensures transactions are all-or-nothing. Consistency ensures transactions bring the database from one valid state to another. Isolation ensures concurrent transactions don't interfere with each other. Durability ensures committed transactions are permanently recorded even in system failures.",
              "industryContext": "Database skills are fundamental for any backend developer role.",
              "tags": [
                "Transactions",
                "intermediate",
                "database"
              ],
              "questionType": "open-ended",
              "estimatedTime": 180,
              "legacy": {
                "originalId": 7,
                "originalType": "open-ended",
                "migrated": "2025-10-01T06:41:13.482Z"
              }
            },
            {
              "id": "database-systems-q8",
              "question": "When should you consider adding an index to a database column?",
              "topic": "Indexing",
              "difficulty": "Intermediate",
              "choices": [
                "When the column is frequently used in WHERE clauses, JOINs, or ORDER BY clauses",
                "When the column contains large text data",
                "When the table has fewer than 100 rows",
                "When the column is updated frequently"
              ],
              "correctIndex": 0,
              "explanation": "Indexes should be added to columns that are frequently used in WHERE clauses, JOIN conditions, or ORDER BY clauses as they significantly improve query performance. However, indexes come with overhead for INSERT, UPDATE, and DELETE operations, so they should be used judiciously.",
              "industryContext": "Database skills are fundamental for any backend developer role.",
              "tags": [
                "Indexing",
                "intermediate",
                "database"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 8,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.482Z"
              }
            },
            {
              "id": "database-systems-q9",
              "question": "What is the main advantage of document databases like MongoDB over relational databases?",
              "topic": "NoSQL",
              "difficulty": "Beginner",
              "choices": [
                "Schema flexibility and ability to store nested data structures",
                "Better performance for all types of queries",
                "Stronger consistency guarantees",
                "Better support for complex transactions"
              ],
              "correctIndex": 0,
              "explanation": "Document databases like MongoDB offer schema flexibility, allowing you to store varied document structures without predefined schemas. They excel at storing nested, hierarchical data and can evolve the data model without complex migrations, making them suitable for agile development and varied data structures.",
              "industryContext": "Database skills are fundamental for any backend developer role.",
              "tags": [
                "NoSQL",
                "beginner",
                "database"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 9,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.482Z"
              }
            },
            {
              "id": "database-systems-q10",
              "question": "Which technique is most effective for preventing SQL injection attacks?",
              "topic": "Security",
              "difficulty": "Intermediate",
              "choices": [
                "Using parameterized queries or prepared statements",
                "Validating input length only",
                "Using stored procedures exclusively",
                "Encrypting all database data"
              ],
              "correctIndex": 0,
              "explanation": "Parameterized queries (prepared statements) are the most effective defense against SQL injection. They separate SQL code from data, ensuring user input is treated as data rather than executable code. This prevents malicious SQL code from being executed regardless of what users input.",
              "industryContext": "Database skills are fundamental for any backend developer role.",
              "tags": [
                "Security",
                "intermediate",
                "database"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 10,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.482Z"
              }
            },
            {
              "id": "database-systems-q11",
              "question": "What is the difference between full, incremental, and differential backups? When would you use each?",
              "topic": "Backup and Recovery",
              "difficulty": "Beginner",
              "choices": [
                "Open-ended question - no multiple choice",
                "This is a conceptual question",
                "Answer requires explanation",
                "Multiple approaches possible"
              ],
              "correctIndex": 0,
              "explanation": "Full backup copies all data and provides complete restore capability but takes longest time and space. Incremental backup copies only changes since last backup (any type), fastest but requires all incremental backups for restore. Differential backup copies changes since last full backup, moderate time but only needs full + latest differential for restore. Use full for weekly/monthly, incremental for daily frequent backups, differential for balanced approach.",
              "industryContext": "Database skills are fundamental for any backend developer role.",
              "tags": [
                "Backup and Recovery",
                "beginner",
                "database"
              ],
              "questionType": "open-ended",
              "estimatedTime": 180,
              "legacy": {
                "originalId": 11,
                "originalType": "open-ended",
                "migrated": "2025-10-01T06:41:13.482Z"
              }
            },
            {
              "id": "database-systems-q12",
              "question": "What is database sharding?",
              "topic": "Performance",
              "difficulty": "Beginner",
              "choices": [
                "Horizontally partitioning data across multiple servers",
                "Creating backup copies of the database",
                "Optimizing database queries",
                "Compressing database files"
              ],
              "correctIndex": 0,
              "explanation": "Database sharding is a horizontal partitioning technique where data is distributed across multiple database servers (shards). Each shard contains a subset of the data based on a sharding key. This improves performance and scalability by distributing load across multiple servers, though it adds complexity to queries and transactions.",
              "industryContext": "Database skills are fundamental for any backend developer role.",
              "tags": [
                "Performance",
                "beginner",
                "database"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 12,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.482Z"
              }
            },
            {
              "id": "database-systems-q13",
              "question": "In master-slave database replication, what is the primary purpose of read replicas?",
              "topic": "Replication",
              "difficulty": "Beginner",
              "choices": [
                "To distribute read queries and improve performance",
                "To provide backup storage only",
                "To handle all write operations",
                "To encrypt database traffic"
              ],
              "correctIndex": 0,
              "explanation": "Read replicas in master-slave replication are designed to handle read queries, distributing the read workload away from the master database. This improves overall system performance by allowing the master to focus on write operations while replicas handle reads. Read replicas also provide geographic distribution and can serve as backup for disaster recovery.",
              "industryContext": "Database skills are fundamental for any backend developer role.",
              "tags": [
                "Replication",
                "beginner",
                "database"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 13,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.482Z"
              }
            },
            {
              "id": "database-systems-q14",
              "question": "What are CHECK constraints and provide an example of when you would use them?",
              "topic": "Constraints",
              "difficulty": "Intermediate",
              "choices": [
                "Open-ended question - no multiple choice",
                "This is a conceptual question",
                "Answer requires explanation",
                "Multiple approaches possible"
              ],
              "correctIndex": 0,
              "explanation": "CHECK constraints enforce domain integrity by limiting the values that can be placed in a column. They define a condition that each row must satisfy. Example: a CHECK constraint on an age column to ensure values are between 0 and 150 (age >= 0 AND age <= 150), or on a status column to only allow specific values like 'active', 'inactive', 'pending'. They help maintain data quality at the database level.",
              "industryContext": "Database skills are fundamental for any backend developer role.",
              "tags": [
                "Constraints",
                "intermediate",
                "database"
              ],
              "questionType": "open-ended",
              "estimatedTime": 180,
              "legacy": {
                "originalId": 14,
                "originalType": "open-ended",
                "migrated": "2025-10-01T06:41:13.482Z"
              }
            },
            {
              "id": "database-systems-q15",
              "question": "What is the CAP theorem in distributed databases?",
              "topic": "Advanced Topics",
              "difficulty": "Beginner",
              "choices": [
                "You can only guarantee two of: Consistency, Availability, and Partition tolerance",
                "All distributed systems must have Consistency, Availability, and Performance",
                "Databases must choose between Cost, Accuracy, and Performance",
                "Systems need Caching, APIs, and Partitioning"
              ],
              "correctIndex": 0,
              "explanation": "The CAP theorem states that in a distributed database system, you can only guarantee two out of three properties: Consistency (all nodes see the same data simultaneously), Availability (system remains operational), and Partition tolerance (system continues despite network failures). This fundamental limitation guides the design of distributed databases and helps understand trade-offs in system architecture.",
              "industryContext": "Database skills are fundamental for any backend developer role.",
              "tags": [
                "Advanced Topics",
                "beginner",
                "database"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 15,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.482Z"
              }
            },
            {
              "id": "database-systems-q16",
              "question": "Which SQL statement would prevent SQL injection in this scenario: user input for email search?",
              "topic": "Security",
              "difficulty": "Intermediate",
              "choices": [
                "SELECT * FROM users WHERE email = ?",
                "SELECT * FROM users WHERE email = 'UNSAFE' + userInput + 'UNSAFE'",
                "SELECT * FROM users WHERE email = UNSAFE + userInput",
                "SELECT * FROM users WHERE email LIKE userInput"
              ],
              "correctIndex": 0,
              "explanation": "Using parameterized queries with placeholders (?) prevents SQL injection by separating SQL code from user data. The database treats user input as data only, not executable code. Options B and C use string concatenation which allows malicious SQL to be injected, while option D has syntax errors.",
              "industryContext": "SQL injection is one of the top security vulnerabilities. Preventing it is critical for protecting user data and system integrity.",
              "tags": [
                "Security",
                "SQL Injection",
                "intermediate"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 120
            },
            {
              "id": "database-systems-q17",
              "question": "What is the main advantage of using a covering index?",
              "topic": "Performance",
              "difficulty": "Advanced",
              "choices": [
                "The query can be satisfied entirely from the index without accessing the table",
                "It covers all tables in the database",
                "It automatically creates indexes on all columns",
                "It provides backup coverage for data"
              ],
              "correctIndex": 0,
              "explanation": "A covering index includes all columns needed by a query, allowing the database to satisfy the query entirely from the index without accessing the underlying table data. This dramatically improves performance by reducing I/O operations and memory usage.",
              "industryContext": "Covering indexes are a advanced performance optimization technique used in high-traffic applications to minimize database I/O.",
              "tags": [
                "Performance",
                "Indexing",
                "advanced"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 120
            },
            {
              "id": "database-systems-q18",
              "question": "In MongoDB, what does the $unwind operator do in an aggregation pipeline?",
              "topic": "NoSQL",
              "difficulty": "Intermediate",
              "choices": [
                "Separates array elements into individual documents",
                "Combines multiple documents into one",
                "Sorts documents in reverse order",
                "Removes duplicate values from arrays"
              ],
              "correctIndex": 0,
              "explanation": "The $unwind operator in MongoDB takes an array field and creates a separate document for each array element. For example, if a document has an array with 3 elements, $unwind creates 3 documents, each containing one array element. This is useful for analyzing array data in aggregation pipelines.",
              "industryContext": "MongoDB aggregation pipelines are essential for data analysis and reporting in NoSQL applications.",
              "tags": [
                "NoSQL",
                "MongoDB",
                "intermediate"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 120
            },
            {
              "id": "database-systems-q19",
              "question": "What is database normalization and why is it important?",
              "topic": "Design",
              "difficulty": "Beginner",
              "choices": [
                "Process of organizing data to reduce redundancy and improve integrity",
                "Making all column names the same format",
                "Converting all data to the same data type",
                "Ensuring all tables have the same number of columns"
              ],
              "correctIndex": 0,
              "explanation": "Database normalization is the process of organizing data in a database to reduce redundancy and improve data integrity. It involves dividing large tables into smaller ones and defining relationships between them. This prevents data anomalies, saves storage space, and makes updates more efficient by ensuring data is stored in only one place.",
              "industryContext": "Proper database design through normalization is fundamental to creating maintainable, efficient database systems.",
              "tags": [
                "Design",
                "Normalization",
                "beginner"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90
            },
            {
              "id": "database-systems-q20",
              "question": "Which backup strategy provides the fastest recovery time but uses the most storage space?",
              "topic": "Administration",
              "difficulty": "Intermediate",
              "choices": [
                "Full backup every day",
                "Full backup weekly with daily incremental backups",
                "Full backup monthly with daily differential backups",
                "Transaction log backups only"
              ],
              "correctIndex": 0,
              "explanation": "Daily full backups provide the fastest recovery time because you only need to restore one backup file. However, they use the most storage space since they backup all data every day. Other strategies save space but require restoring multiple backup files, increasing recovery time.",
              "industryContext": "Backup strategy decisions involve balancing recovery time objectives (RTO) with storage costs and backup windows.",
              "tags": [
                "Administration",
                "Backup",
                "intermediate"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 120
            },
            {
              "id": "database-systems-q21",
              "question": "What happens when you execute this query: SELECT * FROM users WHERE user_id = NULL?",
              "topic": "SQL",
              "difficulty": "Beginner",
              "choices": [
                "Returns no rows because NULL comparisons require IS NULL",
                "Returns all rows where user_id is NULL",
                "Returns all rows in the table",
                "Throws a syntax error"
              ],
              "correctIndex": 0,
              "explanation": "The query returns no rows because NULL cannot be compared using = operator. In SQL, NULL represents unknown/missing data and requires special operators. To find NULL values, use 'WHERE user_id IS NULL'. To find non-NULL values, use 'WHERE user_id IS NOT NULL'.",
              "industryContext": "Understanding NULL handling is crucial for writing correct SQL queries and avoiding common bugs in data retrieval.",
              "tags": [
                "SQL",
                "NULL",
                "beginner"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90
            },
            {
              "id": "database-systems-q22",
              "question": "In a many-to-many relationship, why do you need a junction table?",
              "topic": "Design",
              "difficulty": "Intermediate",
              "choices": [
                "To avoid storing duplicate data and maintain referential integrity",
                "To make queries run faster",
                "To reduce the number of indexes needed",
                "To comply with database licensing requirements"
              ],
              "correctIndex": 0,
              "explanation": "A junction table (bridge/linking table) is needed in many-to-many relationships to avoid data duplication and maintain referential integrity. Without it, you'd have to store duplicate data in one of the tables or violate normalization rules. The junction table contains foreign keys to both related tables, creating a clean many-to-many relationship.",
              "industryContext": "Many-to-many relationships are common in real applications (users-roles, products-categories, students-courses) and proper modeling is essential.",
              "tags": [
                "Design",
                "Relationships",
                "intermediate"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 120
            }
          ],
          "issues": []
        },
        "meetsThresholds": true,
        "issues": []
      },
      "typescript-fundamentals": {
        "slug": "typescript-fundamentals",
        "title": "TypeScript Development",
        "tier": "core",
        "track": "Frontend",
        "difficulty": "Intermediate",
        "thresholds": {
          "requiredLessons": 14,
          "requiredQuestions": 18
        },
        "lessons": {
          "exists": true,
          "count": 14,
          "lessons": [
            {
              "id": "typescript-fundamentals-lesson-1",
              "moduleSlug": "typescript-fundamentals",
              "title": "Primitive Types and Type Annotations",
              "order": 1,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Basic Types.\n\nLearn about TypeScript's primitive types including string, number, and boolean, along with advanced types like any, unknown, and never.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "// Primitive types with explicit annotations\nlet isDone: boolean = false\nlet decimal: number = 6\nlet hex: number = 0xf00d\nlet binary: number = 0b1010\nlet octal: number = 0o744\nlet color: string = \"blue\"\n\ncolor = 'red'  // Still valid\n\nlet fullName: string = `Bob Bobbington`\nlet sentence: string = `Hello, my name is ${fullName}`\n\n// Special types\nlet notSure: any = 4  // Can be anything (avoid when possible)\nnotSure = \"maybe a string instead\"\nnotSure = false\n\nlet uncertain: unknown = 4  // Safer than any\n// uncertain.toFixed(); // Error: Object is of type 'unknown'\nif (typeof uncertain === 'number') {\n  uncertain.toFixed()  // OK\n}\n\nfunction fail(): never {\n  throw new Error(\"Something failed\")\n}",
                "explanation": "This example produces: Variables with explicit type annotations for various primitive types, demonstrating the difference between any and unknown\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "typescript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Primitive Types and Type Annotations",
                  "description": "Apply the concepts from this lesson on Basic Types",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Advanced",
              "tags": [
                "Basic Types",
                "typescript"
              ],
              "legacy": {
                "originalId": 1,
                "originalTopic": "Basic Types",
                "migrated": "2025-10-01T06:41:13.482Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.482Z",
              "version": "1.0.0"
            },
            {
              "id": "typescript-fundamentals-lesson-2",
              "moduleSlug": "typescript-fundamentals",
              "title": "Arrays, Tuples, and Enums",
              "order": 2,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Basic Types.\n\nLearn how to work with arrays, tuples, and enums in TypeScript for more precise type safety.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "// Arrays\nlet list: number[] = [1, 2, 3]\nlet list2: Array<number> = [1, 2, 3]\n\n// Tuples - fixed-length arrays with known types\nlet x: [string, number]\nx = ['hello', 10]  // OK\n// x = [10, 'hello']  // Error\n\nconsole.log(x[0].substring(1))  // OK\n// console.log(x[1].substring(1))  // Error, 'number' does not have 'substring'\n\nx[3] = 'world'  // OK, 'string' can be assigned to (string | number)\nx[5] = 100  // OK, 'number' can be assigned to (string | number)\n// x[6] = true  // Error, 'boolean' isn't (string | number)\n\n// Enums\nenum Color { Red, Green, Blue }\nlet c: Color = Color.Green\n\nenum Color2 { Red = 1, Green, Blue }\nlet c2: Color2 = Color2.Green\n\nenum Color3 { Red = 1, Green = 2, Blue = 4 }\nlet c3: Color3 = Color3.Green\n\n// String enums\nenum Direction {\n  Up = \"UP\",\n  Down = \"DOWN\",\n  Left = \"LEFT\",\n  Right = \"RIGHT\",\n}",
                "explanation": "This example produces: Type-safe arrays, tuples with fixed types, and enums for named constants\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "typescript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Arrays, Tuples, and Enums",
                  "description": "Apply the concepts from this lesson on Basic Types",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Basic Types",
                "typescript"
              ],
              "legacy": {
                "originalId": 2,
                "originalTopic": "Basic Types",
                "migrated": "2025-10-01T06:41:13.482Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.482Z",
              "version": "1.0.0"
            },
            {
              "id": "typescript-fundamentals-lesson-3",
              "moduleSlug": "typescript-fundamentals",
              "title": "Interface Declaration and Extension",
              "order": 3,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Interfaces.\n\nLearn how to define interfaces to describe the shape of objects, including optional properties, readonly properties, and extending interfaces.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "// Basic interface\ninterface Person {\n  firstName: string\n  lastName: string\n  age?: number  // Optional property\n  readonly ssn: string  // Readonly property\n}\n\nfunction greeter(person: Person) {\n  // person.ssn = \"123-45-6789\"  // Error! Cannot assign to 'ssn'\n  return `Hello, ${person.firstName} ${person.lastName}${person.age ? `, age ${person.age}` : ''}`\n}\n\nlet user = { firstName: \"Jane\", lastName: \"User\", ssn: \"123-45-6789\", age: 25 }\n\ngreeter(user)\n\n// Extending interfaces\ninterface Shape {\n  color: string\n}\n\ninterface Square extends Shape {\n  sideLength: number\n}\n\nlet square = <Square>{ color: \"blue\", sideLength: 10 }\n\n// Multiple inheritance\ninterface PenStroke {\n  penWidth: number\n}\n\ninterface Square2 extends Shape, PenStroke {\n  sideLength: number\n}\n\nlet square2 = <Square2>{ color: \"blue\", sideLength: 10, penWidth: 5.0 }",
                "explanation": "This example produces: Type-safe object manipulation with interfaces, showing optional and readonly properties, and interface extension\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "typescript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Interface Declaration and Extension",
                  "description": "Apply the concepts from this lesson on Interfaces",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Interfaces",
                "typescript"
              ],
              "legacy": {
                "originalId": 3,
                "originalTopic": "Interfaces",
                "migrated": "2025-10-01T06:41:13.482Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.482Z",
              "version": "1.0.0"
            },
            {
              "id": "typescript-fundamentals-lesson-4",
              "moduleSlug": "typescript-fundamentals",
              "title": "Class Implementation with Access Modifiers and Abstract Classes",
              "order": 4,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Classes.\n\nLearn how to implement classes with access modifiers in TypeScript, including abstract classes and method overriding.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "abstract class Department {\n  // Public by default\n  name: string\n  \n  // Protected - accessible within class and subclasses\n  protected employees: string[] = []\n  \n  // Private - only accessible within this class\n  private readonly id: string\n  \n  constructor(id: string, n: string) {\n    this.id = id\n    this.name = n\n  }\n  \n  // Abstract method - must be implemented in derived classes\n  abstract describe(): void\n  \n  addEmployee(employee: string) {\n    this.employees.push(employee)\n  }\n  \n  printEmployeeInformation() {\n    console.log(`Department: ${this.name} (${this.id})`)\n    console.log('Employees:', this.employees)\n  }\n}\n\nclass ITDepartment extends Department {\n  admins: string[]\n  \n  constructor(id: string, admins: string[]) {\n    super(id, 'IT')  // Call parent constructor\n    this.admins = admins\n  }\n  \n  describe() {\n    console.log(`IT Department - ID: ${this.id}`)\n  }\n  \n  addEmployee(name: string) {\n    if (name === 'Bill') {\n      return  // Don't add Bill\n    }\n    super.addEmployee(name)  // Call parent method\n  }\n}\n\nlet it = new ITDepartment('d1', ['Max'])\nit.addEmployee('Max')\nit.addEmployee('Bill')  // Won't be added\nit.printEmployeeInformation()\nit.describe()",
                "explanation": "This example produces: Class hierarchy with proper encapsulation, abstract classes, and method overriding\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "typescript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Class Implementation with Access Modifiers and Abstract Classes",
                  "description": "Apply the concepts from this lesson on Classes",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Classes",
                "typescript"
              ],
              "legacy": {
                "originalId": 4,
                "originalTopic": "Classes",
                "migrated": "2025-10-01T06:41:13.482Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.482Z",
              "version": "1.0.0"
            },
            {
              "id": "typescript-fundamentals-lesson-5",
              "moduleSlug": "typescript-fundamentals",
              "title": "Generic Types and Constraints",
              "order": 5,
              "objectives": [
                "Master component creation and usage",
                "Implement practical solutions"
              ],
              "intro": "Welcome to this comprehensive lesson on Generics.\n\nLearn how to create reusable components with generics, including generic constraints for more precise type safety.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "// Simple generic function\nfunction identity<T>(arg: T): T {\n  return arg\n}\n\nlet output1 = identity<string>(\"myString\")\nlet output2 = identity(\"myString\")  // Type argument inferred\n\n// Generic interface\ninterface GenericIdentityFn<T> {\n  (arg: T): T\n}\n\nfunction identity2<T>(arg: T): T {\n  return arg\n}\n\nlet myIdentity: GenericIdentityFn<number> = identity2\n\n// Generic class\nclass GenericNumber<T> {\n  zeroValue: T\n  add: (x: T, y: T) => T\n}\n\nlet myGenericNumber = new GenericNumber<number>()\nmyGenericNumber.zeroValue = 0\nmyGenericNumber.add = function(x, y) {\n  return x + y\n}\n\n// Generic constraints\ninterface Lengthwise {\n  length: number\n}\n\nfunction loggingIdentity<T extends Lengthwise>(arg: T): T {\n  console.log(arg.length)  // Now we know it has a .length property\n  return arg\n}\n\nloggingIdentity(\"hello\")  // OK - string has length\nloggingIdentity([1, 2, 3])  // OK - array has length\n// loggingIdentity(3)  // Error - number doesn't have length\n\n// Using type parameters in generic constraints\nfunction getProperty<T, K extends keyof T>(obj: T, key: K) {\n  return obj[key]\n}\n\nlet x = { a: 1, b: 2, c: 3, d: 4 }\ngetProperty(x, \"a\")  // OK\n// getProperty(x, \"m\")  // Error - Argument of type '\"m\"' is not assignable to parameter of type '\"a\" | \"b\" | \"c\" | \"d\"'",
                "explanation": "This example produces: Type-safe generic functions, interfaces, and classes with constraints for flexible yet safe type usage\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "typescript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Generic Types and Constraints",
                  "description": "Apply the concepts from this lesson on Generics",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Generics",
                "typescript"
              ],
              "legacy": {
                "originalId": 5,
                "originalTopic": "Generics",
                "migrated": "2025-10-01T06:41:13.482Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.482Z",
              "version": "1.0.0"
            },
            {
              "id": "typescript-fundamentals-lesson-6",
              "moduleSlug": "typescript-fundamentals",
              "title": "Union, Intersection, and Conditional Types",
              "order": 6,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Advanced Types.\n\nLearn about advanced type compositions including union types, intersection types, and conditional types.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "// Union types\ntype StringOrNumber = string | number\n\nfunction printId(id: StringOrNumber) {\n  if (typeof id === 'string') {\n    console.log(`ID (string): ${id.toUpperCase()}`)\n  } else {\n    console.log(`ID (number): ${id.toFixed(2)}`)\n  }\n}\n\nprintId('abc123')\nprintId(12345)\n\n// Intersection types\ninterface Person {\n  name: string\n}\n\ninterface Employee {\n  employeeId: number\n}\n\ntype PersonEmployee = Person & Employee\n\nconst worker: PersonEmployee = {\n  name: 'John Doe',\n  employeeId: 12345\n}\n\n// Discriminated unions\ninterface Square {\n  kind: 'square'\n  size: number\n}\n\ninterface Rectangle {\n  kind: 'rectangle'\n  width: number\n  height: number\n}\n\ninterface Circle {\n  kind: 'circle'\n  radius: number\n}\n\ntype Shape = Square | Rectangle | Circle\n\nfunction getArea(shape: Shape): number {\n  switch (shape.kind) {\n    case 'square':\n      return shape.size * shape.size\n    case 'rectangle':\n      return shape.width * shape.height\n    case 'circle':\n      return Math.PI * shape.radius ** 2\n    default:\n      const _exhaustiveCheck: never = shape\n      return _exhaustiveCheck\n  }\n}\n\n// Conditional types\ntype NonNullable<T> = T extends null | undefined ? never : T\ntype StringsOnly<T> = T extends string ? T : never\n\ntype A = NonNullable<string | null>  // string\ntype B = StringsOnly<string | number>  // string",
                "explanation": "This example produces: ID (string): ABC123\nID (number): 12345.00\nDemonstrates union types, intersection types, and type-safe discriminated unions\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "typescript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Union, Intersection, and Conditional Types",
                  "description": "Apply the concepts from this lesson on Advanced Types",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Advanced",
              "tags": [
                "Advanced Types",
                "typescript"
              ],
              "legacy": {
                "originalId": 6,
                "originalTopic": "Advanced Types",
                "migrated": "2025-10-01T06:41:13.482Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.482Z",
              "version": "1.0.0"
            },
            {
              "id": "typescript-fundamentals-lesson-7",
              "moduleSlug": "typescript-fundamentals",
              "title": "Type Guards and Type Assertions",
              "order": 7,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Type Guards.\n\nLearn how to narrow types using type guards and safely assert types in TypeScript.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "// Type predicate functions\nfunction isString(value: unknown): value is string {\n  return typeof value === 'string'\n}\n\nfunction isNumber(value: unknown): value is number {\n  return typeof value === 'number'\n}\n\n// Using type guards\nfunction processValue(value: unknown) {\n  if (isString(value)) {\n    // TypeScript knows value is string here\n    console.log(`String length: ${value.length}`)\n  } else if (isNumber(value)) {\n    // TypeScript knows value is number here\n    console.log(`Number fixed: ${value.toFixed(2)}`)\n  } else {\n    console.log('Unknown type')\n  }\n}\n\nprocessValue('Hello')\nprocessValue(42.123)\nprocessValue(true)\n\n// instanceof type guard\nclass Bird {\n  fly() {\n    console.log('Flying!')\n  }\n  layEggs() {\n    console.log('Laying eggs!')\n  }\n}\n\nclass Fish {\n  swim() {\n    console.log('Swimming!')\n  }\n  layEggs() {\n    console.log('Laying eggs!')\n  }\n}\n\nfunction getAnimal(): Bird | Fish {\n  return Math.random() > 0.5 ? new Bird() : new Fish()\n}\n\nfunction moveAnimal(animal: Bird | Fish) {\n  if (animal instanceof Bird) {\n    animal.fly()  // TypeScript knows it's a Bird\n  } else {\n    animal.swim()  // TypeScript knows it's a Fish\n  }\n  animal.layEggs()  // Available on both\n}\n\n// Type assertions\nconst someValue: unknown = 'this is a string'\nconst strLength: number = (someValue as string).length\n\n// Non-null assertion operator\nfunction processName(name: string | null) {\n  // We know name is not null here\n  console.log(name!.charAt(0))\n}",
                "explanation": "This example produces: String length: 5\nNumber fixed: 42.12\nUnknown type\nFlying! or Swimming!\nLaying eggs!\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "typescript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Type Guards and Type Assertions",
                  "description": "Apply the concepts from this lesson on Type Guards",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Type Guards",
                "typescript"
              ],
              "legacy": {
                "originalId": 7,
                "originalTopic": "Type Guards",
                "migrated": "2025-10-01T06:41:13.482Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.482Z",
              "version": "1.0.0"
            },
            {
              "id": "typescript-fundamentals-lesson-8",
              "moduleSlug": "typescript-fundamentals",
              "title": "Built-in Utility Types",
              "order": 8,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Utility Types.\n\nLearn about TypeScript's built-in utility types for transforming types efficiently.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "interface User {\n  id: number\n  name: string\n  email: string\n  age: number\n  isActive: boolean\n}\n\n// Partial - makes all properties optional\ntype PartialUser = Partial<User>\nconst updateUser: PartialUser = {\n  name: 'John Doe'  // Only name is provided\n}\n\n// Required - makes all properties required\ninterface OptionalUser {\n  id?: number\n  name?: string\n  email?: string\n}\n\ntype RequiredUser = Required<OptionalUser>\n// All properties are now required\n\n// Pick - creates a type by picking specific properties\ntype UserSummary = Pick<User, 'id' | 'name' | 'email'>\nconst summary: UserSummary = {\n  id: 1,\n  name: 'Jane',\n  email: 'jane@example.com'\n  // age and isActive are not included\n}\n\n// Omit - creates a type by omitting specific properties\ntype PublicUser = Omit<User, 'id' | 'isActive'>\nconst publicInfo: PublicUser = {\n  name: 'Bob',\n  email: 'bob@example.com',\n  age: 30\n  // id and isActive are omitted\n}\n\n// Record - creates an object type with specific keys and values\ntype UserRoles = Record<'admin' | 'user' | 'guest', string[]>\nconst roles: UserRoles = {\n  admin: ['read', 'write', 'delete'],\n  user: ['read', 'write'],\n  guest: ['read']\n}\n\n// Exclude and Extract\ntype T1 = Exclude<'a' | 'b' | 'c', 'a'>  // 'b' | 'c'\ntype T2 = Extract<'a' | 'b' | 'c', 'a' | 'f'>  // 'a'\n\n// ReturnType - extracts return type of function\nfunction getUser() {\n  return { id: 1, name: 'John' }\n}\n\ntype UserReturnType = ReturnType<typeof getUser>  // { id: number, name: string }\n\n// Parameters - extracts parameter types\nfunction createUser(name: string, age: number, email: string) {\n  return { name, age, email }\n}\n\ntype CreateUserParams = Parameters<typeof createUser>  // [string, number, string]",
                "explanation": "This example produces: Demonstrates various utility types for flexible type transformations and code reuse\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "typescript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Built-in Utility Types",
                  "description": "Apply the concepts from this lesson on Utility Types",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Utility Types",
                "typescript"
              ],
              "legacy": {
                "originalId": 8,
                "originalTopic": "Utility Types",
                "migrated": "2025-10-01T06:41:13.482Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.482Z",
              "version": "1.0.0"
            },
            {
              "id": "typescript-fundamentals-lesson-9",
              "moduleSlug": "typescript-fundamentals",
              "title": "Decorators and Metadata",
              "order": 9,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Decorators.\n\nLearn how to use decorators for meta-programming in TypeScript.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "// Enable decorators in tsconfig.json:\n// \"experimentalDecorators\": true,\n// \"emitDecoratorMetadata\": true\n\n// Class decorator\nfunction sealed(constructor: Function) {\n  Object.seal(constructor)\n  Object.seal(constructor.prototype)\n}\n\n// Method decorator\nfunction enumerable(value: boolean) {\n  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n    descriptor.enumerable = value\n  }\n}\n\n// Property decorator\nfunction format(formatString: string) {\n  return function (target: any, propertyKey: string) {\n    let value = target[propertyKey]\n    \n    const getter = function () {\n      return `${formatString} ${value}`\n    }\n    \n    const setter = function (newVal: string) {\n      value = newVal\n    }\n    \n    Object.defineProperty(target, propertyKey, {\n      get: getter,\n      set: setter,\n      enumerable: true,\n      configurable: true\n    })\n  }\n}\n\n// Parameter decorator\nfunction required(target: any, propertyKey: string, parameterIndex: number) {\n  const existingRequiredParameters: number[] = Reflect.getOwnMetadata('required', target, propertyKey) || []\n  existingRequiredParameters.push(parameterIndex)\n  Reflect.defineMetadata('required', existingRequiredParameters, target, propertyKey)\n}\n\n// Usage of decorators\n@sealed\nclass Greeter {\n  @format('Hello')\n  greeting: string\n  \n  constructor(message: string) {\n    this.greeting = message\n  }\n  \n  @enumerable(false)\n  greet(@required name: string) {\n    return `${this.greeting}, ${name}!`\n  }\n}\n\nconst greeter = new Greeter('world')\nconsole.log(greeter.greet('TypeScript'))\n\n// Decorator factory example\nfunction log(prefix: string) {\n  return function (target: any, propertyName: string, descriptor: PropertyDescriptor) {\n    const method = descriptor.value\n    \n    descriptor.value = function (...args: any[]) {\n      console.log(`${prefix}: Calling ${propertyName} with args:`, args)\n      const result = method.apply(this, args)\n      console.log(`${prefix}: ${propertyName} returned:`, result)\n      return result\n    }\n  }\n}\n\nclass Calculator {\n  @log('CALC')\n  add(a: number, b: number): number {\n    return a + b\n  }\n}\n\nconst calc = new Calculator()\ncalc.add(2, 3)",
                "explanation": "This example produces: Hello world, TypeScript!\nCALC: Calling add with args: [2, 3]\nCALC: add returned: 5\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "typescript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Decorators and Metadata",
                  "description": "Apply the concepts from this lesson on Decorators",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Decorators",
                "typescript"
              ],
              "legacy": {
                "originalId": 9,
                "originalTopic": "Decorators",
                "migrated": "2025-10-01T06:41:13.482Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.482Z",
              "version": "1.0.0"
            },
            {
              "id": "typescript-fundamentals-lesson-10",
              "moduleSlug": "typescript-fundamentals",
              "title": "Module System and Namespaces",
              "order": 10,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Modules.\n\nLearn about TypeScript's module system, import/export statements, and namespaces.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "// math.ts - Module with multiple exports\nexport function add(x: number, y: number): number {\n  return x + y\n}\n\nexport function subtract(x: number, y: number): number {\n  return x - y\n}\n\nexport const PI = 3.14159\n\n// Default export\nexport default class Calculator {\n  multiply(x: number, y: number): number {\n    return x * y\n  }\n}\n\n// utils.ts - Re-exports\nexport { add, subtract } from './math'\nexport { default as Calculator } from './math'\n\n// app.ts - Various import syntaxes\nimport Calculator, { add, subtract, PI } from './math'\nimport * as MathUtils from './math'\nimport { add as addition } from './math'\n\nconst calc = new Calculator()\nconsole.log(add(5, 3))\nconsole.log(subtract(10, 4))\nconsole.log(calc.multiply(3, 4))\nconsole.log(PI)\n\n// Using namespace alias\nconsole.log(MathUtils.add(1, 2))\nconsole.log(addition(2, 3))\n\n// Namespace declaration (legacy approach)\nnamespace Geometry {\n  export interface Point {\n    x: number\n    y: number\n  }\n  \n  export function distance(p1: Point, p2: Point): number {\n    const dx = p1.x - p2.x\n    const dy = p1.y - p2.y\n    return Math.sqrt(dx * dx + dy * dy)\n  }\n  \n  export namespace Circle {\n    export function area(radius: number): number {\n      return Math.PI * radius * radius\n    }\n    \n    export function circumference(radius: number): number {\n      return 2 * Math.PI * radius\n    }\n  }\n}\n\n// Using namespace\nconst p1: Geometry.Point = { x: 0, y: 0 }\nconst p2: Geometry.Point = { x: 3, y: 4 }\nconsole.log(Geometry.distance(p1, p2))  // 5\nconsole.log(Geometry.Circle.area(5))    // ~78.54\n\n// Dynamic imports\nasync function loadMath() {\n  const mathModule = await import('./math')\n  console.log(mathModule.add(10, 20))\n}",
                "explanation": "This example produces: 8\n6\n12\n3.14159\n3\n5\n5\n78.54\n30 (from dynamic import)\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "typescript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Module System and Namespaces",
                  "description": "Apply the concepts from this lesson on Modules",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Modules",
                "typescript"
              ],
              "legacy": {
                "originalId": 10,
                "originalTopic": "Modules",
                "migrated": "2025-10-01T06:41:13.482Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.482Z",
              "version": "1.0.0"
            },
            {
              "id": "typescript-fundamentals-lesson-11",
              "moduleSlug": "typescript-fundamentals",
              "title": "Promises, Async/Await with TypeScript",
              "order": 11,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Async Programming.\n\nLearn how to work with asynchronous code in TypeScript using Promises and async/await.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "// Typed Promise functions\nfunction fetchUser(id: number): Promise<{ id: number; name: string; email: string }> {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (id > 0) {\n        resolve({\n          id,\n          name: `User ${id}`,\n          email: `user${id}@example.com`\n        })\n      } else {\n        reject(new Error('Invalid user ID'))\n      }\n    }, 1000)\n  })\n}\n\n// Generic Promise wrapper\nfunction delay<T>(ms: number, value: T): Promise<T> {\n  return new Promise(resolve => {\n    setTimeout(() => resolve(value), ms)\n  })\n}\n\n// Async/await with error handling\nasync function getUserInfo(id: number): Promise<string> {\n  try {\n    const user = await fetchUser(id)\n    const greeting = await delay(500, `Hello, ${user.name}!`)\n    return greeting\n  } catch (error) {\n    throw new Error(`Failed to get user info: ${error.message}`)\n  }\n}\n\n// Promise combinators with types\ninterface ApiResponse<T> {\n  data: T\n  status: number\n  timestamp: Date\n}\n\nasync function fetchMultipleUsers(ids: number[]): Promise<ApiResponse<any>[]> {\n  const promises = ids.map(id => \n    fetchUser(id).then(user => ({\n      data: user,\n      status: 200,\n      timestamp: new Date()\n    })).catch(error => ({\n      data: null,\n      status: 404,\n      timestamp: new Date(),\n      error: error.message\n    }))\n  )\n  \n  return Promise.all(promises)\n}\n\n// Async iterators\nasync function* generateNumbers(): AsyncIterableIterator<number> {\n  for (let i = 1; i <= 5; i++) {\n    await delay(100, null)\n    yield i\n  }\n}\n\n// Usage examples\nasync function main() {\n  try {\n    // Single user\n    const greeting = await getUserInfo(1)\n    console.log(greeting)\n    \n    // Multiple users\n    const responses = await fetchMultipleUsers([1, 2, -1])\n    console.log('Responses:', responses.length)\n    \n    // Async iteration\n    for await (const num of generateNumbers()) {\n      console.log(`Generated: ${num}`)\n    }\n    \n  } catch (error) {\n    console.error('Error:', error.message)\n  }\n}\n\nmain()",
                "explanation": "This example produces: Hello, User 1!\nResponses: 3\nGenerated: 1\nGenerated: 2\nGenerated: 3\nGenerated: 4\nGenerated: 5\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "typescript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Promises, Async/Await with TypeScript",
                  "description": "Apply the concepts from this lesson on Async Programming",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Async Programming",
                "typescript"
              ],
              "legacy": {
                "originalId": 11,
                "originalTopic": "Async Programming",
                "migrated": "2025-10-01T06:41:13.482Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.482Z",
              "version": "1.0.0"
            },
            {
              "id": "typescript-fundamentals-lesson-12",
              "moduleSlug": "typescript-fundamentals",
              "title": "Testing TypeScript Code",
              "order": 12,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Testing.\n\nLearn how to write comprehensive tests for TypeScript code using Jest and type-safe testing patterns.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "// user.ts - Code to test\nexport interface User {\n  id: number\n  name: string\n  email: string\n  age: number\n}\n\nexport class UserService {\n  private users: User[] = []\n  \n  addUser(user: Omit<User, 'id'>): User {\n    const newUser: User = {\n      ...user,\n      id: Math.max(0, ...this.users.map(u => u.id)) + 1\n    }\n    this.users.push(newUser)\n    return newUser\n  }\n  \n  getUser(id: number): User | undefined {\n    return this.users.find(user => user.id === id)\n  }\n  \n  updateUser(id: number, updates: Partial<User>): User | null {\n    const userIndex = this.users.findIndex(user => user.id === id)\n    if (userIndex === -1) return null\n    \n    this.users[userIndex] = { ...this.users[userIndex], ...updates }\n    return this.users[userIndex]\n  }\n  \n  deleteUser(id: number): boolean {\n    const userIndex = this.users.findIndex(user => user.id === id)\n    if (userIndex === -1) return false\n    \n    this.users.splice(userIndex, 1)\n    return true\n  }\n  \n  getAllUsers(): User[] {\n    return [...this.users]\n  }\n}\n\n// user.test.ts - Comprehensive tests\nimport { UserService, User } from './user'\n\ndescribe('UserService', () => {\n  let userService: UserService\n  \n  beforeEach(() => {\n    userService = new UserService()\n  })\n  \n  describe('addUser', () => {\n    it('should add a user with auto-generated id', () => {\n      const userData = { name: 'John Doe', email: 'john@example.com', age: 30 }\n      const user = userService.addUser(userData)\n      \n      expect(user.id).toBe(1)\n      expect(user.name).toBe('John Doe')\n      expect(user.email).toBe('john@example.com')\n      expect(user.age).toBe(30)\n    })\n    \n    it('should increment id for subsequent users', () => {\n      userService.addUser({ name: 'User 1', email: 'user1@test.com', age: 25 })\n      const secondUser = userService.addUser({ name: 'User 2', email: 'user2@test.com', age: 35 })\n      \n      expect(secondUser.id).toBe(2)\n    })\n  })\n  \n  describe('getUser', () => {\n    it('should return user by id', () => {\n      const addedUser = userService.addUser({ name: 'Test User', email: 'test@example.com', age: 28 })\n      const foundUser = userService.getUser(addedUser.id)\n      \n      expect(foundUser).toEqual(addedUser)\n    })\n    \n    it('should return undefined for non-existent user', () => {\n      const user = userService.getUser(999)\n      expect(user).toBeUndefined()\n    })\n  })\n  \n  describe('updateUser', () => {\n    it('should update existing user partially', () => {\n      const user = userService.addUser({ name: 'Original Name', email: 'original@test.com', age: 25 })\n      const updated = userService.updateUser(user.id, { name: 'Updated Name', age: 26 })\n      \n      expect(updated).toMatchObject({\n        id: user.id,\n        name: 'Updated Name',\n        email: 'original@test.com',\n        age: 26\n      })\n    })\n    \n    it('should return null for non-existent user', () => {\n      const result = userService.updateUser(999, { name: 'New Name' })\n      expect(result).toBeNull()\n    })\n  })\n})",
                "explanation": "This example produces:  UserService  addUser  should add a user with auto-generated id\n UserService  addUser  should increment id for subsequent users\n UserService  getUser  should return user by id\n UserService  getUser  should return undefined for non-existent user\n UserService  updateUser  should update existing user partially\n UserService  updateUser  should return null for non-existent user\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "typescript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Testing TypeScript Code",
                  "description": "Apply the concepts from this lesson on Testing",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Testing",
                "typescript"
              ],
              "legacy": {
                "originalId": 12,
                "originalTopic": "Testing",
                "migrated": "2025-10-01T06:41:13.482Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.482Z",
              "version": "1.0.0"
            },
            {
              "id": "typescript-fundamentals-lesson-13",
              "moduleSlug": "typescript-fundamentals",
              "title": "Advanced TypeScript Patterns and Utility Types",
              "order": 13,
              "objectives": [
                "Master utility types and conditional types",
                "Implement advanced TypeScript patterns",
                "Understand mapped types and template literal types"
              ],
              "intro": "Welcome to this comprehensive lesson on Advanced TypeScript Patterns and Utility Types.\n\nLearn how to leverage TypeScript's advanced type system features to create more robust and maintainable code.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "// Utility Types\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n  age: number;\n  isActive: boolean;\n}\n\n// Partial - makes all properties optional\ntype UserUpdate = Partial<User>;\nconst updateUser = (id: number, updates: UserUpdate) => {\n  // Only update the provided fields\n};\n\n// Pick - select specific properties\ntype UserSummary = Pick<User, 'id' | 'name' | 'email'>;\n\n// Omit - exclude specific properties\ntype CreateUser = Omit<User, 'id'>;\n\n// Record - create object type with specific keys and values\ntype UserRoles = Record<'admin' | 'user' | 'guest', string[]>;\nconst permissions: UserRoles = {\n  admin: ['read', 'write', 'delete'],\n  user: ['read', 'write'],\n  guest: ['read']\n};\n\n// Conditional Types\ntype ApiResponse<T> = T extends string ? string : T extends number ? number : never;\n\n// Mapped Types\ntype Optional<T> = {\n  [K in keyof T]?: T[K];\n};\n\ntype Readonly<T> = {\n  readonly [K in keyof T]: T[K];\n};\n\n// Template Literal Types\ntype Color = 'red' | 'green' | 'blue';\ntype Size = 'small' | 'medium' | 'large';\ntype ThemeClass = `${Color}-${Size}`;\n// Results in: 'red-small' | 'red-medium' | 'red-large' | 'green-small' | etc.\n\n// Advanced Pattern: Discriminated Unions\ninterface LoadingState {\n  status: 'loading';\n}\n\ninterface SuccessState {\n  status: 'success';\n  data: any;\n}\n\ninterface ErrorState {\n  status: 'error';\n  error: string;\n}\n\ntype AsyncState = LoadingState | SuccessState | ErrorState;\n\nfunction handleState(state: AsyncState) {\n  switch (state.status) {\n    case 'loading':\n      console.log('Loading...');\n      break;\n    case 'success':\n      console.log('Data:', state.data); // TypeScript knows data exists\n      break;\n    case 'error':\n      console.log('Error:', state.error); // TypeScript knows error exists\n      break;\n  }\n}\n\n// Advanced Pattern: Builder Pattern with TypeScript\nclass QueryBuilder<T> {\n  private conditions: string[] = [];\n  private orderBy: string = '';\n  private limitCount: number = 0;\n\n  where(condition: keyof T, operator: string, value: any): this {\n    this.conditions.push(`${String(condition)} ${operator} '${value}'`);\n    return this;\n  }\n\n  order(field: keyof T, direction: 'ASC' | 'DESC' = 'ASC'): this {\n    this.orderBy = `ORDER BY ${String(field)} ${direction}`;\n    return this;\n  }\n\n  limit(count: number): this {\n    this.limitCount = count;\n    return this;\n  }\n\n  build(): string {\n    let query = 'SELECT * FROM table';\n    if (this.conditions.length > 0) {\n      query += ` WHERE ${this.conditions.join(' AND ')}`;\n    }\n    if (this.orderBy) {\n      query += ` ${this.orderBy}`;\n    }\n    if (this.limitCount > 0) {\n      query += ` LIMIT ${this.limitCount}`;\n    }\n    return query;\n  }\n}\n\n// Usage\nconst query = new QueryBuilder<User>()\n  .where('age', '>', 18)\n  .where('isActive', '=', true)\n  .order('name', 'ASC')\n  .limit(10)\n  .build();",
                "explanation": "This example demonstrates advanced TypeScript patterns including utility types (Partial, Pick, Omit, Record), conditional types, mapped types, template literal types, discriminated unions, and the builder pattern with proper type safety.\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "typescript"
              },
              "pitfalls": [
                {
                  "mistake": "Overusing complex types that hurt readability",
                  "solution": "Balance type safety with code readability. Use meaningful names and document complex types",
                  "severity": "medium"
                },
                {
                  "mistake": "Not leveraging utility types for DRY code",
                  "solution": "Use built-in utility types like Partial, Pick, and Omit to avoid duplicating type definitions",
                  "severity": "medium"
                },
                {
                  "mistake": "Misusing conditional types for simple scenarios",
                  "solution": "Use conditional types for truly conditional logic, not as a replacement for union types",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Advanced TypeScript Patterns and Utility Types",
                  "description": "Implement advanced TypeScript patterns to create type-safe and maintainable code",
                  "checkpoints": [
                    "Create utility types for common data transformations",
                    "Implement discriminated unions for state management",
                    "Build type-safe APIs using template literal types",
                    "Create reusable patterns with conditional and mapped types"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 40,
              "difficulty": "Advanced",
              "tags": [
                "Advanced Types",
                "Utility Types",
                "typescript"
              ],
              "lastUpdated": "2025-10-01T06:41:13.482Z",
              "version": "1.0.0"
            },
            {
              "id": "typescript-fundamentals-lesson-14",
              "moduleSlug": "typescript-fundamentals",
              "title": "TypeScript in Production and Migration Strategies",
              "order": 14,
              "objectives": [
                "Understand production TypeScript configuration",
                "Learn migration strategies from JavaScript to TypeScript",
                "Implement build optimization and deployment practices"
              ],
              "intro": "Welcome to this comprehensive lesson on TypeScript in Production and Migration Strategies.\n\nLearn how to successfully deploy TypeScript applications to production and migrate existing JavaScript codebases.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "// Production tsconfig.json\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2020\",\n    \"module\": \"ESNext\",\n    \"moduleResolution\": \"node\",\n    \"lib\": [\"ES2020\", \"DOM\"],\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\",\n    \"strict\": true,\n    \"noImplicitAny\": true,\n    \"strictNullChecks\": true,\n    \"strictFunctionTypes\": true,\n    \"noImplicitReturns\": true,\n    \"noFallthroughCasesInSwitch\": true,\n    \"noUncheckedIndexedAccess\": true,\n    \"exactOptionalPropertyTypes\": true,\n    \"allowSyntheticDefaultImports\": true,\n    \"esModuleInterop\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"skipLibCheck\": true,\n    \"declaration\": true,\n    \"declarationMap\": true,\n    \"sourceMap\": false,\n    \"removeComments\": true,\n    \"importHelpers\": true,\n    \"downlevelIteration\": true\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\", \"**/*.test.ts\"]\n}\n\n// Migration Strategy: Gradual adoption\n// 1. Start with JavaScript files and .d.ts declarations\n// types/legacy.d.ts\ndeclare module 'legacy-library' {\n  export function legacyFunction(param: any): any;\n  export const LEGACY_CONSTANT: string;\n}\n\n// 2. Add TypeScript gradually, file by file\n// utils/validation.ts (new TypeScript file)\nexport interface ValidationRule {\n  field: string;\n  required?: boolean;\n  minLength?: number;\n  maxLength?: number;\n  pattern?: RegExp;\n}\n\nexport interface ValidationResult {\n  isValid: boolean;\n  errors: string[];\n}\n\nexport class Validator {\n  private rules: ValidationRule[] = [];\n\n  addRule(rule: ValidationRule): this {\n    this.rules.push(rule);\n    return this;\n  }\n\n  validate(data: Record<string, any>): ValidationResult {\n    const errors: string[] = [];\n\n    for (const rule of this.rules) {\n      const value = data[rule.field];\n\n      if (rule.required && (value === undefined || value === null || value === '')) {\n        errors.push(`${rule.field} is required`);\n        continue;\n      }\n\n      if (typeof value === 'string') {\n        if (rule.minLength && value.length < rule.minLength) {\n          errors.push(`${rule.field} must be at least ${rule.minLength} characters`);\n        }\n        if (rule.maxLength && value.length > rule.maxLength) {\n          errors.push(`${rule.field} must be no more than ${rule.maxLength} characters`);\n        }\n        if (rule.pattern && !rule.pattern.test(value)) {\n          errors.push(`${rule.field} format is invalid`);\n        }\n      }\n    }\n\n    return {\n      isValid: errors.length === 0,\n      errors\n    };\n  }\n}\n\n// 3. Build configuration for production\n// webpack.config.js\nconst path = require('path');\n\nmodule.exports = {\n  entry: './src/index.ts',\n  module: {\n    rules: [\n      {\n        test: /\\.ts$/,\n        use: 'ts-loader',\n        exclude: /node_modules/,\n      },\n    ],\n  },\n  resolve: {\n    extensions: ['.ts', '.js'],\n  },\n  output: {\n    filename: 'bundle.js',\n    path: path.resolve(__dirname, 'dist'),\n  },\n  optimization: {\n    usedExports: true,\n    sideEffects: false,\n  },\n};\n\n// CI/CD Integration\n// .github/workflows/typescript.yml\n/*\nname: TypeScript CI\non: [push, pull_request]\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v2\n    - name: Setup Node.js\n      uses: actions/setup-node@v2\n      with:\n        node-version: '16'\n    - name: Install dependencies\n      run: npm ci\n    - name: TypeScript type check\n      run: npx tsc --noEmit\n    - name: Lint\n      run: npm run lint\n    - name: Test\n      run: npm test\n    - name: Build\n      run: npm run build\n*/\n\n// Performance monitoring in production\ninterface PerformanceMetrics {\n  buildTime: number;\n  bundleSize: number;\n  typeCheckTime: number;\n}\n\nclass TypeScriptMetrics {\n  static measureBuildPerformance(): PerformanceMetrics {\n    const start = Date.now();\n    // Build process timing logic\n    const buildTime = Date.now() - start;\n    \n    return {\n      buildTime,\n      bundleSize: this.getBundleSize(),\n      typeCheckTime: this.getTypeCheckTime()\n    };\n  }\n\n  private static getBundleSize(): number {\n    // Logic to measure bundle size\n    return 0;\n  }\n\n  private static getTypeCheckTime(): number {\n    // Logic to measure type checking time\n    return 0;\n  }\n}",
                "explanation": "This example demonstrates production-ready TypeScript configuration, migration strategies for converting JavaScript projects, build optimization, and deployment practices including CI/CD integration.\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "typescript"
              },
              "pitfalls": [
                {
                  "mistake": "Enabling strict mode too early in migration",
                  "solution": "Gradually enable strict TypeScript options during migration to avoid overwhelming the team",
                  "severity": "medium"
                },
                {
                  "mistake": "Not configuring proper build optimization",
                  "solution": "Use tree shaking, code splitting, and proper bundling for production builds",
                  "severity": "medium"
                },
                {
                  "mistake": "Missing type checking in CI/CD pipeline",
                  "solution": "Always include TypeScript type checking as part of your automated build process",
                  "severity": "high"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: TypeScript in Production and Migration Strategies",
                  "description": "Set up a production-ready TypeScript project and implement migration strategies",
                  "checkpoints": [
                    "Configure production TypeScript settings",
                    "Set up build optimization and bundling",
                    "Implement gradual migration strategy",
                    "Configure CI/CD pipeline with type checking",
                    "Monitor and optimize build performance"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 45,
              "difficulty": "Advanced",
              "tags": [
                "Production",
                "Migration",
                "Build Tools",
                "typescript"
              ],
              "lastUpdated": "2025-10-01T06:41:13.482Z",
              "version": "1.0.0"
            }
          ],
          "issues": []
        },
        "quiz": {
          "exists": true,
          "count": 18,
          "questions": [
            {
              "id": "typescript-fundamentals-q1",
              "question": "How do you define a variable with an explicit type annotation in TypeScript?",
              "topic": "Basic Types",
              "difficulty": "Beginner",
              "choices": [
                "let myVar: string = \"hello\"",
                "let myVar string = \"hello\"",
                "let myVar = string \"hello\"",
                "let myVar := string = \"hello\""
              ],
              "correctIndex": 0,
              "explanation": "In TypeScript, type annotations are specified using a colon (:) after the variable name, followed by the type. This provides compile-time type checking and better tooling support.",
              "industryContext": "TypeScript is increasingly adopted in large codebases for better maintainability.",
              "tags": [
                "Basic Types",
                "beginner",
                "typescript"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 1,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.483Z"
              }
            },
            {
              "id": "typescript-fundamentals-q2",
              "question": "Which of the following is the correct way to define an array of strings?",
              "topic": "Basic Types",
              "difficulty": "Intermediate",
              "choices": [
                "let arr: string[] = ['a', 'b', 'c']",
                "let arr: Array<string> = ['a', 'b', 'c']",
                "Both A and B",
                "let arr: [string] = ['a', 'b', 'c']"
              ],
              "correctIndex": 2,
              "explanation": "Both syntaxes are valid in TypeScript. You can use string[] (array literal syntax) or Array<string> (generic syntax) to define an array of strings. The array literal syntax is more common.",
              "industryContext": "TypeScript is increasingly adopted in large codebases for better maintainability.",
              "tags": [
                "Basic Types",
                "intermediate",
                "typescript"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 2,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.483Z"
              }
            },
            {
              "id": "typescript-fundamentals-q3",
              "question": "What is the difference between an interface and a type alias in TypeScript? When would you use each?",
              "topic": "Interfaces",
              "difficulty": "Beginner",
              "choices": [
                "Open-ended question - no multiple choice",
                "This is a conceptual question",
                "Answer requires explanation",
                "Multiple approaches possible"
              ],
              "correctIndex": 0,
              "explanation": "Interfaces create a new name that can be used everywhere and can be extended and implemented. Type aliases don't create a new name and cannot be extended or implemented. Use interfaces for defining object shapes and type aliases for complex types like union types. Interfaces are preferred for object shapes because they support declaration merging.",
              "industryContext": "TypeScript is increasingly adopted in large codebases for better maintainability.",
              "tags": [
                "Interfaces",
                "beginner",
                "typescript"
              ],
              "questionType": "open-ended",
              "estimatedTime": 180,
              "legacy": {
                "originalId": 3,
                "originalType": "open-ended",
                "migrated": "2025-10-01T06:41:13.483Z"
              }
            },
            {
              "id": "typescript-fundamentals-q4",
              "question": "Which access modifier makes a property or method accessible only within the same class?",
              "topic": "Classes",
              "difficulty": "Intermediate",
              "choices": [
                "private",
                "protected",
                "public",
                "internal"
              ],
              "correctIndex": 0,
              "explanation": "The private access modifier restricts access to the containing class only. Protected allows access in the containing class and subclasses, while public allows access from anywhere. TypeScript also supports # syntax for truly private fields.",
              "industryContext": "TypeScript is increasingly adopted in large codebases for better maintainability.",
              "tags": [
                "Classes",
                "intermediate",
                "typescript"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 4,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.483Z"
              }
            },
            {
              "id": "typescript-fundamentals-q5",
              "question": "What is the purpose of generics in TypeScript?",
              "topic": "Generics",
              "difficulty": "Beginner",
              "choices": [
                "To create reusable components that work with multiple types",
                "To enforce strict typing at runtime",
                "To automatically convert JavaScript to TypeScript",
                "To provide better IDE support"
              ],
              "correctIndex": 0,
              "explanation": "Generics allow you to create reusable components that work with a variety of types rather than a single type, providing type safety while maintaining flexibility. They help catch type-related errors at compile time.",
              "industryContext": "TypeScript is increasingly adopted in large codebases for better maintainability.",
              "tags": [
                "Generics",
                "beginner",
                "typescript"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 5,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.483Z"
              }
            },
            {
              "id": "typescript-fundamentals-q6",
              "question": "What is the difference between 'any' and 'unknown' types in TypeScript?",
              "topic": "Type System",
              "difficulty": "Beginner",
              "choices": [
                "'any' bypasses type checking, 'unknown' requires type checking before usage",
                "'unknown' bypasses type checking, 'any' requires type checking",
                "Both work exactly the same way",
                "'any' is for strings, 'unknown' is for numbers"
              ],
              "correctIndex": 0,
              "explanation": "The 'any' type bypasses all type checking, essentially opting out of type safety. The 'unknown' type is safer - it requires type checking (narrowing) before you can perform operations on it. 'unknown' is the type-safe counterpart of 'any'.",
              "industryContext": "TypeScript is increasingly adopted in large codebases for better maintainability.",
              "tags": [
                "Type System",
                "beginner",
                "typescript"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 6,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.483Z"
              }
            },
            {
              "id": "typescript-fundamentals-q7",
              "question": "Explain the concept of 'declaration merging' in TypeScript and when it's useful.",
              "topic": "Interfaces",
              "difficulty": "Intermediate",
              "choices": [
                "Open-ended question - no multiple choice",
                "This is a conceptual question",
                "Answer requires explanation",
                "Multiple approaches possible"
              ],
              "correctIndex": 0,
              "explanation": "Declaration merging allows TypeScript to combine multiple declarations with the same name into a single definition. This is particularly useful for interfaces, where multiple interface declarations with the same name are merged into one. It's commonly used to extend existing types or add properties to global objects without modifying the original definition.",
              "industryContext": "TypeScript is increasingly adopted in large codebases for better maintainability.",
              "tags": [
                "Interfaces",
                "intermediate",
                "typescript"
              ],
              "questionType": "open-ended",
              "estimatedTime": 180,
              "legacy": {
                "originalId": 7,
                "originalType": "open-ended",
                "migrated": "2025-10-01T06:41:13.483Z"
              }
            },
            {
              "id": "typescript-fundamentals-q8",
              "question": "What is a discriminated union in TypeScript?",
              "topic": "Advanced Types",
              "difficulty": "Beginner",
              "choices": [
                "A union type with a common field that can be used to narrow the type",
                "A union of string literals",
                "A union that can only contain primitive types",
                "A union that discriminates against certain types"
              ],
              "correctIndex": 0,
              "explanation": "A discriminated union is a pattern where you use a union of types with a common literal type field (the discriminant) that allows TypeScript to narrow the type in switch statements or conditional checks. This provides type safety for working with variant data structures.",
              "industryContext": "TypeScript is increasingly adopted in large codebases for better maintainability.",
              "tags": [
                "Advanced Types",
                "beginner",
                "typescript"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 8,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.483Z"
              }
            },
            {
              "id": "typescript-fundamentals-q9",
              "question": "What is a mapped type in TypeScript?",
              "topic": "Advanced Types",
              "difficulty": "Beginner",
              "choices": [
                "A type that transforms properties of another type",
                "A type for mapping functions",
                "A geographic mapping type",
                "A type for Map objects"
              ],
              "correctIndex": 0,
              "explanation": "Mapped types allow you to create new types by transforming properties of an existing type, such as making all properties optional with Partial<T>.",
              "industryContext": "TypeScript is increasingly adopted in large codebases for better maintainability.",
              "tags": [
                "Advanced Types",
                "beginner",
                "typescript"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 9,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.483Z"
              }
            },
            {
              "id": "typescript-fundamentals-q10",
              "question": "What does the Pick<T, K> utility type do?",
              "topic": "Utility Types",
              "difficulty": "Intermediate",
              "choices": [
                "Creates a type with selected properties from T",
                "Removes properties from T",
                "Picks random properties",
                "Validates property selection"
              ],
              "correctIndex": 0,
              "explanation": "Pick<T, K> constructs a type by picking the set of properties K from type T, creating a new type with only the specified properties.",
              "industryContext": "TypeScript is increasingly adopted in large codebases for better maintainability.",
              "tags": [
                "Utility Types",
                "intermediate",
                "typescript"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 10,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.483Z"
              }
            },
            {
              "id": "typescript-fundamentals-q11",
              "question": "What are type predicates and how do they work?",
              "topic": "Type Guards",
              "difficulty": "Intermediate",
              "choices": [
                "Open-ended question - no multiple choice",
                "This is a conceptual question",
                "Answer requires explanation",
                "Multiple approaches possible"
              ],
              "correctIndex": 0,
              "explanation": "Type predicates are functions that return a boolean and use the 'is' keyword to tell TypeScript the type of a variable. They narrow types within conditional blocks, improving type safety.",
              "industryContext": "TypeScript is increasingly adopted in large codebases for better maintainability.",
              "tags": [
                "Type Guards",
                "intermediate",
                "typescript"
              ],
              "questionType": "open-ended",
              "estimatedTime": 180,
              "legacy": {
                "originalId": 11,
                "originalType": "open-ended",
                "migrated": "2025-10-01T06:41:13.483Z"
              }
            },
            {
              "id": "typescript-fundamentals-q12",
              "question": "What is the difference between 'import * as' and 'import {}'?",
              "topic": "Modules",
              "difficulty": "Beginner",
              "choices": [
                "'import * as' imports everything as namespace, 'import {}' imports specific exports",
                "No difference in functionality",
                "'import * as' is faster",
                "'import {}' imports everything"
              ],
              "correctIndex": 0,
              "explanation": "'import * as name' imports all exports as a namespace object, while 'import { specific }' imports only specific named exports.",
              "industryContext": "TypeScript is increasingly adopted in large codebases for better maintainability.",
              "tags": [
                "Modules",
                "beginner",
                "typescript"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 12,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.483Z"
              }
            },
            {
              "id": "typescript-fundamentals-q13",
              "question": "What are decorators in TypeScript?",
              "topic": "Decorators",
              "difficulty": "Intermediate",
              "choices": [
                "Functions that modify classes, methods, or properties",
                "UI design patterns",
                "Error handling mechanisms",
                "Performance optimization tools"
              ],
              "correctIndex": 0,
              "explanation": "Decorators are functions that can modify or observe classes, methods, properties, or parameters, providing meta-programming capabilities.",
              "industryContext": "TypeScript is increasingly adopted in large codebases for better maintainability.",
              "tags": [
                "Decorators",
                "intermediate",
                "typescript"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 13,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.483Z"
              }
            },
            {
              "id": "typescript-fundamentals-q14",
              "question": "How do conditional types work in TypeScript?",
              "topic": "Conditional Types",
              "difficulty": "Intermediate",
              "choices": [
                "Open-ended question - no multiple choice",
                "This is a conceptual question",
                "Answer requires explanation",
                "Multiple approaches possible"
              ],
              "correctIndex": 0,
              "explanation": "Conditional types use the ternary operator syntax 'T extends U ? X : Y' to select types based on conditions, enabling powerful type transformations and generic constraints.",
              "industryContext": "TypeScript is increasingly adopted in large codebases for better maintainability.",
              "tags": [
                "Conditional Types",
                "intermediate",
                "typescript"
              ],
              "questionType": "open-ended",
              "estimatedTime": 180,
              "legacy": {
                "originalId": 14,
                "originalType": "open-ended",
                "migrated": "2025-10-01T06:41:13.483Z"
              }
            },
            {
              "id": "typescript-fundamentals-q15",
              "question": "What is tree shaking in TypeScript projects?",
              "topic": "Performance",
              "difficulty": "Beginner",
              "choices": [
                "Removing unused code during bundling",
                "Optimizing type checking",
                "Cleaning up imports",
                "Reducing file sizes"
              ],
              "correctIndex": 0,
              "explanation": "Tree shaking eliminates unused code from the final bundle, reducing bundle size and improving performance in production applications.",
              "industryContext": "TypeScript is increasingly adopted in large codebases for better maintainability.",
              "tags": [
                "Performance",
                "beginner",
                "typescript"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 15,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.483Z"
              }
            },
            {
              "id": "typescript-fundamentals-q16",
              "question": "Which utility type removes all properties from a type T that are assignable to type U?",
              "topic": "Advanced Types",
              "difficulty": "Advanced",
              "choices": [
                "Omit<T, U>",
                "Exclude<T, U>",
                "Extract<T, U>",
                "Pick<T, U>"
              ],
              "correctIndex": 1,
              "explanation": "Exclude<T, U> constructs a type by excluding from T all union members that are assignable to U. Omit works on object properties, while Exclude works on union types.",
              "industryContext": "Utility types are essential for advanced TypeScript development and are commonly used in large-scale applications.",
              "tags": [
                "Advanced Types",
                "advanced",
                "typescript"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 120
            },
            {
              "id": "typescript-fundamentals-q17",
              "question": "What are the key considerations when migrating a JavaScript project to TypeScript?",
              "topic": "Migration",
              "difficulty": "Advanced",
              "choices": [
                "Open-ended question - no multiple choice",
                "This is a conceptual question",
                "Answer requires explanation",
                "Multiple approaches possible"
              ],
              "correctIndex": 0,
              "explanation": "Key considerations include: gradual adoption by renaming .js to .ts files incrementally, configuring tsconfig.json with appropriate strictness levels, adding type definitions for third-party libraries, creating .d.ts files for legacy code, setting up proper build tools (webpack, rollup), establishing team conventions, and implementing type checking in CI/CD pipelines.",
              "industryContext": "Many companies migrate existing JavaScript codebases to TypeScript to improve maintainability and developer experience.",
              "tags": [
                "Migration",
                "advanced",
                "typescript"
              ],
              "questionType": "open-ended",
              "estimatedTime": 180
            },
            {
              "id": "typescript-fundamentals-q18",
              "question": "What is the purpose of the 'satisfies' operator introduced in TypeScript 4.9?",
              "topic": "Advanced Types",
              "difficulty": "Advanced",
              "choices": [
                "To check that a type satisfies a constraint without widening the type",
                "To convert between incompatible types",
                "To create intersection types",
                "To enable strict null checks"
              ],
              "correctIndex": 0,
              "explanation": "The 'satisfies' operator allows you to validate that a type satisfies a certain constraint without changing the inferred type of the expression. This provides type safety while preserving the original type information for better IDE support and type narrowing.",
              "industryContext": "The satisfies operator helps maintain type safety while preserving precise type information, which is crucial for modern TypeScript development.",
              "tags": [
                "Advanced Types",
                "advanced",
                "typescript"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 120
            }
          ],
          "issues": []
        },
        "meetsThresholds": true,
        "issues": []
      },
      "node-fundamentals": {
        "slug": "node-fundamentals",
        "title": "Node.js Development",
        "tier": "core",
        "track": "Backend",
        "difficulty": "Intermediate",
        "thresholds": {
          "requiredLessons": 15,
          "requiredQuestions": 20
        },
        "lessons": {
          "exists": true,
          "count": 15,
          "lessons": [
            {
              "id": "node-fundamentals-lesson-1",
              "moduleSlug": "node-fundamentals",
              "title": "Introduction to Node.js",
              "order": 1,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Basics.\n\nLearn the fundamentals of Node.js and how it enables server-side JavaScript.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "// Basic Node.js server\nconst http = require('http');\n\nconst server = http.createServer((req, res) => {\n  res.statusCode = 200;\n  res.setHeader('Content-Type', 'text/plain');\n  res.end('Hello World!');\n});\n\nserver.listen(3000, '127.0.0.1', () => {\n  console.log('Server running at http://127.0.0.1:3000/');\n});",
                "explanation": "This example produces: Server running at http://127.0.0.1:3000/\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Introduction to Node.js",
                  "description": "Apply the concepts from this lesson on Basics",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Beginner",
              "tags": [
                "Basics",
                "node"
              ],
              "legacy": {
                "originalId": 1,
                "originalTopic": "Basics",
                "migrated": "2025-10-01T06:41:13.484Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.484Z",
              "version": "1.0.0"
            },
            {
              "id": "node-fundamentals-lesson-2",
              "moduleSlug": "node-fundamentals",
              "title": "Node.js Modules",
              "order": 2,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Basics.\n\nLearn how to create and use modules in Node.js.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "// math.js\nfunction add(a, b) {\n  return a + b;\n}\n\nfunction subtract(a, b) {\n  return a - b;\n}\n\nmodule.exports = { add, subtract };\n\n// app.js\nconst { add, subtract } = require('./math');\n\nconsole.log(add(5, 3)); // 8\nconsole.log(subtract(5, 3)); // 2",
                "explanation": "This example produces: 8\n2\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Node.js Modules",
                  "description": "Apply the concepts from this lesson on Basics",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Basics",
                "node"
              ],
              "legacy": {
                "originalId": 2,
                "originalTopic": "Basics",
                "migrated": "2025-10-01T06:41:13.484Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.484Z",
              "version": "1.0.0"
            },
            {
              "id": "node-fundamentals-lesson-3",
              "moduleSlug": "node-fundamentals",
              "title": "Building REST APIs with Express",
              "order": 3,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Express.\n\nLearn how to create RESTful APIs using the Express.js framework.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "const express = require('express');\nconst app = express();\n\n// Middleware to parse JSON\napp.use(express.json());\n\n// GET request\napp.get('/users', (req, res) => {\n  res.json([{ id: 1, name: 'John' }, { id: 2, name: 'Jane' }]);\n});\n\n// POST request\napp.post('/users', (req, res) => {\n  const user = req.body;\n  res.status(201).json({ id: 3, ...user });\n});\n\napp.listen(3000, () => console.log('Server started on port 3000'));",
                "explanation": "This example produces: Server started on port 3000\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Building REST APIs with Express",
                  "description": "Apply the concepts from this lesson on Express",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Express",
                "node"
              ],
              "legacy": {
                "originalId": 3,
                "originalTopic": "Express",
                "migrated": "2025-10-01T06:41:13.484Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.484Z",
              "version": "1.0.0"
            },
            {
              "id": "node-fundamentals-lesson-4",
              "moduleSlug": "node-fundamentals",
              "title": "Middleware in Express",
              "order": 4,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Express.\n\nLearn how to use and create middleware functions in Express.js.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "const express = require('express');\nconst app = express();\n\n// Custom middleware\nconst logger = (req, res, next) => {\n  console.log(`${req.method} ${req.url}`);\n  next();\n};\n\n// Application-level middleware\napp.use(logger);\n\n// Route-specific middleware\nconst auth = (req, res, next) => {\n  const token = req.header('Authorization');\n  if (token === 'secret-token') {\n    next();\n  } else {\n    res.status(401).json({ error: 'Unauthorized' });\n  }\n};\n\napp.get('/protected', auth, (req, res) => {\n  res.json({ message: 'Protected data' });\n});",
                "explanation": "This example produces: GET /protected\n401 {\"error\": \"Unauthorized\"} (without token) or 200 {\"message\": \"Protected data\"} (with token)\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Middleware in Express",
                  "description": "Apply the concepts from this lesson on Express",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Express",
                "node"
              ],
              "legacy": {
                "originalId": 4,
                "originalTopic": "Express",
                "migrated": "2025-10-01T06:41:13.484Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.484Z",
              "version": "1.0.0"
            },
            {
              "id": "node-fundamentals-lesson-5",
              "moduleSlug": "node-fundamentals",
              "title": "Working with Databases in Node.js",
              "order": 5,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Database.\n\nLearn how to connect and interact with databases using Node.js.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "const { MongoClient } = require('mongodb');\n\nasync function main() {\n  const uri = 'mongodb://localhost:27017';\n  const client = new MongoClient(uri);\n  \n  try {\n    await client.connect();\n    const database = client.db('myDatabase');\n    const collection = database.collection('users');\n    \n    // Insert a document\n    const user = { name: 'John', email: 'john@example.com' };\n    const result = await collection.insertOne(user);\n    console.log(`New user created with id: ${result.insertedId}`);\n    \n    // Find documents\n    const users = await collection.find({}).toArray();\n    console.log('Users:', users);\n  } finally {\n    await client.close();\n  }\n}\n\nmain().catch(console.error);",
                "explanation": "This example produces: New user created with id: [ObjectId]\nUsers: [{ name: 'John', email: 'john@example.com' }]\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Working with Databases in Node.js",
                  "description": "Apply the concepts from this lesson on Database",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Database",
                "node"
              ],
              "legacy": {
                "originalId": 5,
                "originalTopic": "Database",
                "migrated": "2025-10-01T06:41:13.484Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.484Z",
              "version": "1.0.0"
            },
            {
              "id": "node-fundamentals-lesson-6",
              "moduleSlug": "node-fundamentals",
              "title": "Promises and Async/Await",
              "order": 6,
              "objectives": [
                "Build foundational understanding",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Async Programming.\n\nMaster asynchronous programming patterns in Node.js using Promises and async/await.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "// Promise-based function\nfunction fetchData() {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve('Data fetched successfully');\n    }, 1000);\n  });\n}\n\n// Using async/await\nasync function getData() {\n  try {\n    const data = await fetchData();\n    console.log(data);\n    return data;\n  } catch (error) {\n    console.error('Error:', error);\n  }\n}\n\n// Using Promises\nfetchData()\n  .then(data => console.log(data))\n  .catch(error => console.error(error));\n\ngetData();",
                "explanation": "This example produces: Data fetched successfully\nData fetched successfully\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Promises and Async/Await",
                  "description": "Apply the concepts from this lesson on Async Programming",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Async Programming",
                "node"
              ],
              "legacy": {
                "originalId": 6,
                "originalTopic": "Async Programming",
                "migrated": "2025-10-01T06:41:13.484Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.484Z",
              "version": "1.0.0"
            },
            {
              "id": "node-fundamentals-lesson-7",
              "moduleSlug": "node-fundamentals",
              "title": "File System Operations",
              "order": 7,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on File System.\n\nLearn how to work with files and directories using Node.js fs module.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "const fs = require('fs').promises;\nconst path = require('path');\n\nasync function fileOperations() {\n  try {\n    // Write to file\n    await fs.writeFile('example.txt', 'Hello Node.js!');\n    console.log('File written successfully');\n    \n    // Read from file\n    const data = await fs.readFile('example.txt', 'utf8');\n    console.log('File content:', data);\n    \n    // Check if file exists\n    try {\n      await fs.access('example.txt');\n      console.log('File exists');\n    } catch {\n      console.log('File does not exist');\n    }\n    \n    // Delete file\n    await fs.unlink('example.txt');\n    console.log('File deleted');\n  } catch (error) {\n    console.error('File operation error:', error);\n  }\n}\n\nfileOperations();",
                "explanation": "This example produces: File written successfully\nFile content: Hello Node.js!\nFile exists\nFile deleted\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: File System Operations",
                  "description": "Apply the concepts from this lesson on File System",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "File System",
                "node"
              ],
              "legacy": {
                "originalId": 7,
                "originalTopic": "File System",
                "migrated": "2025-10-01T06:41:13.484Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.484Z",
              "version": "1.0.0"
            },
            {
              "id": "node-fundamentals-lesson-8",
              "moduleSlug": "node-fundamentals",
              "title": "Error Handling and Debugging",
              "order": 8,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Error Handling.\n\nLearn best practices for error handling and debugging in Node.js applications.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "// Custom error class\nclass ValidationError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'ValidationError';\n  }\n}\n\n// Function with error handling\nfunction validateUser(user) {\n  if (!user.name) {\n    throw new ValidationError('Name is required');\n  }\n  if (!user.email) {\n    throw new ValidationError('Email is required');\n  }\n  return true;\n}\n\n// Express error middleware\nfunction errorHandler(err, req, res, next) {\n  console.error(err.stack);\n  \n  if (err instanceof ValidationError) {\n    return res.status(400).json({ error: err.message });\n  }\n  \n  res.status(500).json({ error: 'Internal server error' });\n}\n\n// Usage example\ntry {\n  validateUser({ name: 'John' }); // Missing email\n} catch (error) {\n  console.log('Caught error:', error.message);\n}",
                "explanation": "This example produces: Caught error: Email is required\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Error Handling and Debugging",
                  "description": "Apply the concepts from this lesson on Error Handling",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Error Handling",
                "node"
              ],
              "legacy": {
                "originalId": 8,
                "originalTopic": "Error Handling",
                "migrated": "2025-10-01T06:41:13.484Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.484Z",
              "version": "1.0.0"
            },
            {
              "id": "node-fundamentals-lesson-9",
              "moduleSlug": "node-fundamentals",
              "title": "Working with Streams",
              "order": 9,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Streams.\n\nLearn how to handle large data efficiently using Node.js streams.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "const fs = require('fs');\nconst { Transform } = require('stream');\n\n// Create a transform stream\nconst upperCaseTransform = new Transform({\n  transform(chunk, encoding, callback) {\n    this.push(chunk.toString().toUpperCase());\n    callback();\n  }\n});\n\n// Reading and transforming data with streams\nfunction processLargeFile() {\n  const readStream = fs.createReadStream('input.txt');\n  const writeStream = fs.createWriteStream('output.txt');\n  \n  readStream\n    .pipe(upperCaseTransform)\n    .pipe(writeStream)\n    .on('finish', () => {\n      console.log('File processing completed');\n    })\n    .on('error', (error) => {\n      console.error('Stream error:', error);\n    });\n}\n\n// Create readable stream from array\nconst { Readable } = require('stream');\n\nconst arrayStream = new Readable({\n  read() {\n    this.push('data chunk ');\n    this.push(null); // End the stream\n  }\n});\n\narrayStream.on('data', (chunk) => {\n  console.log('Received:', chunk.toString());\n});",
                "explanation": "This example produces: Received: data chunk \nFile processing completed\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Working with Streams",
                  "description": "Apply the concepts from this lesson on Streams",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Streams",
                "node"
              ],
              "legacy": {
                "originalId": 9,
                "originalTopic": "Streams",
                "migrated": "2025-10-01T06:41:13.484Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.484Z",
              "version": "1.0.0"
            },
            {
              "id": "node-fundamentals-lesson-10",
              "moduleSlug": "node-fundamentals",
              "title": "Testing with Jest",
              "order": 10,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Testing.\n\nLearn how to write and run tests for Node.js applications using Jest.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "// math.js\nfunction add(a, b) {\n  return a + b;\n}\n\nfunction divide(a, b) {\n  if (b === 0) {\n    throw new Error('Division by zero');\n  }\n  return a / b;\n}\n\nmodule.exports = { add, divide };\n\n// math.test.js\nconst { add, divide } = require('./math');\n\ndescribe('Math functions', () => {\n  test('adds 1 + 2 to equal 3', () => {\n    expect(add(1, 2)).toBe(3);\n  });\n  \n  test('divides 10 / 2 to equal 5', () => {\n    expect(divide(10, 2)).toBe(5);\n  });\n  \n  test('throws error on division by zero', () => {\n    expect(() => divide(10, 0)).toThrow('Division by zero');\n  });\n  \n  test('async test example', async () => {\n    const result = await Promise.resolve(42);\n    expect(result).toBe(42);\n  });\n});",
                "explanation": "This example produces: PASS math.test.js\n adds 1 + 2 to equal 3\n divides 10 / 2 to equal 5\n throws error on division by zero\n async test example\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Testing with Jest",
                  "description": "Apply the concepts from this lesson on Testing",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Testing",
                "node"
              ],
              "legacy": {
                "originalId": 10,
                "originalTopic": "Testing",
                "migrated": "2025-10-01T06:41:13.484Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.484Z",
              "version": "1.0.0"
            },
            {
              "id": "node-fundamentals-lesson-11",
              "moduleSlug": "node-fundamentals",
              "title": "Security Best Practices",
              "order": 11,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Security.\n\nLearn essential security practices for Node.js applications.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "const express = require('express');\nconst helmet = require('helmet');\nconst rateLimit = require('express-rate-limit');\nconst bcrypt = require('bcrypt');\nconst jwt = require('jsonwebtoken');\n\nconst app = express();\n\n// Security middleware\napp.use(helmet()); // Sets various HTTP headers\napp.use(express.json({ limit: '10mb' })); // Limit body size\n\n// Rate limiting\nconst limiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 100 // limit each IP to 100 requests per windowMs\n});\napp.use(limiter);\n\n// Password hashing\nasync function hashPassword(password) {\n  const saltRounds = 12;\n  return await bcrypt.hash(password, saltRounds);\n}\n\n// JWT token creation\nfunction createToken(userId) {\n  return jwt.sign({ userId }, process.env.JWT_SECRET, { expiresIn: '1h' });\n}\n\n// Input validation\nfunction validateEmail(email) {\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  return emailRegex.test(email);\n}\n\nconsole.log('Security measures implemented');",
                "explanation": "This example produces: Security measures implemented\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Security Best Practices",
                  "description": "Apply the concepts from this lesson on Security",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Security",
                "node"
              ],
              "legacy": {
                "originalId": 11,
                "originalTopic": "Security",
                "migrated": "2025-10-01T06:41:13.484Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.484Z",
              "version": "1.0.0"
            },
            {
              "id": "node-fundamentals-lesson-12",
              "moduleSlug": "node-fundamentals",
              "title": "Performance Optimization",
              "order": 12,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Performance.\n\nLearn techniques to optimize Node.js application performance.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "const cluster = require('cluster');\nconst os = require('os');\nconst express = require('express');\n\n// Clustering for multi-core utilization\nif (cluster.isMaster) {\n  const numCPUs = os.cpus().length;\n  console.log(`Master process ${process.pid} is running`);\n  \n  // Fork workers\n  for (let i = 0; i < numCPUs; i++) {\n    cluster.fork();\n  }\n  \n  cluster.on('exit', (worker, code, signal) => {\n    console.log(`Worker ${worker.process.pid} died`);\n    cluster.fork(); // Replace dead worker\n  });\n} else {\n  const app = express();\n  \n  // Memory-efficient caching\n  const cache = new Map();\n  const MAX_CACHE_SIZE = 1000;\n  \n  function setCache(key, value) {\n    if (cache.size >= MAX_CACHE_SIZE) {\n      const firstKey = cache.keys().next().value;\n      cache.delete(firstKey);\n    }\n    cache.set(key, value);\n  }\n  \n  // Optimized route with caching\n  app.get('/expensive-operation/:id', (req, res) => {\n    const id = req.params.id;\n    \n    if (cache.has(id)) {\n      return res.json(cache.get(id));\n    }\n    \n    // Simulate expensive operation\n    const result = { id, data: 'Processed data', timestamp: Date.now() };\n    setCache(id, result);\n    res.json(result);\n  });\n  \n  app.listen(3000, () => {\n    console.log(`Worker ${process.pid} started`);\n  });\n}",
                "explanation": "This example produces: Master process [PID] is running\nWorker [PID] started\nWorker [PID] started...\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Performance Optimization",
                  "description": "Apply the concepts from this lesson on Performance",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Advanced",
              "tags": [
                "Performance",
                "node"
              ],
              "legacy": {
                "originalId": 12,
                "originalTopic": "Performance",
                "migrated": "2025-10-01T06:41:13.484Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.484Z",
              "version": "1.0.0"
            },
            {
              "id": "node-fundamentals-lesson-13",
              "moduleSlug": "node-fundamentals",
              "title": "Advanced Security Practices in Node.js",
              "order": 13,
              "objectives": [
                "Implement comprehensive security measures in Node.js applications",
                "Understand and prevent common security vulnerabilities",
                "Configure secure authentication and authorization systems"
              ],
              "intro": "Welcome to this comprehensive lesson on Advanced Security Practices in Node.js.\n\nLearn how to secure Node.js applications against common vulnerabilities and implement robust security measures. Security is critical for production applications and requires understanding of various attack vectors and defensive strategies.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "const express = require('express');\nconst helmet = require('helmet');\nconst rateLimit = require('express-rate-limit');\nconst bcrypt = require('bcrypt');\nconst jwt = require('jsonwebtoken');\nconst xss = require('xss');\nconst validator = require('validator');\n\nconst app = express();\n\n// Security middleware\napp.use(helmet({\n  contentSecurityPolicy: {\n    directives: {\n      defaultSrc: [\"'self'\"],\n      styleSrc: [\"'self'\", \"'unsafe-inline'\"],\n      scriptSrc: [\"'self'\"],\n      imgSrc: [\"'self'\", \"data:\", \"https:\"]\n    }\n  }\n}));\n\n// Rate limiting\nconst limiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 100, // limit each IP to 100 requests per windowMs\n  message: 'Too many requests from this IP'\n});\napp.use('/api/', limiter);\n\n// Input validation and sanitization\nfunction validateInput(req, res, next) {\n  const { email, password, name } = req.body;\n  \n  // Validate email\n  if (!validator.isEmail(email)) {\n    return res.status(400).json({ error: 'Invalid email format' });\n  }\n  \n  // Validate password strength\n  if (!validator.isStrongPassword(password, {\n    minLength: 8,\n    minLowercase: 1,\n    minUppercase: 1,\n    minNumbers: 1,\n    minSymbols: 1\n  })) {\n    return res.status(400).json({ error: 'Password too weak' });\n  }\n  \n  // Sanitize name input\n  req.body.name = xss(name);\n  \n  next();\n}\n\n// Secure authentication\nclass AuthService {\n  static async hashPassword(password) {\n    const saltRounds = 12;\n    return await bcrypt.hash(password, saltRounds);\n  }\n  \n  static async verifyPassword(password, hash) {\n    return await bcrypt.compare(password, hash);\n  }\n  \n  static generateToken(userId) {\n    return jwt.sign(\n      { userId, iat: Date.now() },\n      process.env.JWT_SECRET,\n      { expiresIn: '24h' }\n    );\n  }\n  \n  static verifyToken(token) {\n    try {\n      return jwt.verify(token, process.env.JWT_SECRET);\n    } catch (error) {\n      throw new Error('Invalid token');\n    }\n  }\n}\n\n// Authentication middleware\nfunction authenticate(req, res, next) {\n  const authHeader = req.headers.authorization;\n  \n  if (!authHeader || !authHeader.startsWith('Bearer ')) {\n    return res.status(401).json({ error: 'No token provided' });\n  }\n  \n  const token = authHeader.substring(7);\n  \n  try {\n    const decoded = AuthService.verifyToken(token);\n    req.user = decoded;\n    next();\n  } catch (error) {\n    return res.status(401).json({ error: 'Invalid token' });\n  }\n}\n\n// SQL injection prevention with parameterized queries\nconst mysql = require('mysql2/promise');\n\nclass UserRepository {\n  static async findByEmail(email) {\n    const connection = await mysql.createConnection({\n      host: process.env.DB_HOST,\n      user: process.env.DB_USER,\n      password: process.env.DB_PASSWORD,\n      database: process.env.DB_NAME\n    });\n    \n    // Safe parameterized query\n    const [rows] = await connection.execute(\n      'SELECT * FROM users WHERE email = ?',\n      [email]\n    );\n    \n    await connection.end();\n    return rows[0];\n  }\n}\n\n// Secure routes\napp.post('/api/register', validateInput, async (req, res) => {\n  try {\n    const { email, password, name } = req.body;\n    \n    // Check if user exists\n    const existingUser = await UserRepository.findByEmail(email);\n    if (existingUser) {\n      return res.status(409).json({ error: 'User already exists' });\n    }\n    \n    // Hash password\n    const hashedPassword = await AuthService.hashPassword(password);\n    \n    // Create user (implementation depends on your database)\n    const user = await UserRepository.create({\n      email,\n      password: hashedPassword,\n      name\n    });\n    \n    // Generate token\n    const token = AuthService.generateToken(user.id);\n    \n    res.status(201).json({\n      message: 'User created successfully',\n      token\n    });\n  } catch (error) {\n    console.error('Registration error:', error);\n    res.status(500).json({ error: 'Internal server error' });\n  }\n});\n\napp.get('/api/profile', authenticate, (req, res) => {\n  res.json({\n    message: 'Protected profile data',\n    userId: req.user.userId\n  });\n});\n\n// Error handling middleware\napp.use((error, req, res, next) => {\n  console.error('Unhandled error:', error);\n  res.status(500).json({ error: 'Internal server error' });\n});\n\napp.listen(3000, () => {\n  console.log('Secure server running on port 3000');\n});",
                "explanation": "This example demonstrates comprehensive security practices including helmet for security headers, rate limiting, input validation and sanitization, secure password hashing, JWT authentication, and SQL injection prevention with parameterized queries.\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Storing passwords in plain text",
                  "solution": "Always hash passwords using bcrypt with appropriate salt rounds",
                  "severity": "high"
                },
                {
                  "mistake": "Not validating and sanitizing user input",
                  "solution": "Implement comprehensive input validation and XSS protection",
                  "severity": "high"
                },
                {
                  "mistake": "Using weak JWT secrets or not setting expiration",
                  "solution": "Use strong, randomly generated secrets and set appropriate token expiration times",
                  "severity": "medium"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Advanced Security Practices in Node.js",
                  "description": "Implement comprehensive security measures in a Node.js application",
                  "checkpoints": [
                    "Set up security middleware (helmet, rate limiting)",
                    "Implement secure authentication with password hashing",
                    "Add input validation and sanitization",
                    "Prevent SQL injection with parameterized queries",
                    "Test security measures and conduct vulnerability assessment"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 45,
              "difficulty": "Advanced",
              "tags": [
                "Security",
                "Authentication",
                "Validation",
                "node"
              ],
              "lastUpdated": "2025-10-01T06:41:13.484Z",
              "version": "1.0.0"
            },
            {
              "id": "node-fundamentals-lesson-14",
              "moduleSlug": "node-fundamentals",
              "title": "Microservices Architecture with Node.js",
              "order": 14,
              "objectives": [
                "Understand microservices architecture principles",
                "Implement service communication patterns",
                "Deploy and orchestrate Node.js microservices"
              ],
              "intro": "Welcome to this comprehensive lesson on Microservices Architecture with Node.js.\n\nLearn how to design, implement, and deploy microservices using Node.js. Microservices architecture enables building scalable, maintainable applications by breaking them into smaller, independent services.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "// User Service (users-service.js)\nconst express = require('express');\nconst axios = require('axios');\nconst app = express();\n\napp.use(express.json());\n\nconst users = [\n  { id: 1, name: 'John Doe', email: 'john@example.com' },\n  { id: 2, name: 'Jane Smith', email: 'jane@example.com' }\n];\n\napp.get('/health', (req, res) => {\n  res.json({ status: 'healthy', service: 'users' });\n});\n\napp.get('/users', (req, res) => {\n  res.json(users);\n});\n\napp.get('/users/:id', (req, res) => {\n  const user = users.find(u => u.id === parseInt(req.params.id));\n  if (!user) {\n    return res.status(404).json({ error: 'User not found' });\n  }\n  res.json(user);\n});\n\napp.listen(3001, () => console.log('Users service on port 3001'));\n\n// Orders Service (orders-service.js)\nconst express = require('express');\nconst axios = require('axios');\nconst app = express();\n\napp.use(express.json());\n\nconst orders = [\n  { id: 1, userId: 1, product: 'Laptop', amount: 999.99 },\n  { id: 2, userId: 2, product: 'Phone', amount: 599.99 }\n];\n\napp.get('/health', (req, res) => {\n  res.json({ status: 'healthy', service: 'orders' });\n});\n\napp.get('/orders', async (req, res) => {\n  try {\n    // Enrich orders with user data\n    const enrichedOrders = await Promise.all(\n      orders.map(async (order) => {\n        try {\n          const userResponse = await axios.get(\n            `http://users-service:3001/users/${order.userId}`,\n            { timeout: 5000 }\n          );\n          return {\n            ...order,\n            user: userResponse.data\n          };\n        } catch (error) {\n          console.error(`Failed to fetch user ${order.userId}:`, error.message);\n          return {\n            ...order,\n            user: { error: 'User data unavailable' }\n          };\n        }\n      })\n    );\n    \n    res.json(enrichedOrders);\n  } catch (error) {\n    res.status(500).json({ error: 'Failed to fetch orders' });\n  }\n});\n\napp.listen(3002, () => console.log('Orders service on port 3002'));\n\n// API Gateway (gateway.js)\nconst express = require('express');\nconst { createProxyMiddleware } = require('http-proxy-middleware');\nconst app = express();\n\napp.use(express.json());\n\n// Service discovery\nconst services = {\n  users: 'http://users-service:3001',\n  orders: 'http://orders-service:3002'\n};\n\n// Health check aggregator\napp.get('/health', async (req, res) => {\n  const healthChecks = await Promise.allSettled(\n    Object.entries(services).map(async ([name, url]) => {\n      try {\n        const response = await axios.get(`${url}/health`);\n        return { service: name, status: 'healthy', ...response.data };\n      } catch (error) {\n        return { service: name, status: 'unhealthy', error: error.message };\n      }\n    })\n  );\n  \n  res.json({\n    overall: healthChecks.every(hc => hc.value?.status === 'healthy') ? 'healthy' : 'degraded',\n    services: healthChecks.map(hc => hc.value)\n  });\n});\n\n// Route proxying\napp.use('/api/users', createProxyMiddleware({\n  target: services.users,\n  changeOrigin: true,\n  pathRewrite: { '^/api/users': '/users' },\n  onError: (err, req, res) => {\n    res.status(503).json({ error: 'Users service unavailable' });\n  }\n}));\n\napp.use('/api/orders', createProxyMiddleware({\n  target: services.orders,\n  changeOrigin: true,\n  pathRewrite: { '^/api/orders': '/orders' },\n  onError: (err, req, res) => {\n    res.status(503).json({ error: 'Orders service unavailable' });\n  }\n}));\n\napp.listen(3000, () => console.log('API Gateway on port 3000'));\n\n// Docker Compose (docker-compose.yml)\n/*\nversion: '3.8'\nservices:\n  users-service:\n    build: ./users-service\n    ports:\n      - \"3001:3001\"\n    environment:\n      - NODE_ENV=production\n    healthcheck:\n      test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:3001/health\"]\n      interval: 30s\n      timeout: 10s\n      retries: 3\n\n  orders-service:\n    build: ./orders-service\n    ports:\n      - \"3002:3002\"\n    depends_on:\n      - users-service\n    environment:\n      - NODE_ENV=production\n    healthcheck:\n      test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:3002/health\"]\n      interval: 30s\n      timeout: 10s\n      retries: 3\n\n  gateway:\n    build: ./gateway\n    ports:\n      - \"3000:3000\"\n    depends_on:\n      - users-service\n      - orders-service\n    environment:\n      - NODE_ENV=production\n*/",
                "explanation": "This example demonstrates a complete microservices architecture with separate user and order services, an API gateway for routing, service communication with circuit breakers, and Docker orchestration for deployment.\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Creating too many small services (nano-services)",
                  "solution": "Design services around business domains, not just code organization",
                  "severity": "medium"
                },
                {
                  "mistake": "Not implementing proper service communication patterns",
                  "solution": "Use circuit breakers, timeouts, and fallback mechanisms for resilient communication",
                  "severity": "high"
                },
                {
                  "mistake": "Lack of distributed tracing and monitoring",
                  "solution": "Implement comprehensive logging, monitoring, and distributed tracing across services",
                  "severity": "medium"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Microservices Architecture with Node.js",
                  "description": "Design and implement a microservices architecture using Node.js",
                  "checkpoints": [
                    "Design service boundaries based on business domains",
                    "Implement service communication with circuit breakers",
                    "Set up API gateway for routing and load balancing",
                    "Configure Docker containers and orchestration",
                    "Implement monitoring and health checks"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 50,
              "difficulty": "Advanced",
              "tags": [
                "Microservices",
                "Architecture",
                "Docker",
                "node"
              ],
              "lastUpdated": "2025-10-01T06:41:13.484Z",
              "version": "1.0.0"
            },
            {
              "id": "node-fundamentals-lesson-15",
              "moduleSlug": "node-fundamentals",
              "title": "Production Deployment and DevOps for Node.js",
              "order": 15,
              "objectives": [
                "Configure production-ready Node.js applications",
                "Implement CI/CD pipelines for Node.js deployment",
                "Monitor and maintain Node.js applications in production"
              ],
              "intro": "Welcome to this comprehensive lesson on Production Deployment and DevOps for Node.js.\n\nLearn how to deploy Node.js applications to production environments with proper configuration, monitoring, and automation. Production deployment requires careful consideration of performance, security, and reliability.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "// Production configuration (config/production.js)\nmodule.exports = {\n  port: process.env.PORT || 3000,\n  nodeEnv: 'production',\n  database: {\n    host: process.env.DB_HOST,\n    port: process.env.DB_PORT || 5432,\n    name: process.env.DB_NAME,\n    user: process.env.DB_USER,\n    password: process.env.DB_PASSWORD,\n    ssl: true,\n    pool: {\n      min: 5,\n      max: 20,\n      acquireTimeoutMillis: 60000,\n      idleTimeoutMillis: 600000\n    }\n  },\n  redis: {\n    host: process.env.REDIS_HOST,\n    port: process.env.REDIS_PORT || 6379,\n    password: process.env.REDIS_PASSWORD\n  },\n  jwt: {\n    secret: process.env.JWT_SECRET,\n    expiresIn: '24h'\n  },\n  logging: {\n    level: 'info',\n    format: 'json'\n  }\n};\n\n// Production server setup (server.js)\nconst express = require('express');\nconst cluster = require('cluster');\nconst os = require('os');\nconst winston = require('winston');\nconst helmet = require('helmet');\nconst compression = require('compression');\nconst cors = require('cors');\nconst config = require('./config/production');\n\n// Configure Winston logger\nconst logger = winston.createLogger({\n  level: config.logging.level,\n  format: winston.format.combine(\n    winston.format.timestamp(),\n    winston.format.errors({ stack: true }),\n    winston.format.json()\n  ),\n  transports: [\n    new winston.transports.Console(),\n    new winston.transports.File({ filename: 'logs/error.log', level: 'error' }),\n    new winston.transports.File({ filename: 'logs/combined.log' })\n  ]\n});\n\nif (cluster.isMaster) {\n  // Master process - create worker processes\n  const numCPUs = os.cpus().length;\n  logger.info(`Master process starting with ${numCPUs} workers`);\n  \n  for (let i = 0; i < numCPUs; i++) {\n    cluster.fork();\n  }\n  \n  cluster.on('exit', (worker, code, signal) => {\n    logger.error(`Worker ${worker.process.pid} died. Restarting...`);\n    cluster.fork();\n  });\n} else {\n  // Worker process\n  const app = express();\n  \n  // Production middleware\n  app.use(helmet());\n  app.use(compression());\n  app.use(cors());\n  app.use(express.json({ limit: '10mb' }));\n  \n  // Request logging\n  app.use((req, res, next) => {\n    logger.info({\n      method: req.method,\n      url: req.url,\n      ip: req.ip,\n      userAgent: req.get('User-Agent')\n    });\n    next();\n  });\n  \n  // Health check endpoint\n  app.get('/health', (req, res) => {\n    res.json({\n      status: 'healthy',\n      timestamp: new Date().toISOString(),\n      uptime: process.uptime(),\n      memory: process.memoryUsage(),\n      pid: process.pid\n    });\n  });\n  \n  // Graceful shutdown\n  process.on('SIGTERM', () => {\n    logger.info('SIGTERM received, shutting down gracefully');\n    server.close(() => {\n      logger.info('Process terminated');\n      process.exit(0);\n    });\n  });\n  \n  const server = app.listen(config.port, () => {\n    logger.info(`Worker ${process.pid} listening on port ${config.port}`);\n  });\n}\n\n// Dockerfile\n/*\nFROM node:18-alpine\n\nWORKDIR /app\n\n# Copy package files\nCOPY package*.json ./\n\n# Install dependencies\nRUN npm ci --only=production && npm cache clean --force\n\n# Copy application code\nCOPY . .\n\n# Create non-root user\nRUN addgroup -g 1001 -S nodejs\nRUN adduser -S nodejs -u 1001\n\n# Change ownership\nRUN chown -R nodejs:nodejs /app\nUSER nodejs\n\nEXPOSE 3000\n\nHEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \\\n  CMD node healthcheck.js\n\nCMD [\"node\", \"server.js\"]\n*/\n\n// CI/CD Pipeline (GitHub Actions)\n/*\nname: Deploy to Production\n\non:\n  push:\n    branches: [main]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - name: Setup Node.js\n        uses: actions/setup-node@v2\n        with:\n          node-version: '18'\n          cache: 'npm'\n      - name: Install dependencies\n        run: npm ci\n      - name: Run tests\n        run: npm test\n      - name: Run security audit\n        run: npm audit --audit-level=high\n\n  deploy:\n    needs: test\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - name: Build Docker image\n        run: docker build -t myapp:${{ github.sha }} .\n      - name: Deploy to production\n        run: |\n          # Deploy to your production environment\n          # This could be AWS ECS, Kubernetes, etc.\n*/\n\n// Monitoring with Prometheus metrics\nconst promClient = require('prom-client');\n\n// Create metrics\nconst httpRequestDuration = new promClient.Histogram({\n  name: 'http_request_duration_seconds',\n  help: 'Duration of HTTP requests in seconds',\n  labelNames: ['method', 'status_code', 'route']\n});\n\nconst httpRequestsTotal = new promClient.Counter({\n  name: 'http_requests_total',\n  help: 'Total number of HTTP requests',\n  labelNames: ['method', 'status_code', 'route']\n});\n\n// Middleware to collect metrics\napp.use((req, res, next) => {\n  const start = Date.now();\n  \n  res.on('finish', () => {\n    const duration = (Date.now() - start) / 1000;\n    const route = req.route ? req.route.path : req.path;\n    \n    httpRequestDuration\n      .labels(req.method, res.statusCode, route)\n      .observe(duration);\n    \n    httpRequestsTotal\n      .labels(req.method, res.statusCode, route)\n      .inc();\n  });\n  \n  next();\n});\n\n// Metrics endpoint\napp.get('/metrics', (req, res) => {\n  res.set('Content-Type', promClient.register.contentType);\n  res.end(promClient.register.metrics());\n});",
                "explanation": "This example demonstrates comprehensive production deployment including clustering for scalability, structured logging with Winston, Docker containerization, CI/CD pipeline configuration, and monitoring with Prometheus metrics.\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not implementing proper logging in production",
                  "solution": "Use structured logging with appropriate log levels and centralized log aggregation",
                  "severity": "high"
                },
                {
                  "mistake": "Running single-threaded in production",
                  "solution": "Use cluster mode or PM2 to utilize multiple CPU cores",
                  "severity": "medium"
                },
                {
                  "mistake": "Not implementing health checks and graceful shutdown",
                  "solution": "Implement comprehensive health checks and handle SIGTERM for graceful shutdown",
                  "severity": "high"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Production Deployment and DevOps for Node.js",
                  "description": "Deploy a Node.js application to production with proper DevOps practices",
                  "checkpoints": [
                    "Configure production environment variables and settings",
                    "Implement clustering and process management",
                    "Set up Docker containerization and health checks",
                    "Configure CI/CD pipeline with automated testing",
                    "Implement monitoring, logging, and alerting"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 55,
              "difficulty": "Advanced",
              "tags": [
                "Production",
                "DevOps",
                "Deployment",
                "Monitoring",
                "node"
              ],
              "lastUpdated": "2025-10-01T06:41:13.484Z",
              "version": "1.0.0"
            }
          ],
          "issues": []
        },
        "quiz": {
          "exists": true,
          "count": 20,
          "questions": [
            {
              "id": "node-fundamentals-q1",
              "question": "What is Node.js?",
              "topic": "Basics",
              "difficulty": "Beginner",
              "choices": [
                "A JavaScript runtime built on Chrome's V8 JavaScript engine",
                "A CSS framework",
                "A database management system",
                "A front-end framework"
              ],
              "correctIndex": 0,
              "explanation": "Node.js is a JavaScript runtime that allows you to run JavaScript on the server-side, built on Chrome's V8 JavaScript engine.",
              "industryContext": "Node.js is essential for modern backend development and tooling.",
              "tags": [
                "Basics",
                "beginner",
                "node"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 1,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.484Z"
              }
            },
            {
              "id": "node-fundamentals-q2",
              "question": "How do you import a module in Node.js?",
              "topic": "Basics",
              "difficulty": "Beginner",
              "choices": [
                "require()",
                "import",
                "include",
                "load"
              ],
              "correctIndex": 0,
              "explanation": "In Node.js, modules are imported using the require() function. The import statement is used in ES6 modules.",
              "industryContext": "Node.js is essential for modern backend development and tooling.",
              "tags": [
                "Basics",
                "beginner",
                "node"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 2,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.484Z"
              }
            },
            {
              "id": "node-fundamentals-q3",
              "question": "What is Express.js and why is it used?",
              "topic": "Express",
              "difficulty": "Beginner",
              "choices": [
                "Open-ended question - no multiple choice",
                "This is a conceptual question",
                "Answer requires explanation",
                "Multiple approaches possible"
              ],
              "correctIndex": 0,
              "explanation": "Express.js is a minimal and flexible Node.js web application framework that provides a robust set of features for web and mobile applications. It simplifies the process of building web servers and APIs by providing helpful utilities and middleware.",
              "industryContext": "Node.js is essential for modern backend development and tooling.",
              "tags": [
                "Express",
                "beginner",
                "node"
              ],
              "questionType": "open-ended",
              "estimatedTime": 180,
              "legacy": {
                "originalId": 3,
                "originalType": "open-ended",
                "migrated": "2025-10-01T06:41:13.484Z"
              }
            },
            {
              "id": "node-fundamentals-q4",
              "question": "Which method is used to handle GET requests in Express?",
              "topic": "Express",
              "difficulty": "Intermediate",
              "choices": [
                "app.get()",
                "app.post()",
                "app.put()",
                "app.delete()"
              ],
              "correctIndex": 0,
              "explanation": "In Express.js, app.get() is used to define a route handler for GET requests.",
              "industryContext": "Node.js is essential for modern backend development and tooling.",
              "tags": [
                "Express",
                "intermediate",
                "node"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 4,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.484Z"
              }
            },
            {
              "id": "node-fundamentals-q5",
              "question": "What is middleware in Express.js?",
              "topic": "Middleware",
              "difficulty": "Beginner",
              "choices": [
                "Functions that have access to the request and response objects",
                "Database connection utilities",
                "Template engines",
                "Routing functions"
              ],
              "correctIndex": 0,
              "explanation": "Middleware functions in Express.js are functions that have access to the request object, the response object, and the next middleware function in the application's request-response cycle.",
              "industryContext": "Node.js is essential for modern backend development and tooling.",
              "tags": [
                "Middleware",
                "beginner",
                "node"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 5,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.484Z"
              }
            },
            {
              "id": "node-fundamentals-q6",
              "question": "How do you handle asynchronous operations in Node.js?",
              "topic": "Async",
              "difficulty": "Beginner",
              "choices": [
                "Using callbacks, promises, or async/await",
                "Using synchronous functions only",
                "Using threads",
                "Using global variables"
              ],
              "correctIndex": 0,
              "explanation": "Node.js handles asynchronous operations using callbacks, promises, or the more modern async/await syntax.",
              "industryContext": "Node.js is essential for modern backend development and tooling.",
              "tags": [
                "Async",
                "beginner",
                "node"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 6,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.484Z"
              }
            },
            {
              "id": "node-fundamentals-q7",
              "question": "What is NPM and what is it used for?",
              "topic": "NPM",
              "difficulty": "Beginner",
              "choices": [
                "Open-ended question - no multiple choice",
                "This is a conceptual question",
                "Answer requires explanation",
                "Multiple approaches possible"
              ],
              "correctIndex": 0,
              "explanation": "NPM (Node Package Manager) is the default package manager for Node.js. It is used to install, share, and manage packages (libraries and tools) in Node.js projects. It also helps with dependency management and script execution.",
              "industryContext": "Node.js is essential for modern backend development and tooling.",
              "tags": [
                "NPM",
                "beginner",
                "node"
              ],
              "questionType": "open-ended",
              "estimatedTime": 180,
              "legacy": {
                "originalId": 7,
                "originalType": "open-ended",
                "migrated": "2025-10-01T06:41:13.484Z"
              }
            },
            {
              "id": "node-fundamentals-q8",
              "question": "What is the event loop in Node.js?",
              "topic": "Event Loop",
              "difficulty": "Beginner",
              "choices": [
                "A mechanism that handles asynchronous operations",
                "A loop that executes synchronous code",
                "A database query optimizer",
                "A memory management system"
              ],
              "correctIndex": 0,
              "explanation": "The event loop in Node.js is a mechanism that handles asynchronous operations by continuously checking the call stack and callback queue to execute callbacks when the call stack is empty.",
              "industryContext": "Node.js is essential for modern backend development and tooling.",
              "tags": [
                "Event Loop",
                "beginner",
                "node"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 8,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.484Z"
              }
            },
            {
              "id": "node-fundamentals-q9",
              "question": "What is the main advantage of using async/await over Promises in Node.js?",
              "topic": "Async Programming",
              "difficulty": "Beginner",
              "choices": [
                "More readable and easier to debug synchronous-looking code",
                "Better performance than Promises",
                "Automatic error handling without try-catch",
                "Faster execution than callback functions"
              ],
              "correctIndex": 0,
              "explanation": "Async/await provides more readable, synchronous-looking code that's easier to debug and maintain. While it doesn't improve performance over Promises (it's syntactic sugar over them), it makes error handling with try-catch more natural and reduces callback hell and Promise chaining complexity.",
              "industryContext": "Node.js is essential for modern backend development and tooling.",
              "tags": [
                "Async Programming",
                "beginner",
                "node"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 9,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.484Z"
              }
            },
            {
              "id": "node-fundamentals-q10",
              "question": "What is clustering in Node.js and why is it useful?",
              "topic": "Performance",
              "difficulty": "Beginner",
              "choices": [
                "Running multiple Node.js processes to utilize all CPU cores",
                "Grouping related modules together",
                "Connecting multiple databases",
                "Organizing code into clusters of functions"
              ],
              "correctIndex": 0,
              "explanation": "Clustering in Node.js allows you to create multiple worker processes that share the same server port, enabling utilization of all CPU cores. Since Node.js is single-threaded, clustering helps improve performance for CPU-intensive applications by distributing the workload across multiple processes.",
              "industryContext": "Node.js is essential for modern backend development and tooling.",
              "tags": [
                "Performance",
                "beginner",
                "node"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 10,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.484Z"
              }
            },
            {
              "id": "node-fundamentals-q11",
              "question": "What are some essential security practices for Node.js applications?",
              "topic": "Security",
              "difficulty": "Intermediate",
              "choices": [
                "Open-ended question - no multiple choice",
                "This is a conceptual question",
                "Answer requires explanation",
                "Multiple approaches possible"
              ],
              "correctIndex": 0,
              "explanation": "Essential security practices include: using HTTPS everywhere, validating and sanitizing all input, implementing proper authentication and authorization, using helmet.js for security headers, rate limiting, keeping dependencies updated, using environment variables for secrets, implementing CSRF protection, using secure session management, and regular security audits with tools like npm audit.",
              "industryContext": "Node.js is essential for modern backend development and tooling.",
              "tags": [
                "Security",
                "intermediate",
                "node"
              ],
              "questionType": "open-ended",
              "estimatedTime": 180,
              "legacy": {
                "originalId": 11,
                "originalType": "open-ended",
                "migrated": "2025-10-01T06:41:13.484Z"
              }
            },
            {
              "id": "node-fundamentals-q12",
              "question": "Which testing framework is most commonly used for Node.js applications?",
              "topic": "Testing",
              "difficulty": "Intermediate",
              "choices": [
                "Jest",
                "JUnit",
                "PHPUnit",
                "NUnit"
              ],
              "correctIndex": 0,
              "explanation": "Jest is the most popular testing framework for Node.js applications. It provides a comprehensive testing solution with built-in test runner, assertion library, mocking capabilities, and code coverage reporting. Other popular options include Mocha and Chai, but Jest has gained widespread adoption due to its simplicity and feature completeness.",
              "industryContext": "Node.js is essential for modern backend development and tooling.",
              "tags": [
                "Testing",
                "intermediate",
                "node"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 12,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.484Z"
              }
            },
            {
              "id": "node-fundamentals-q13",
              "question": "What is the difference between fs.readFile() and fs.readFileSync() in Node.js?",
              "topic": "File System",
              "difficulty": "Beginner",
              "choices": [
                "readFile() is asynchronous and non-blocking, readFileSync() is synchronous and blocking",
                "readFile() is faster than readFileSync()",
                "readFileSync() supports more file formats",
                "readFile() requires more memory than readFileSync()"
              ],
              "correctIndex": 0,
              "explanation": "fs.readFile() is asynchronous and non-blocking, allowing other operations to continue while the file is being read. fs.readFileSync() is synchronous and blocks the event loop until the file reading is complete. The async version is preferred in production applications to maintain performance and responsiveness.",
              "industryContext": "Node.js is essential for modern backend development and tooling.",
              "tags": [
                "File System",
                "beginner",
                "node"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 13,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.484Z"
              }
            },
            {
              "id": "node-fundamentals-q14",
              "question": "How should you handle uncaught exceptions in Node.js applications?",
              "topic": "Error Handling",
              "difficulty": "Intermediate",
              "choices": [
                "Open-ended question - no multiple choice",
                "This is a conceptual question",
                "Answer requires explanation",
                "Multiple approaches possible"
              ],
              "correctIndex": 0,
              "explanation": "Handle uncaught exceptions by: 1) Using process.on('uncaughtException') to log errors and gracefully shut down, 2) Using process.on('unhandledRejection') for unhandled Promise rejections, 3) Implementing proper error handling in all async operations, 4) Using try-catch blocks around critical code, 5) Using process managers like PM2 for automatic restarts, 6) Logging all errors for debugging. Never ignore uncaught exceptions as they can lead to memory leaks and unstable applications.",
              "industryContext": "Node.js is essential for modern backend development and tooling.",
              "tags": [
                "Error Handling",
                "intermediate",
                "node"
              ],
              "questionType": "open-ended",
              "estimatedTime": 180,
              "legacy": {
                "originalId": 14,
                "originalType": "open-ended",
                "migrated": "2025-10-01T06:41:13.484Z"
              }
            },
            {
              "id": "node-fundamentals-q15",
              "question": "What is the main advantage of using streams for processing large files in Node.js?",
              "topic": "Streams",
              "difficulty": "Beginner",
              "choices": [
                "Memory efficient processing of data in chunks",
                "Faster file compression",
                "Better error handling",
                "Automatic file backup"
              ],
              "correctIndex": 0,
              "explanation": "Streams allow memory-efficient processing of large files by reading and processing data in small chunks rather than loading the entire file into memory. This prevents memory overflow issues and enables processing of files larger than available RAM, making applications more scalable and efficient.",
              "industryContext": "Node.js is essential for modern backend development and tooling.",
              "tags": [
                "Streams",
                "beginner",
                "node"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 15,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.484Z"
              }
            },
            {
              "id": "node-fundamentals-q16",
              "question": "What are the key security considerations when developing Node.js applications?",
              "topic": "Security",
              "difficulty": "Advanced",
              "choices": [
                "Open-ended question - no multiple choice",
                "This is a conceptual question",
                "Answer requires explanation",
                "Multiple approaches possible"
              ],
              "correctIndex": 0,
              "explanation": "Key security considerations include: input validation and sanitization to prevent XSS and injection attacks, secure password hashing with bcrypt, proper authentication and authorization, rate limiting to prevent DoS attacks, using HTTPS and security headers (helmet), keeping dependencies updated, implementing proper error handling without exposing sensitive information, and using environment variables for secrets.",
              "industryContext": "Security is critical for production Node.js applications, especially in enterprise environments handling sensitive data.",
              "tags": [
                "Security",
                "advanced",
                "node"
              ],
              "questionType": "open-ended",
              "estimatedTime": 180
            },
            {
              "id": "node-fundamentals-q17",
              "question": "What is the difference between process.nextTick() and setImmediate() in Node.js?",
              "topic": "Event Loop",
              "difficulty": "Advanced",
              "choices": [
                "process.nextTick() executes before I/O events, setImmediate() executes after",
                "setImmediate() executes before I/O events, process.nextTick() executes after",
                "Both execute at the same time",
                "They are identical functions"
              ],
              "correctIndex": 0,
              "explanation": "process.nextTick() has higher priority and executes callbacks before I/O events in the same phase, while setImmediate() executes callbacks after I/O events. process.nextTick() can potentially starve I/O if overused.",
              "industryContext": "Understanding event loop mechanics is crucial for writing performant Node.js applications.",
              "tags": [
                "Event Loop",
                "advanced",
                "node"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 120
            },
            {
              "id": "node-fundamentals-q18",
              "question": "How do you implement clustering in Node.js and why is it important?",
              "topic": "Performance",
              "difficulty": "Advanced",
              "choices": [
                "Using the cluster module to fork worker processes",
                "Using threads with the worker_threads module",
                "Using external load balancers only",
                "Node.js automatically handles clustering"
              ],
              "correctIndex": 0,
              "explanation": "Clustering in Node.js is implemented using the cluster module, which allows you to fork multiple worker processes that share the same server port. This is important because Node.js is single-threaded by default, so clustering allows utilization of multiple CPU cores for better performance.",
              "industryContext": "Clustering is essential for production Node.js applications to maximize server resource utilization.",
              "tags": [
                "Performance",
                "advanced",
                "node"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 120
            },
            {
              "id": "node-fundamentals-q19",
              "question": "What are the benefits and challenges of microservices architecture with Node.js?",
              "topic": "Architecture",
              "difficulty": "Advanced",
              "choices": [
                "Open-ended question - no multiple choice",
                "This is a conceptual question",
                "Answer requires explanation",
                "Multiple approaches possible"
              ],
              "correctIndex": 0,
              "explanation": "Benefits include: independent deployment and scaling, technology diversity, fault isolation, and team autonomy. Challenges include: increased complexity in service communication, distributed system challenges (consistency, monitoring), network latency, data consistency across services, and operational overhead. Node.js is well-suited for microservices due to its lightweight nature and excellent I/O handling.",
              "industryContext": "Microservices architecture is widely adopted in enterprise environments for scalable, maintainable applications.",
              "tags": [
                "Architecture",
                "advanced",
                "node"
              ],
              "questionType": "open-ended",
              "estimatedTime": 180
            },
            {
              "id": "node-fundamentals-q20",
              "question": "What tools and practices are essential for production deployment of Node.js applications?",
              "topic": "DevOps",
              "difficulty": "Advanced",
              "choices": [
                "Process managers, monitoring, logging, and containerization",
                "Only Docker containers",
                "Just environment variables",
                "Basic server setup is sufficient"
              ],
              "correctIndex": 0,
              "explanation": "Essential tools and practices include: process managers (PM2, cluster), comprehensive monitoring (Prometheus, New Relic), structured logging (Winston), containerization (Docker), CI/CD pipelines, health checks, graceful shutdowns, security headers, and load balancing. These ensure reliability, scalability, and maintainability in production.",
              "industryContext": "Production deployment requires robust DevOps practices to ensure application reliability and performance.",
              "tags": [
                "DevOps",
                "advanced",
                "node"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 120
            }
          ],
          "issues": []
        },
        "meetsThresholds": true,
        "issues": []
      },
      "laravel-fundamentals": {
        "slug": "laravel-fundamentals",
        "title": "Laravel Framework",
        "tier": "core",
        "track": "Backend",
        "difficulty": "Intermediate",
        "thresholds": {
          "requiredLessons": 16,
          "requiredQuestions": 22
        },
        "lessons": {
          "exists": true,
          "count": 16,
          "lessons": [
            {
              "id": "laravel-fundamentals-lesson-1",
              "moduleSlug": "laravel-fundamentals",
              "title": "Basic Routing in Laravel",
              "order": 1,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to the foundational world of Laravel routing - the cornerstone of web application navigation and request handling in one of PHP's most elegant frameworks. Laravel's routing system provides an intuitive, expressive syntax that transforms complex URL patterns into clean, maintainable code structures that power modern web applications.\n\nRouting in Laravel serves as the traffic control system for your application, determining how incoming HTTP requests are directed to the appropriate controllers, closures, or resources. Understanding Laravel's routing capabilities is essential for building scalable web applications, as it provides the foundation for RESTful APIs, resource controllers, and complex application architectures.\n\nIn this comprehensive introduction, you'll master the fundamental concepts of route definition, from basic GET and POST routes to more advanced patterns involving route parameters, middleware integration, and route model binding. Laravel's routing system supports HTTP verbs, route groups, and subdomain routing, providing flexibility for everything from simple websites to complex enterprise applications.\n\nThe knowledge you gain here forms the backbone of Laravel development, enabling you to create intuitive URL structures, implement proper separation of concerns, and build applications that follow web standards and best practices. Every subsequent Laravel concept builds upon these routing fundamentals.\n\nBy the end of this lesson, you'll confidently navigate Laravel's routing landscape, understanding how to structure URLs that are both user-friendly and SEO-optimized while maintaining clean, readable code that scales with your application's growth.",
              "code": {
                "example": "<?php\n// routes/web.php\n\nuse Illuminate\\Support\\Facades\\Route;\n\nRoute::get('/', function () {\n    return view('welcome');\n});\n\nRoute::get('/users', function () {\n    return 'All users';\n});",
                "explanation": "This example produces: Route definitions registered successfully\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "php"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Basic Routing in Laravel",
                  "description": "Apply the concepts from this lesson on Routing",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Beginner",
              "tags": [
                "Routing",
                "laravel"
              ],
              "legacy": {
                "originalId": 1,
                "originalTopic": "Routing",
                "migrated": "2025-10-01T06:41:13.484Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.484Z",
              "version": "1.0.0"
            },
            {
              "id": "laravel-fundamentals-lesson-2",
              "moduleSlug": "laravel-fundamentals",
              "title": "Route Parameters",
              "order": 2,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Routing.\n\nLearn how to capture segments of the URI in Laravel routes.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "<?php\n// routes/web.php\n\nuse Illuminate\\Support\\Facades\\Route;\n\nRoute::get('/user/{id}', function ($id) {\n    return 'User '.$id;\n});\n\nRoute::get('/posts/{post}/comments/{comment}', function ($postId, $commentId) {\n    //\n});",
                "explanation": "This example produces: Route with parameters registered successfully\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "php"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Route Parameters",
                  "description": "Apply the concepts from this lesson on Routing",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Routing",
                "laravel"
              ],
              "legacy": {
                "originalId": 2,
                "originalTopic": "Routing",
                "migrated": "2025-10-01T06:41:13.484Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.484Z",
              "version": "1.0.0"
            },
            {
              "id": "laravel-fundamentals-lesson-3",
              "moduleSlug": "laravel-fundamentals",
              "title": "Introduction to Eloquent",
              "order": 3,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Eloquent ORM.\n\nLearn how to work with database records using Eloquent ORM.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "<?php\n// app/Models/User.php\n\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Factories\\HasFactory;\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass User extends Model\n{\n    use HasFactory;\n\n    protected $fillable = [\n        'name',\n        'email',\n        'password',\n    ];\n}",
                "explanation": "This example produces: Eloquent model created successfully\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "php"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Introduction to Eloquent",
                  "description": "Apply the concepts from this lesson on Eloquent ORM",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Beginner",
              "tags": [
                "Eloquent ORM",
                "laravel"
              ],
              "legacy": {
                "originalId": 3,
                "originalTopic": "Eloquent ORM",
                "migrated": "2025-10-01T06:41:13.484Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.484Z",
              "version": "1.0.0"
            },
            {
              "id": "laravel-fundamentals-lesson-4",
              "moduleSlug": "laravel-fundamentals",
              "title": "Querying Models",
              "order": 4,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Eloquent ORM.\n\nLearn how to retrieve records from the database using Eloquent.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "<?php\n// Retrieving models\n\nuse App\\Models\\User;\n\n$users = User::all();\n\n$user = User::find(1);\n\n$users = User::where('active', 1)->orderBy('name')->get();",
                "explanation": "This example produces: Users retrieved successfully\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "php"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Querying Models",
                  "description": "Apply the concepts from this lesson on Eloquent ORM",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Eloquent ORM",
                "laravel"
              ],
              "legacy": {
                "originalId": 4,
                "originalTopic": "Eloquent ORM",
                "migrated": "2025-10-01T06:41:13.484Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.484Z",
              "version": "1.0.0"
            },
            {
              "id": "laravel-fundamentals-lesson-5",
              "moduleSlug": "laravel-fundamentals",
              "title": "Blade Basics",
              "order": 5,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Blade Templates.\n\nLearn how to create dynamic views using Blade templating engine.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "<!-- resources/views/welcome.blade.php -->\n\n<!DOCTYPE html>\n<html>\n<head>\n    <title>App Name - @yield('title')</title>\n</head>\n<body>\n    @section('sidebar')\n        This is the master sidebar.\n    @show\n\n    <div class=\"container\">\n        @yield('content')\n    </div>\n</body>\n</html>",
                "explanation": "This example produces: Blade template rendered successfully\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "php"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Blade Basics",
                  "description": "Apply the concepts from this lesson on Blade Templates",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Beginner",
              "tags": [
                "Blade Templates",
                "laravel"
              ],
              "legacy": {
                "originalId": 5,
                "originalTopic": "Blade Templates",
                "migrated": "2025-10-01T06:41:13.484Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.484Z",
              "version": "1.0.0"
            },
            {
              "id": "laravel-fundamentals-lesson-6",
              "moduleSlug": "laravel-fundamentals",
              "title": "Blade Control Structures",
              "order": 6,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Blade Templates.\n\nLearn how to use control structures in Blade templates.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "@if (count($records) === 1)\n    I have one record!\n@elseif (count($records) > 1)\n    I have multiple records!\n@else\n    I don't have any records!\n@endif\n\n@foreach ($users as $user)\n    <p>This is user {{ $user->id }}</p>\n@endforeach",
                "explanation": "This example produces: Blade control structures executed successfully\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "php"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Blade Control Structures",
                  "description": "Apply the concepts from this lesson on Blade Templates",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Blade Templates",
                "laravel"
              ],
              "legacy": {
                "originalId": 6,
                "originalTopic": "Blade Templates",
                "migrated": "2025-10-01T06:41:13.484Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.484Z",
              "version": "1.0.0"
            },
            {
              "id": "laravel-fundamentals-lesson-7",
              "moduleSlug": "laravel-fundamentals",
              "title": "Creating Middleware",
              "order": 7,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Middleware.\n\nLearn how to create and register custom middleware in Laravel.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "<?php\n// app/Http/Middleware/EnsureTokenIsValid.php\n\nnamespace App\\Http\\Middleware;\n\nuse Closure;\n\nclass EnsureTokenIsValid\n{\n    public function handle($request, Closure $next)\n    {\n        if ($request->input('token') !== 'my-secret-token') {\n            return redirect('home');\n        }\n\n        return $next($request);\n    }\n}",
                "explanation": "This example produces: Middleware created successfully\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "php"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Creating Middleware",
                  "description": "Apply the concepts from this lesson on Middleware",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Advanced",
              "tags": [
                "Middleware",
                "laravel"
              ],
              "legacy": {
                "originalId": 7,
                "originalTopic": "Middleware",
                "migrated": "2025-10-01T06:41:13.484Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.484Z",
              "version": "1.0.0"
            },
            {
              "id": "laravel-fundamentals-lesson-8",
              "moduleSlug": "laravel-fundamentals",
              "title": "Registering Middleware",
              "order": 8,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Middleware.\n\nLearn how to register middleware in Laravel applications.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "<?php\n// app/Http/Kernel.php\n\nprotected $routeMiddleware = [\n    // ...\n    'token' => \\App\\Http\\Middleware\\EnsureTokenIsValid::class,\n];\n\n// In routes\nRoute::get('/profile', function () {\n    //\n})->middleware('token');",
                "explanation": "This example produces: Middleware registered successfully\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "php"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Registering Middleware",
                  "description": "Apply the concepts from this lesson on Middleware",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Middleware",
                "laravel"
              ],
              "legacy": {
                "originalId": 8,
                "originalTopic": "Middleware",
                "migrated": "2025-10-01T06:41:13.484Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.484Z",
              "version": "1.0.0"
            },
            {
              "id": "laravel-fundamentals-lesson-9",
              "moduleSlug": "laravel-fundamentals",
              "title": "Migrations",
              "order": 9,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Database.\n\nLearn how to create and run database migrations in Laravel.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "<?php\n// Creating a migration\nphp artisan make:migration create_flights_table\n\n// Migration file\nSchema::create('flights', function (Blueprint $table) {\n    $table->id();\n    $table->string('name');\n    $table->text('description');\n    $table->timestamps();\n});",
                "explanation": "This example produces: Migration created and executed successfully\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "php"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Migrations",
                  "description": "Apply the concepts from this lesson on Database",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Database",
                "laravel"
              ],
              "legacy": {
                "originalId": 9,
                "originalTopic": "Database",
                "migrated": "2025-10-01T06:41:13.484Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.484Z",
              "version": "1.0.0"
            },
            {
              "id": "laravel-fundamentals-lesson-10",
              "moduleSlug": "laravel-fundamentals",
              "title": "Seeding Data",
              "order": 10,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Database.\n\nLearn how to seed your database with test data in Laravel.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "<?php\n// Creating a seeder\nphp artisan make:seeder UsersTableSeeder\n\n// In the seeder\npublic function run()\n{\n    DB::table('users')->insert([\n        'name' => Str::random(10),\n        'email' => Str::random(10).'@gmail.com',\n        'password' => Hash::make('password'),\n    ]);\n}",
                "explanation": "This example produces: Database seeded successfully\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "php"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Seeding Data",
                  "description": "Apply the concepts from this lesson on Database",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Database",
                "laravel"
              ],
              "legacy": {
                "originalId": 10,
                "originalTopic": "Database",
                "migrated": "2025-10-01T06:41:13.484Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.484Z",
              "version": "1.0.0"
            },
            {
              "id": "laravel-fundamentals-lesson-11",
              "moduleSlug": "laravel-fundamentals",
              "title": "Laravel Breeze",
              "order": 11,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Authentication.\n\nLearn how to implement authentication using Laravel Breeze.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "// Install Laravel Breeze\ncomposer require laravel/breeze --dev\n\n// Install Breeze scaffolding\nphp artisan breeze:install\n\n// Run migrations\nphp artisan migrate",
                "explanation": "This example produces: Authentication scaffolding installed successfully\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "php"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Laravel Breeze",
                  "description": "Apply the concepts from this lesson on Authentication",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Authentication",
                "laravel"
              ],
              "legacy": {
                "originalId": 11,
                "originalTopic": "Authentication",
                "migrated": "2025-10-01T06:41:13.484Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.484Z",
              "version": "1.0.0"
            },
            {
              "id": "laravel-fundamentals-lesson-12",
              "moduleSlug": "laravel-fundamentals",
              "title": "API Authentication",
              "order": 12,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Authentication.\n\nLearn how to authenticate API requests in Laravel.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "<?php\n// In routes/api.php\n\nRoute::middleware('auth:sanctum')->get('/user', function (Request $request) {\n    return $request->user();\n});\n\n// In controller\npublic function index(Request $request)\n{\n    return $request->user();\n}",
                "explanation": "This example produces: API authentication configured successfully\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "php"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: API Authentication",
                  "description": "Apply the concepts from this lesson on Authentication",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Authentication",
                "laravel"
              ],
              "legacy": {
                "originalId": 12,
                "originalTopic": "Authentication",
                "migrated": "2025-10-01T06:41:13.484Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.484Z",
              "version": "1.0.0"
            },
            {
              "id": "laravel-fundamentals-lesson-13",
              "moduleSlug": "laravel-fundamentals",
              "title": "Form Validation",
              "order": 13,
              "objectives": [
                "Implement comprehensive form validation in Laravel applications",
                "Create custom validation rules and error handling",
                "Understand validation request classes and their benefits"
              ],
              "intro": "Form validation is a critical aspect of web application security and user experience in Laravel development. This comprehensive lesson will teach you how to implement robust validation systems that protect your application from malicious input while providing clear feedback to users.\n\nYou'll learn to use Laravel's powerful validation features, including built-in rules, custom validation logic, and validation request classes. We'll explore both server-side and client-side validation techniques, ensuring your applications maintain data integrity and security.\n\nBy mastering Laravel's validation system, you'll be able to create forms that handle edge cases gracefully, provide meaningful error messages, and maintain excellent user experience. This knowledge is essential for building production-ready applications that users can trust.\n\nThe validation techniques covered here will serve as the foundation for secure data handling in all your Laravel projects, from simple contact forms to complex multi-step registration processes.",
              "code": {
                "example": "<?php\n// In Controller\npublic function store(Request $request)\n{\n    $validated = $request->validate([\n        'name' => 'required|string|max:255',\n        'email' => 'required|email|unique:users',\n        'password' => 'required|min:8|confirmed',\n        'age' => 'required|integer|min:18|max:120',\n        'terms' => 'accepted'\n    ]);\n\n    User::create($validated);\n    return redirect()->route('users.index')->with('success', 'User created successfully');\n}\n\n// Form Request Class\nclass StoreUserRequest extends FormRequest\n{\n    public function rules()\n    {\n        return [\n            'name' => 'required|string|max:255',\n            'email' => 'required|email|unique:users,email',\n            'password' => 'required|min:8|regex:/^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)/',\n        ];\n    }\n\n    public function messages()\n    {\n        return [\n            'password.regex' => 'Password must contain uppercase, lowercase, and numbers',\n        ];\n    }\n}",
                "explanation": "This example demonstrates comprehensive form validation including required fields, email validation, password confirmation, and custom validation rules. The FormRequest class provides organized validation logic with custom error messages, making the code more maintainable and reusable across different controllers.",
                "language": "php"
              },
              "pitfalls": [
                {
                  "mistake": "Not validating file uploads properly",
                  "solution": "Always validate file types, sizes, and use secure upload handling",
                  "severity": "high"
                },
                {
                  "mistake": "Trusting client-side validation only",
                  "solution": "Always implement server-side validation as the primary security measure",
                  "severity": "high"
                },
                {
                  "mistake": "Not providing clear error messages",
                  "solution": "Create user-friendly validation messages that guide users to correct inputs",
                  "severity": "medium"
                }
              ],
              "exercises": [
                {
                  "title": "Build a User Registration Form",
                  "description": "Create a complete user registration form with comprehensive validation including password strength, email uniqueness, and profile image upload validation",
                  "checkpoints": [
                    "Implement FormRequest class with all validation rules",
                    "Add custom validation for password strength",
                    "Create user-friendly error messages",
                    "Test validation with various input scenarios"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 35,
              "difficulty": "Intermediate",
              "tags": [
                "Validation",
                "Forms",
                "Security",
                "Laravel"
              ],
              "legacy": {
                "originalId": 13,
                "originalTopic": "Form Validation",
                "migrated": "2025-01-27T10:15:00.000Z"
              },
              "lastUpdated": "2025-01-27T10:15:00.000Z",
              "version": "1.0.0"
            },
            {
              "id": "laravel-fundamentals-lesson-14",
              "moduleSlug": "laravel-fundamentals",
              "title": "Eloquent Relationships",
              "order": 14,
              "objectives": [
                "Master one-to-many and many-to-many relationships in Eloquent",
                "Implement efficient relationship queries with eager loading",
                "Understand pivot tables and relationship constraints"
              ],
              "intro": "Eloquent relationships are the backbone of database interactions in Laravel, enabling you to define and work with complex data structures efficiently. This lesson provides comprehensive coverage of Laravel's relationship system, from basic one-to-one connections to complex many-to-many associations.\n\nYou'll learn to design database schemas that reflect real-world relationships, implement efficient queries that avoid the N+1 problem, and leverage Laravel's powerful relationship features for clean, maintainable code. Understanding relationships is crucial for building scalable applications that handle complex data interactions.\n\nWe'll explore practical scenarios like user-post relationships, role-based permissions, and tagging systems. You'll discover how to optimize relationship queries, handle pivot table data, and implement relationship constraints that maintain data integrity.\n\nMastering Eloquent relationships will dramatically improve your ability to build sophisticated applications with clean, expressive code that accurately models complex business logic and data structures.",
              "code": {
                "example": "<?php\n// User Model (One-to-Many)\nclass User extends Model\n{\n    public function posts()\n    {\n        return $this->hasMany(Post::class);\n    }\n\n    public function roles()\n    {\n        return $this->belongsToMany(Role::class)->withPivot('assigned_at');\n    }\n}\n\n// Post Model\nclass Post extends Model\n{\n    public function user()\n    {\n        return $this->belongsTo(User::class);\n    }\n\n    public function tags()\n    {\n        return $this->belongsToMany(Tag::class);\n    }\n}\n\n// Efficient Relationship Queries\n$users = User::with(['posts', 'roles'])->get(); // Eager loading\n\n$userPosts = User::find(1)->posts()->where('published', true)->get();\n\n// Many-to-Many with Pivot Data\n$user->roles()->attach($roleId, ['assigned_at' => now()]);\n$user->roles()->wherePivot('assigned_at', '>', Carbon::yesterday())->get();",
                "explanation": "This example demonstrates the three main relationship types in Laravel: one-to-many (User-Posts), many-to-many (User-Roles), and many-to-many with pivot data (Posts-Tags). Eager loading prevents N+1 query problems, while pivot table methods enable complex relationship management.",
                "language": "php"
              },
              "pitfalls": [
                {
                  "mistake": "N+1 query problem when accessing relationships",
                  "solution": "Use eager loading with with() method or lazy eager loading with load()",
                  "severity": "high"
                },
                {
                  "mistake": "Not defining inverse relationships",
                  "solution": "Always define both sides of relationships for proper Eloquent functionality",
                  "severity": "medium"
                },
                {
                  "mistake": "Incorrectly naming foreign keys",
                  "solution": "Follow Laravel conventions or explicitly specify foreign key names",
                  "severity": "medium"
                }
              ],
              "exercises": [
                {
                  "title": "Build a Blog System with Relationships",
                  "description": "Create a complete blog system with Users, Posts, Categories, and Tags, implementing all relationship types and optimized queries",
                  "checkpoints": [
                    "Define all model relationships correctly",
                    "Implement efficient queries with eager loading",
                    "Create pivot table for post-tag relationships",
                    "Build controllers that demonstrate relationship usage"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 40,
              "difficulty": "Intermediate",
              "tags": [
                "Eloquent",
                "Relationships",
                "Database",
                "ORM",
                "Laravel"
              ],
              "legacy": {
                "originalId": 14,
                "originalTopic": "Eloquent Relationships",
                "migrated": "2025-01-27T10:15:00.000Z"
              },
              "lastUpdated": "2025-01-27T10:15:00.000Z",
              "version": "1.0.0"
            },
            {
              "id": "laravel-fundamentals-lesson-15",
              "moduleSlug": "laravel-fundamentals",
              "title": "File Storage and Uploads",
              "order": 15,
              "objectives": [
                "Implement secure file upload handling in Laravel applications",
                "Configure and use different storage drivers (local, S3, etc.)",
                "Handle file validation, processing, and storage organization"
              ],
              "intro": "File storage and uploads are essential features in modern web applications, from user profile pictures to document management systems. This comprehensive lesson covers Laravel's powerful filesystem abstraction, enabling you to handle files securely and efficiently across different storage environments.\n\nYou'll learn to implement robust file upload systems that validate file types and sizes, process images, and organize files in logical directory structures. We'll explore Laravel's unified API for different storage drivers, making it easy to switch between local storage, cloud services like Amazon S3, and CDN integration.\n\nSecurity is paramount when handling user uploads, so we'll cover best practices for preventing malicious file uploads, implementing proper access controls, and sanitizing file names. You'll also learn to optimize file storage for performance and scalability.\n\nBy the end of this lesson, you'll be confident in building file management features that scale from simple personal projects to enterprise applications handling thousands of uploads daily.",
              "code": {
                "example": "<?php\n// File Upload Controller\nclass FileUploadController extends Controller\n{\n    public function store(Request $request)\n    {\n        $request->validate([\n            'avatar' => 'required|image|mimes:jpeg,png,jpg|max:2048',\n            'document' => 'required|file|mimes:pdf,doc,docx|max:10240'\n        ]);\n\n        // Store avatar with custom name\n        $avatarPath = $request->file('avatar')->store('avatars', 'public');\n        \n        // Store document on S3\n        $documentPath = $request->file('document')->store('documents', 's3');\n\n        // Save file info to database\n        UserFile::create([\n            'user_id' => auth()->id(),\n            'avatar_path' => $avatarPath,\n            'document_path' => $documentPath,\n            'original_name' => $request->file('document')->getClientOriginalName()\n        ]);\n\n        return back()->with('success', 'Files uploaded successfully');\n    }\n\n    public function download($fileId)\n    {\n        $file = UserFile::findOrFail($fileId);\n        \n        // Check permissions\n        $this->authorize('download', $file);\n        \n        return Storage::disk('s3')->download($file->document_path, $file->original_name);\n    }\n}\n\n// In config/filesystems.php\n'disks' => [\n    's3' => [\n        'driver' => 's3',\n        'key' => env('AWS_ACCESS_KEY_ID'),\n        'secret' => env('AWS_SECRET_ACCESS_KEY'),\n        'region' => env('AWS_DEFAULT_REGION'),\n        'bucket' => env('AWS_BUCKET'),\n    ],\n];",
                "explanation": "This example shows comprehensive file handling including validation, multiple storage drivers, organized directory structure, and secure download functionality. The code demonstrates both local and cloud storage integration with proper security measures.",
                "language": "php"
              },
              "pitfalls": [
                {
                  "mistake": "Not validating file types and sizes",
                  "solution": "Always implement strict file validation to prevent security vulnerabilities",
                  "severity": "high"
                },
                {
                  "mistake": "Storing files in publicly accessible directories without access control",
                  "solution": "Use Laravel's storage system with proper disk configuration and authorization",
                  "severity": "high"
                },
                {
                  "mistake": "Not handling file upload errors gracefully",
                  "solution": "Implement proper error handling and user feedback for upload failures",
                  "severity": "medium"
                }
              ],
              "exercises": [
                {
                  "title": "Build a Document Management System",
                  "description": "Create a secure document upload and management system with different file types, access controls, and cloud storage integration",
                  "checkpoints": [
                    "Implement file upload with comprehensive validation",
                    "Configure multiple storage drivers (local and cloud)",
                    "Create access control for file downloads",
                    "Build file organization and search functionality"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 45,
              "difficulty": "Intermediate",
              "tags": [
                "File Storage",
                "Uploads",
                "Security",
                "Cloud Storage",
                "Laravel"
              ],
              "legacy": {
                "originalId": 15,
                "originalTopic": "File Storage",
                "migrated": "2025-01-27T10:15:00.000Z"
              },
              "lastUpdated": "2025-01-27T10:15:00.000Z",
              "version": "1.0.0"
            },
            {
              "id": "laravel-fundamentals-lesson-16",
              "moduleSlug": "laravel-fundamentals",
              "title": "Laravel Artisan Commands",
              "order": 16,
              "objectives": [
                "Create custom Artisan commands for application automation",
                "Understand command scheduling and background task execution",
                "Implement command-line interfaces for administrative tasks"
              ],
              "intro": "Laravel's Artisan command-line interface is a powerful tool for automating tasks, managing your application, and creating custom administrative utilities. This lesson teaches you to harness Artisan's full potential by creating custom commands that streamline your development workflow and application maintenance.\n\nYou'll learn to build sophisticated command-line tools that can process data, generate reports, perform maintenance tasks, and integrate with external systems. We'll explore command arguments, options, interactive prompts, and progress indicators that create professional command-line experiences.\n\nCommand scheduling is another crucial aspect we'll cover, enabling you to automate repetitive tasks like data backups, email notifications, and system cleanups. You'll discover how to create robust, error-resistant commands that handle edge cases and provide detailed logging.\n\nMastering Artisan commands will significantly improve your productivity and enable you to build applications with powerful administrative capabilities that can be automated and scheduled for optimal performance.",
              "code": {
                "example": "<?php\n// Creating a custom command\nphp artisan make:command ProcessUserData\n\n// In app/Console/Commands/ProcessUserData.php\nclass ProcessUserData extends Command\n{\n    protected $signature = 'users:process {--inactive : Process only inactive users} {--limit=100 : Limit number of users}';\n    protected $description = 'Process user data and generate reports';\n\n    public function handle()\n    {\n        $limit = $this->option('limit');\n        $onlyInactive = $this->option('inactive');\n        \n        $query = User::query();\n        if ($onlyInactive) {\n            $query->where('last_login_at', '<', now()->subDays(30));\n        }\n        \n        $users = $query->limit($limit)->get();\n        \n        $this->info(\"Processing {$users->count()} users...\");\n        \n        $bar = $this->output->createProgressBar($users->count());\n        $bar->start();\n        \n        foreach ($users as $user) {\n            // Process user data\n            $this->processUserData($user);\n            $bar->advance();\n        }\n        \n        $bar->finish();\n        $this->newLine();\n        $this->info('User processing completed successfully!');\n        \n        return Command::SUCCESS;\n    }\n    \n    private function processUserData(User $user)\n    {\n        // Simulate data processing\n        sleep(1);\n        \n        // Log processing\n        $this->line(\"Processed user: {$user->email}\");\n    }\n}\n\n// In app/Console/Kernel.php - Scheduling\nprotected function schedule(Schedule $schedule)\n{\n    $schedule->command('users:process --inactive')\n             ->daily()\n             ->at('02:00')\n             ->emailOutputTo('admin@example.com');\n             \n    $schedule->command('backup:run')\n             ->weekly()\n             ->sundays()\n             ->at('01:00');\n}",
                "explanation": "This example demonstrates a comprehensive custom Artisan command with options, arguments, progress bars, and interactive output. The command includes scheduling configuration for automated execution, showing how to build professional command-line tools for application management.",
                "language": "php"
              },
              "pitfalls": [
                {
                  "mistake": "Not handling command failures gracefully",
                  "solution": "Implement proper error handling and return appropriate exit codes",
                  "severity": "medium"
                },
                {
                  "mistake": "Creating commands that consume too much memory",
                  "solution": "Use chunking and proper memory management for large data processing",
                  "severity": "medium"
                },
                {
                  "mistake": "Not providing clear command documentation",
                  "solution": "Write descriptive command descriptions and use meaningful argument names",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Build a Data Export Command",
                  "description": "Create a comprehensive data export command that can export different data types with various format options and scheduling capabilities",
                  "checkpoints": [
                    "Create command with multiple options and arguments",
                    "Implement progress tracking and user feedback",
                    "Add error handling and logging",
                    "Configure command scheduling for automated exports"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 35,
              "difficulty": "Intermediate",
              "tags": [
                "Artisan",
                "Commands",
                "Automation",
                "CLI",
                "Laravel"
              ],
              "legacy": {
                "originalId": 16,
                "originalTopic": "Artisan Commands",
                "migrated": "2025-01-27T10:15:00.000Z"
              },
              "lastUpdated": "2025-01-27T10:15:00.000Z",
              "version": "1.0.0"
            }
          ],
          "issues": []
        },
        "quiz": {
          "exists": true,
          "count": 35,
          "questions": [
            {
              "id": "laravel-fundamentals-q1",
              "question": "Which method is used to define a GET route in Laravel?",
              "topic": "Routing",
              "difficulty": "Intermediate",
              "choices": [
                "Route::get()",
                "Route::post()",
                "Route::put()",
                "Route::delete()"
              ],
              "correctIndex": 0,
              "explanation": "In Laravel, Route::get() is used to define a GET route. This is the most common HTTP method for retrieving data.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Routing",
                "intermediate",
                "laravel"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 1,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.485Z"
              }
            },
            {
              "id": "laravel-fundamentals-q2",
              "question": "Which method is used to retrieve all records from a model?",
              "topic": "Eloquent ORM",
              "difficulty": "Intermediate",
              "choices": [
                "Model::all()",
                "Model::get()",
                "Model::find()",
                "Model::first()"
              ],
              "correctIndex": 0,
              "explanation": "The all() method retrieves all records from the model's associated database table.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Eloquent ORM",
                "intermediate",
                "laravel"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 2,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.485Z"
              }
            },
            {
              "id": "laravel-fundamentals-q3",
              "question": "Which directive is used to extend a Blade layout?",
              "topic": "Blade Templates",
              "difficulty": "Intermediate",
              "choices": [
                "@extends",
                "@include",
                "@yield",
                "@section"
              ],
              "correctIndex": 0,
              "explanation": "The @extends directive is used to specify which layout the child view should inherit from.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Blade Templates",
                "intermediate",
                "laravel"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 3,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.485Z"
              }
            },
            {
              "id": "laravel-fundamentals-q4",
              "question": "Which artisan command is used to create a new migration?",
              "topic": "Database",
              "difficulty": "Intermediate",
              "choices": [
                "php artisan make:migration",
                "php artisan create:migration",
                "php artisan generate:migration",
                "php artisan new:migration"
              ],
              "correctIndex": 0,
              "explanation": "The php artisan make:migration command is used to create a new migration file in Laravel.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Database",
                "intermediate",
                "laravel"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 4,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.485Z"
              }
            },
            {
              "id": "laravel-fundamentals-q5",
              "question": "Which middleware is used to authenticate users in Laravel?",
              "topic": "Authentication",
              "difficulty": "Intermediate",
              "choices": [
                "auth",
                "guest",
                "verified",
                "throttle"
              ],
              "correctIndex": 0,
              "explanation": "The auth middleware is used to ensure that only authenticated users can access certain routes.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Authentication",
                "intermediate",
                "laravel"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 5,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.485Z"
              }
            },
            {
              "id": "laravel-fundamentals-q6",
              "question": "How do you define a route parameter in Laravel?",
              "topic": "Routing",
              "difficulty": "Beginner",
              "choices": [
                "/user/{id}",
                "/user/:id",
                "/user/[id]",
                "/user/<id>"
              ],
              "correctIndex": 0,
              "explanation": "In Laravel, curly braces {} are used to define route parameters.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Routing",
                "beginner",
                "laravel"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 6,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.485Z"
              }
            },
            {
              "id": "laravel-fundamentals-q7",
              "question": "What is Eloquent ORM in Laravel?",
              "topic": "Eloquent ORM",
              "difficulty": "Beginner",
              "choices": [
                "Open-ended question - no multiple choice",
                "This is a conceptual question",
                "Answer requires explanation",
                "Multiple approaches possible"
              ],
              "correctIndex": 0,
              "explanation": "Eloquent ORM is Laravel's implementation of the Active Record pattern. It provides a beautiful, simple ActiveRecord implementation for working with your database. Each database table has a corresponding 'Model' which is used to interact with that table.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Eloquent ORM",
                "beginner",
                "laravel"
              ],
              "questionType": "open-ended",
              "estimatedTime": 180,
              "legacy": {
                "originalId": 7,
                "originalType": "open-ended",
                "migrated": "2025-10-01T06:41:13.485Z"
              }
            },
            {
              "id": "laravel-fundamentals-q8",
              "question": "Which Blade directive is used to display data that might be null?",
              "topic": "Blade Templates",
              "difficulty": "Intermediate",
              "choices": [
                "{{ $variable ?? 'default' }}",
                "{{ $variable ?: 'default' }}",
                "{{ $variable ? 'default' }}",
                "{{ $variable | 'default' }}"
              ],
              "correctIndex": 0,
              "explanation": "The ?? operator in Blade is the null coalescing operator, which displays the default value if the variable is null.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Blade Templates",
                "intermediate",
                "laravel"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 8,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.485Z"
              }
            },
            {
              "id": "laravel-fundamentals-q9",
              "question": "What is middleware in Laravel?",
              "topic": "Middleware",
              "difficulty": "Beginner",
              "choices": [
                "Open-ended question - no multiple choice",
                "This is a conceptual question",
                "Answer requires explanation",
                "Multiple approaches possible"
              ],
              "correctIndex": 0,
              "explanation": "Middleware acts as a filter for HTTP requests entering your application. It can examine the request and decide whether to allow it to proceed or redirect the user somewhere else. Common uses include authentication, CSRF protection, and logging.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Middleware",
                "beginner",
                "laravel"
              ],
              "questionType": "open-ended",
              "estimatedTime": 180,
              "legacy": {
                "originalId": 9,
                "originalType": "open-ended",
                "migrated": "2025-10-01T06:41:13.485Z"
              }
            },
            {
              "id": "laravel-fundamentals-q10",
              "question": "Which method is used to run database migrations?",
              "topic": "Database",
              "difficulty": "Intermediate",
              "choices": [
                "php artisan migrate",
                "php artisan run:migrations",
                "php artisan db:migrate",
                "php artisan execute:migrations"
              ],
              "correctIndex": 0,
              "explanation": "The php artisan migrate command is used to run all outstanding migrations.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Database",
                "intermediate",
                "laravel"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 10,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.485Z"
              }
            },
            {
              "id": "laravel-fundamentals-q11",
              "question": "Which Laravel package provides a simple way to add authentication to your application?",
              "topic": "Authentication",
              "difficulty": "Beginner",
              "choices": [
                "Laravel Breeze",
                "Laravel Cashier",
                "Laravel Dusk",
                "Laravel Envoy"
              ],
              "correctIndex": 0,
              "explanation": "Laravel Breeze is a simple, minimal implementation of Laravel's authentication features including login, registration, password reset, email verification, and password confirmation.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Authentication",
                "beginner",
                "laravel"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 11,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.485Z"
              }
            },
            {
              "id": "laravel-fundamentals-q12",
              "question": "What is route model binding in Laravel?",
              "topic": "Routing",
              "difficulty": "Beginner",
              "choices": [
                "Open-ended question - no multiple choice",
                "This is a conceptual question",
                "Answer requires explanation",
                "Multiple approaches possible"
              ],
              "correctIndex": 0,
              "explanation": "Route model binding provides a convenient way to inject model instances into your routes. Laravel will automatically resolve Eloquent models defined in routes or controller methods whose type-hinted variable names match a route segment name.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Routing",
                "beginner",
                "laravel"
              ],
              "questionType": "open-ended",
              "estimatedTime": 180,
              "legacy": {
                "originalId": 12,
                "originalType": "open-ended",
                "migrated": "2025-10-01T06:41:13.485Z"
              }
            },
            {
              "id": "laravel-fundamentals-q13",
              "question": "Which method is used to create a new record in the database using Eloquent?",
              "topic": "Eloquent ORM",
              "difficulty": "Intermediate",
              "choices": [
                "Model::create()",
                "Model::save()",
                "Model::insert()",
                "Model::make()"
              ],
              "correctIndex": 0,
              "explanation": "The create() method creates and saves a new model instance in a single operation. It requires the $fillable property to be set on the model.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Eloquent ORM",
                "intermediate",
                "laravel"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 13,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.485Z"
              }
            },
            {
              "id": "laravel-fundamentals-q14",
              "question": "Which Blade directive is used to include a view?",
              "topic": "Blade Templates",
              "difficulty": "Intermediate",
              "choices": [
                "@include",
                "@extend",
                "@yield",
                "@section"
              ],
              "correctIndex": 0,
              "explanation": "The @include directive is used to include another Blade view within the current view.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Blade Templates",
                "intermediate",
                "laravel"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 14,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.485Z"
              }
            },
            {
              "id": "laravel-fundamentals-q15",
              "question": "Where are route middleware registered in Laravel?",
              "topic": "Middleware",
              "difficulty": "Intermediate",
              "choices": [
                "app/Http/Kernel.php",
                "routes/web.php",
                "config/app.php",
                "app/Providers/AppServiceProvider.php"
              ],
              "correctIndex": 0,
              "explanation": "Route middleware are registered in the $routeMiddleware property of the app/Http/Kernel.php file.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Middleware",
                "intermediate",
                "laravel"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 15,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.485Z"
              }
            },
            {
              "id": "laravel-fundamentals-q16",
              "question": "What are Laravel migrations?",
              "topic": "Database",
              "difficulty": "Intermediate",
              "choices": [
                "Open-ended question - no multiple choice",
                "This is a conceptual question",
                "Answer requires explanation",
                "Multiple approaches possible"
              ],
              "correctIndex": 0,
              "explanation": "Migrations are like version control for your database, allowing your team to define and share the application's database schema definition. They are typically paired with Laravel's schema builder to build your application's database schema.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Database",
                "intermediate",
                "laravel"
              ],
              "questionType": "open-ended",
              "estimatedTime": 180,
              "legacy": {
                "originalId": 16,
                "originalType": "open-ended",
                "migrated": "2025-10-01T06:41:13.485Z"
              }
            },
            {
              "id": "laravel-fundamentals-q17",
              "question": "Which Laravel feature provides API token authentication?",
              "topic": "Authentication",
              "difficulty": "Intermediate",
              "choices": [
                "Laravel Sanctum",
                "Laravel Passport",
                "Laravel Breeze",
                "Laravel Fortify"
              ],
              "correctIndex": 0,
              "explanation": "Laravel Sanctum provides a simple way to authenticate single page applications and mobile applications with Laravel. It provides a way to issue API tokens to users.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Authentication",
                "intermediate",
                "laravel"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 17,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.485Z"
              }
            },
            {
              "id": "laravel-fundamentals-q18",
              "question": "Which method is used to define a POST route in Laravel?",
              "topic": "Routing",
              "difficulty": "Intermediate",
              "choices": [
                "Route::post()",
                "Route::get()",
                "Route::put()",
                "Route::patch()"
              ],
              "correctIndex": 0,
              "explanation": "Route::post() is used to define a POST route, typically used for creating resources.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Routing",
                "intermediate",
                "laravel"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 18,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.485Z"
              }
            },
            {
              "id": "laravel-fundamentals-q19",
              "question": "How do you define a relationship between two models in Eloquent?",
              "topic": "Eloquent ORM",
              "difficulty": "Beginner",
              "choices": [
                "By defining a method that returns a relationship method",
                "By adding a foreign key column",
                "By creating a pivot table",
                "By using the with() method"
              ],
              "correctIndex": 0,
              "explanation": "In Eloquent, relationships are defined as methods on your Eloquent model classes. These methods return instances of relationships like hasOne, hasMany, belongsTo, etc.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Eloquent ORM",
                "beginner",
                "laravel"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 19,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.485Z"
              }
            },
            {
              "id": "laravel-fundamentals-q20",
              "question": "Which Blade directive is used to define a section?",
              "topic": "Blade Templates",
              "difficulty": "Intermediate",
              "choices": [
                "@section",
                "@yield",
                "@include",
                "@extends"
              ],
              "correctIndex": 0,
              "explanation": "The @section directive is used to define a section of content, while @yield is used to display that content in the layout.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Blade Templates",
                "intermediate",
                "laravel"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 20,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.485Z"
              }
            },
            {
              "id": "laravel-fundamentals-q21",
              "question": "Which method is used to validate request data in Laravel controllers?",
              "topic": "Validation",
              "difficulty": "Intermediate",
              "choices": [
                "$request->validate()",
                "$this->validate()",
                "Validator::make()",
                "All of the above"
              ],
              "correctIndex": 3,
              "explanation": "In Laravel, you can validate request data using $request->validate(), $this->validate(), or Validator::make(). All three methods are valid approaches.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Validation",
                "intermediate",
                "laravel"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 21,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.485Z"
              }
            },
            {
              "id": "laravel-fundamentals-q22",
              "question": "Which artisan command generates a new event and listener?",
              "topic": "Events",
              "difficulty": "Intermediate",
              "choices": [
                "php artisan make:event",
                "php artisan make:listener",
                "Both A and B",
                "php artisan make:event-listener"
              ],
              "correctIndex": 2,
              "explanation": "You need to use both php artisan make:event and php artisan make:listener to create an event and its corresponding listener.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Events",
                "intermediate",
                "laravel"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 22,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.485Z"
              }
            },
            {
              "id": "laravel-fundamentals-q23",
              "question": "Which method is used to dispatch a job to the queue?",
              "topic": "Queues",
              "difficulty": "Intermediate",
              "choices": [
                "dispatch()",
                "queue()",
                "send()",
                "process()"
              ],
              "correctIndex": 0,
              "explanation": "The dispatch() method is used to dispatch a job to the queue in Laravel. You can call it on the job instance or use the dispatch() helper function.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Queues",
                "intermediate",
                "laravel"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 23,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.485Z"
              }
            },
            {
              "id": "laravel-fundamentals-q24",
              "question": "Which facade is used to interact with the cache in Laravel?",
              "topic": "Caching",
              "difficulty": "Intermediate",
              "choices": [
                "Cache",
                "Storage",
                "Session",
                "Config"
              ],
              "correctIndex": 0,
              "explanation": "The Cache facade is used to interact with the cache in Laravel. It provides methods like Cache::get(), Cache::put(), Cache::remember(), etc.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Caching",
                "intermediate",
                "laravel"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 24,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.485Z"
              }
            },
            {
              "id": "laravel-fundamentals-q25",
              "question": "Which base class should feature tests extend in Laravel?",
              "topic": "Testing",
              "difficulty": "Intermediate",
              "choices": [
                "Tests\\TestCase",
                "PHPUnit\\Framework\\TestCase",
                "Tests\\Feature\\TestCase",
                "Tests\\Unit\\TestCase"
              ],
              "correctIndex": 0,
              "explanation": "Feature tests in Laravel should extend the Tests\\TestCase base class, which provides additional testing helpers specific to Laravel applications.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Testing",
                "intermediate",
                "laravel"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 25,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.485Z"
              }
            },
            {
              "id": "laravel-fundamentals-q26",
              "question": "Which method is used to transform each item in a collection?",
              "topic": "Collections",
              "difficulty": "Intermediate",
              "choices": [
                "map()",
                "filter()",
                "reduce()",
                "each()"
              ],
              "correctIndex": 0,
              "explanation": "The map() method is used to transform each item in a collection by applying a callback function to each item and returning a new collection with the transformed items.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Collections",
                "intermediate",
                "laravel"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 26,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.485Z"
              }
            },
            {
              "id": "laravel-fundamentals-q27",
              "question": "How do you list all available Artisan commands?",
              "topic": "Artisan",
              "difficulty": "Beginner",
              "choices": [
                "php artisan list",
                "php artisan help",
                "php artisan commands",
                "php artisan show"
              ],
              "correctIndex": 0,
              "explanation": "The php artisan list command displays all available Artisan commands along with their descriptions and usage information.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Artisan",
                "beginner",
                "laravel"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 27,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.485Z"
              }
            },
            {
              "id": "laravel-fundamentals-q28",
              "question": "Which method is used to define a foreign key constraint in Laravel migrations?",
              "topic": "Database",
              "difficulty": "Intermediate",
              "choices": [
                "foreign()",
                "references()",
                "on()",
                "All of the above"
              ],
              "correctIndex": 3,
              "explanation": "To define a foreign key constraint, you use a combination of foreign(), references(), and on() methods: $table->foreign('user_id')->references('id')->on('users');",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Database",
                "intermediate",
                "laravel"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 28,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.485Z"
              }
            },
            {
              "id": "laravel-fundamentals-q29",
              "question": "How do you eager load relationships to avoid the N+1 query problem?",
              "topic": "Eloquent ORM",
              "difficulty": "Beginner",
              "choices": [
                "with()",
                "load()",
                "join()",
                "attach()"
              ],
              "correctIndex": 0,
              "explanation": "The with() method is used to eager load relationships when querying models to avoid the N+1 query problem. Example: User::with('posts')->get();",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Eloquent ORM",
                "beginner",
                "laravel"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 29,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.485Z"
              }
            },
            {
              "id": "laravel-fundamentals-q30",
              "question": "Which middleware is used to prevent CSRF attacks in Laravel?",
              "topic": "Security",
              "difficulty": "Intermediate",
              "choices": [
                "VerifyCsrfToken",
                "EncryptCookies",
                "RedirectIfAuthenticated",
                "TrimStrings"
              ],
              "correctIndex": 0,
              "explanation": "The VerifyCsrfToken middleware is used to prevent CSRF (Cross-Site Request Forgery) attacks by validating CSRF tokens on incoming requests.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Security",
                "intermediate",
                "laravel"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 30,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.485Z"
              }
            },
            {
              "id": "laravel-fundamentals-q31",
              "question": "Which method is used to store uploaded files in Laravel?",
              "topic": "File Storage",
              "difficulty": "Intermediate",
              "choices": [
                "$request->file('photo')->store()",
                "$request->store('photo')",
                "Storage::save()",
                "File::upload()"
              ],
              "correctIndex": 0,
              "explanation": "The store() method is used to store uploaded files. You can call it on the uploaded file instance: $request->file('photo')->store('images');",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "File Storage",
                "intermediate",
                "laravel"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 31,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.485Z"
              }
            },
            {
              "id": "laravel-fundamentals-q32",
              "question": "Which method is used to send a notification immediately?",
              "topic": "Notifications",
              "difficulty": "Intermediate",
              "choices": [
                "notify()",
                "send()",
                "queue()",
                "dispatch()"
              ],
              "correctIndex": 0,
              "explanation": "The notify() method is used to send a notification immediately to a notifiable entity (like a user): $user->notify(new InvoicePaid($invoice));",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Notifications",
                "intermediate",
                "laravel"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 32,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.485Z"
              }
            },
            {
              "id": "laravel-fundamentals-q33",
              "question": "Which artisan command generates a new API resource class?",
              "topic": "API Resources",
              "difficulty": "Intermediate",
              "choices": [
                "php artisan make:resource",
                "php artisan make:api-resource",
                "php artisan make:json",
                "php artisan make:transformer"
              ],
              "correctIndex": 0,
              "explanation": "The php artisan make:resource command generates a new API resource class that can be used to transform models into JSON responses.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "API Resources",
                "intermediate",
                "laravel"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 33,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.485Z"
              }
            },
            {
              "id": "laravel-fundamentals-q34",
              "question": "Which method is used to bind a class to the service container?",
              "topic": "Service Container",
              "difficulty": "Intermediate",
              "choices": [
                "bind()",
                "register()",
                "resolve()",
                "make()"
              ],
              "correctIndex": 0,
              "explanation": "The bind() method is used to bind a class or interface to the service container: $this->app->bind('HelpSpot\\Api\\Contracts\\Repository', 'HelpSpot\\Api\\Repositories\\RedisRepository');",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Service Container",
                "intermediate",
                "laravel"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 34,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.485Z"
              }
            },
            {
              "id": "laravel-fundamentals-q35",
              "question": "Where are scheduled tasks defined in Laravel?",
              "topic": "Task Scheduling",
              "difficulty": "Intermediate",
              "choices": [
                "app/Console/Kernel.php",
                "routes/console.php",
                "config/app.php",
                "app/Providers/AppServiceProvider.php"
              ],
              "correctIndex": 0,
              "explanation": "Scheduled tasks are defined in the schedule() method of the app/Console/Kernel.php file using the scheduler instance.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Task Scheduling",
                "intermediate",
                "laravel"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 35,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.485Z"
              }
            }
          ],
          "issues": []
        },
        "meetsThresholds": true,
        "issues": []
      },
      "nextjs-advanced": {
        "slug": "nextjs-advanced",
        "title": "Next.js Full-Stack Framework",
        "tier": "specialized",
        "track": "Frontend",
        "difficulty": "Advanced",
        "thresholds": {
          "requiredLessons": 14,
          "requiredQuestions": 18
        },
        "lessons": {
          "exists": true,
          "count": 14,
          "lessons": [
            {
              "id": "nextjs-advanced-lesson-1",
              "moduleSlug": "nextjs-advanced",
              "title": "Next.js Fundamentals and Setup",
              "order": 1,
              "objectives": [
                "Understand Next.js architecture and benefits",
                "Set up a Next.js development environment",
                "Create your first Next.js application"
              ],
              "intro": "Welcome to Next.js Full-Stack Framework - the most powerful React framework for production.\n\nNext.js is a React framework that gives you building blocks to create web applications. By framework, we mean Next.js handles the tooling and configuration needed for React, and provides additional structure, features, and optimizations for your application.\n\nThroughout this lesson, you'll gain hands-on experience with setting up Next.js projects and understanding its core concepts. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to introduce you to the Next.js ecosystem while showing you practical techniques that will enhance your development skills. By the end, you'll have a solid understanding of Next.js fundamentals and be ready to tackle more advanced topics.",
              "code": {
                "example": "// Creating a Next.js app\nnpx create-next-app@latest my-nextjs-app\ncd my-nextjs-app\nnpm run dev\n\n// Basic page structure\n// pages/index.js\nimport Head from 'next/head'\n\nexport default function Home() {\n  return (\n    <div>\n      <Head>\n        <title>My Next.js App</title>\n        <meta name=\"description\" content=\"Generated by create next app\" />\n      </Head>\n      <main>\n        <h1>Welcome to Next.js!</h1>\n        <p>The React Framework for Production</p>\n      </main>\n    </div>\n  )\n}",
                "explanation": "This example creates a basic Next.js application with proper SEO setup using the Head component. The create-next-app command sets up a complete development environment with all necessary configurations.\n\nKey features demonstrated:\n- Zero-config setup with create-next-app\n- Built-in Head component for SEO\n- File-based routing system\n- Hot reloading in development",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not using the Head component for SEO",
                  "solution": "Always include proper meta tags using next/head",
                  "severity": "medium"
                },
                {
                  "mistake": "Placing components in the wrong directory",
                  "solution": "Use pages/ for routes, components/ for reusable components",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Create Your First Next.js App",
                  "description": "Set up a new Next.js project and create a custom homepage",
                  "checkpoints": [
                    "Install Next.js using create-next-app",
                    "Modify the homepage with custom content",
                    "Add proper SEO meta tags"
                  ]
                }
              ],
              "next": [
                "nextjs-advanced-lesson-2"
              ],
              "estimatedMinutes": 30,
              "difficulty": "Beginner",
              "tags": [
                "Next.js",
                "Setup",
                "React",
                "SSR"
              ],
              "lastUpdated": "2025-10-01T12:00:00.000Z",
              "version": "1.0.0"
            },
            {
              "id": "nextjs-advanced-lesson-2",
              "moduleSlug": "nextjs-advanced",
              "title": "File-based Routing System",
              "order": 2,
              "objectives": [
                "Master Next.js file-based routing",
                "Implement dynamic routes and nested routing",
                "Use programmatic navigation"
              ],
              "intro": "Next.js has a file-system based router built on the concept of pages. When a file is added to the pages directory, it's automatically available as a route.\n\nThis powerful routing system eliminates the need for complex routing configurations while providing advanced features like dynamic routes, nested routing, and automatic code splitting.\n\nIn this lesson, you'll learn how to leverage Next.js routing to build scalable application structures with clean URLs and optimized performance.",
              "code": {
                "example": "// Static routes\n// pages/about.js -> /about\n// pages/blog/index.js -> /blog\n// pages/blog/first-post.js -> /blog/first-post\n\n// Dynamic routes\n// pages/posts/[id].js -> /posts/1, /posts/abc, etc.\nexport default function Post({ post }) {\n  return (\n    <div>\n      <h1>{post.title}</h1>\n      <p>{post.content}</p>\n    </div>\n  )\n}\n\nexport async function getStaticPaths() {\n  return {\n    paths: [\n      { params: { id: '1' } },\n      { params: { id: '2' } }\n    ],\n    fallback: false\n  }\n}\n\nexport async function getStaticProps({ params }) {\n  const post = await fetchPost(params.id)\n  return {\n    props: { post }\n  }\n}\n\n// Programmatic navigation\nimport { useRouter } from 'next/router'\n\nfunction HomePage() {\n  const router = useRouter()\n  \n  const handleClick = () => {\n    router.push('/about')\n  }\n  \n  return <button onClick={handleClick}>Go to About</button>\n}",
                "explanation": "This example demonstrates Next.js routing patterns:\n\n1. Static routes: Simple file-to-route mapping\n2. Dynamic routes: Using [id].js for variable segments\n3. Data fetching: getStaticPaths and getStaticProps for static generation\n4. Programmatic navigation: useRouter hook for navigation\n\nNext.js automatically code-splits each page, loading only what's needed.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not handling fallback cases in dynamic routes",
                  "solution": "Always configure fallback behavior in getStaticPaths",
                  "severity": "high"
                },
                {
                  "mistake": "Using client-side only navigation for SEO-critical pages",
                  "solution": "Use Link component for SEO-friendly navigation",
                  "severity": "medium"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Build a Blog with Dynamic Routes",
                  "description": "Create a blog structure with dynamic post routes",
                  "checkpoints": [
                    "Create static pages (about, contact)",
                    "Implement dynamic post routes [slug].js",
                    "Add navigation between pages"
                  ]
                }
              ],
              "next": [
                "nextjs-advanced-lesson-3"
              ],
              "estimatedMinutes": 35,
              "difficulty": "Intermediate",
              "tags": [
                "Routing",
                "Dynamic Routes",
                "Navigation"
              ],
              "lastUpdated": "2025-10-01T12:00:00.000Z",
              "version": "1.0.0"
            },
            {
              "id": "nextjs-advanced-lesson-3",
              "moduleSlug": "nextjs-advanced",
              "title": "Server-Side Rendering (SSR)",
              "order": 3,
              "objectives": [
                "Understand SSR concepts and benefits",
                "Implement getServerSideProps for dynamic data",
                "Optimize SSR performance"
              ],
              "intro": "Server-Side Rendering (SSR) is one of Next.js's most powerful features, allowing you to render pages on the server for each request.\n\nSSR provides excellent SEO, faster initial page loads, and better user experience, especially for content that changes frequently or requires authentication.\n\nIn this lesson, you'll learn when and how to use SSR effectively in your Next.js applications.",
              "code": {
                "example": "// SSR with getServerSideProps\n// pages/products/[id].js\nimport { GetServerSideProps } from 'next'\n\ninterface Product {\n  id: string\n  name: string\n  price: number\n  description: string\n}\n\ninterface Props {\n  product: Product\n  userAgent: string\n}\n\nexport default function ProductPage({ product, userAgent }: Props) {\n  return (\n    <div>\n      <h1>{product.name}</h1>\n      <p>Price: ${product.price}</p>\n      <p>{product.description}</p>\n      <small>Viewed on: {userAgent}</small>\n    </div>\n  )\n}\n\nexport const getServerSideProps: GetServerSideProps = async (context) => {\n  const { params, req, res, query } = context\n  \n  // Fetch data from API or database\n  const product = await fetch(`https://api.example.com/products/${params?.id}`)\n    .then(res => res.json())\n  \n  // Access request headers\n  const userAgent = req.headers['user-agent'] || ''\n  \n  // Handle not found\n  if (!product) {\n    return {\n      notFound: true\n    }\n  }\n  \n  // Redirect if needed\n  if (product.discontinued) {\n    return {\n      redirect: {\n        destination: '/products',\n        permanent: false\n      }\n    }\n  }\n  \n  return {\n    props: {\n      product,\n      userAgent\n    }\n  }\n}",
                "explanation": "This example shows comprehensive SSR implementation:\n\n1. getServerSideProps runs on every request\n2. Access to request/response objects\n3. Data fetching on the server\n4. Error handling with notFound\n5. Conditional redirects\n6. TypeScript support\n\nThe page is fully rendered on the server before being sent to the client.",
                "language": "typescript"
              },
              "pitfalls": [
                {
                  "mistake": "Using SSR for static content",
                  "solution": "Use SSG (getStaticProps) for content that doesn't change often",
                  "severity": "medium"
                },
                {
                  "mistake": "Not handling errors in getServerSideProps",
                  "solution": "Always implement proper error handling and fallbacks",
                  "severity": "high"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Build a Product Catalog with SSR",
                  "description": "Create a product page that fetches data server-side",
                  "checkpoints": [
                    "Implement getServerSideProps",
                    "Handle loading states and errors",
                    "Add proper TypeScript types"
                  ]
                }
              ],
              "next": [
                "nextjs-advanced-lesson-4"
              ],
              "estimatedMinutes": 40,
              "difficulty": "Advanced",
              "tags": [
                "SSR",
                "getServerSideProps",
                "Performance"
              ],
              "lastUpdated": "2025-10-01T12:00:00.000Z",
              "version": "1.0.0"
            },
            {
              "id": "nextjs-advanced-lesson-4",
              "moduleSlug": "nextjs-advanced",
              "title": "Static Site Generation (SSG)",
              "order": 4,
              "objectives": [
                "Master Static Site Generation concepts",
                "Implement getStaticProps and getStaticPaths",
                "Understand Incremental Static Regeneration"
              ],
              "intro": "Static Site Generation (SSG) is Next.js's method for pre-rendering pages at build time, resulting in blazing-fast websites with excellent SEO.\n\nSSG is perfect for content that doesn't change frequently, providing the best performance while maintaining the flexibility of dynamic content through Incremental Static Regeneration (ISR).",
              "code": {
                "example": "// SSG with getStaticProps\n// pages/blog/[slug].js\nexport default function BlogPost({ post, relatedPosts }) {\n  return (\n    <article>\n      <h1>{post.title}</h1>\n      <p>{post.excerpt}</p>\n      <div dangerouslySetInnerHTML={{ __html: post.content }} />\n      \n      <aside>\n        <h3>Related Posts</h3>\n        {relatedPosts.map(post => (\n          <Link key={post.slug} href={`/blog/${post.slug}`}>\n            <a>{post.title}</a>\n          </Link>\n        ))}\n      </aside>\n    </article>\n  )\n}\n\n// Generate static paths at build time\nexport async function getStaticPaths() {\n  const posts = await getAllPosts()\n  \n  const paths = posts.map(post => ({\n    params: { slug: post.slug }\n  }))\n  \n  return {\n    paths,\n    fallback: 'blocking' // Enable ISR for new posts\n  }\n}\n\n// Fetch data at build time\nexport async function getStaticProps({ params }) {\n  const post = await getPostBySlug(params.slug)\n  const relatedPosts = await getRelatedPosts(post.tags)\n  \n  if (!post) {\n    return { notFound: true }\n  }\n  \n  return {\n    props: {\n      post,\n      relatedPosts\n    },\n    revalidate: 3600 // Revalidate every hour (ISR)\n  }\n}\n\n// Incremental Static Regeneration example\n// pages/products.js\nexport async function getStaticProps() {\n  const products = await fetchProducts()\n  \n  return {\n    props: { products },\n    revalidate: 10 // Regenerate page every 10 seconds if requested\n  }\n}",
                "explanation": "This example demonstrates advanced SSG patterns:\n\n1. getStaticPaths: Defines which dynamic routes to pre-render\n2. fallback: 'blocking': Enables ISR for new content\n3. getStaticProps: Fetches data at build time\n4. revalidate: Enables ISR with time-based regeneration\n5. Related content: Shows how to fetch additional data\n\nThe result is lightning-fast pages that can still update dynamically.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not setting appropriate revalidate intervals",
                  "solution": "Choose revalidate times based on content update frequency",
                  "severity": "medium"
                },
                {
                  "mistake": "Using fallback: false for large datasets",
                  "solution": "Use fallback: 'blocking' or true for scalability",
                  "severity": "medium"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Build a Static Blog with ISR",
                  "description": "Create a blog that updates automatically with ISR",
                  "checkpoints": [
                    "Implement getStaticPaths for all posts",
                    "Add ISR with appropriate revalidate timing",
                    "Handle fallback states properly"
                  ]
                }
              ],
              "next": [
                "nextjs-advanced-lesson-5"
              ],
              "estimatedMinutes": 45,
              "difficulty": "Advanced",
              "tags": [
                "SSG",
                "ISR",
                "Performance",
                "getStaticProps"
              ],
              "lastUpdated": "2025-10-01T12:00:00.000Z",
              "version": "1.0.0"
            },
            {
              "id": "nextjs-advanced-lesson-5",
              "moduleSlug": "nextjs-advanced",
              "title": "API Routes and Backend Integration",
              "order": 5,
              "objectives": [
                "Create and manage API routes in Next.js",
                "Implement authentication and middleware",
                "Connect to databases and external APIs"
              ],
              "intro": "Next.js API routes provide a simple solution to build your API with Next.js. Any file inside pages/api folder is mapped to /api/* and will be treated as an API endpoint instead of a page.\n\nThis feature allows you to build full-stack applications without needing a separate backend server, making deployment and development much simpler.",
              "code": {
                "example": "// pages/api/users/[id].js\nimport { NextApiRequest, NextApiResponse } from 'next'\nimport { connectToDatabase } from '../../../lib/mongodb'\nimport { verifyToken } from '../../../lib/auth'\n\nexport default async function handler(req: NextApiRequest, res: NextApiResponse) {\n  const { method, query: { id }, headers } = req\n  \n  // Verify authentication\n  const token = headers.authorization?.replace('Bearer ', '')\n  const user = await verifyToken(token)\n  \n  if (!user) {\n    return res.status(401).json({ error: 'Unauthorized' })\n  }\n  \n  const { db } = await connectToDatabase()\n  \n  switch (method) {\n    case 'GET':\n      try {\n        const userData = await db.collection('users').findOne({ _id: id })\n        if (!userData) {\n          return res.status(404).json({ error: 'User not found' })\n        }\n        res.status(200).json(userData)\n      } catch (error) {\n        res.status(500).json({ error: 'Failed to fetch user' })\n      }\n      break\n      \n    case 'PUT':\n      try {\n        const { name, email } = req.body\n        const result = await db.collection('users').updateOne(\n          { _id: id },\n          { $set: { name, email, updatedAt: new Date() } }\n        )\n        res.status(200).json({ message: 'User updated successfully' })\n      } catch (error) {\n        res.status(500).json({ error: 'Failed to update user' })\n      }\n      break\n      \n    case 'DELETE':\n      try {\n        await db.collection('users').deleteOne({ _id: id })\n        res.status(200).json({ message: 'User deleted successfully' })\n      } catch (error) {\n        res.status(500).json({ error: 'Failed to delete user' })\n      }\n      break\n      \n    default:\n      res.setHeader('Allow', ['GET', 'PUT', 'DELETE'])\n      res.status(405).end(`Method ${method} Not Allowed`)\n  }\n}\n\n// pages/api/auth/login.js\nexport default async function handler(req, res) {\n  if (req.method !== 'POST') {\n    return res.status(405).json({ error: 'Method not allowed' })\n  }\n  \n  const { email, password } = req.body\n  \n  try {\n    const user = await authenticateUser(email, password)\n    const token = generateJWT(user)\n    \n    // Set HTTP-only cookie\n    res.setHeader('Set-Cookie', `token=${token}; HttpOnly; Secure; SameSite=Strict; Path=/`)\n    \n    res.status(200).json({ user: { id: user.id, email: user.email } })\n  } catch (error) {\n    res.status(401).json({ error: 'Invalid credentials' })\n  }\n}",
                "explanation": "This example shows comprehensive API route implementation:\n\n1. Dynamic routes: [id].js for parameterized endpoints\n2. HTTP method handling: GET, PUT, DELETE\n3. Authentication: Token verification\n4. Database integration: MongoDB connection\n5. Error handling: Proper status codes and messages\n6. Security: HttpOnly cookies, input validation\n\nAPI routes run on the server and can access databases directly.",
                "language": "typescript"
              },
              "pitfalls": [
                {
                  "mistake": "Not validating input data",
                  "solution": "Always validate and sanitize user input",
                  "severity": "high"
                },
                {
                  "mistake": "Exposing sensitive data in API responses",
                  "solution": "Filter sensitive fields before sending responses",
                  "severity": "high"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Build a User Management API",
                  "description": "Create CRUD operations for user management",
                  "checkpoints": [
                    "Implement all HTTP methods",
                    "Add authentication middleware",
                    "Connect to a database"
                  ]
                }
              ],
              "next": [
                "nextjs-advanced-lesson-6"
              ],
              "estimatedMinutes": 50,
              "difficulty": "Advanced",
              "tags": [
                "API Routes",
                "Backend",
                "Authentication",
                "Database"
              ],
              "lastUpdated": "2025-10-01T12:00:00.000Z",
              "version": "1.0.0"
            },
            {
              "id": "nextjs-advanced-lesson-6",
              "moduleSlug": "nextjs-advanced",
              "title": "Image Optimization and Performance",
              "order": 6,
              "objectives": [
                "Master Next.js Image component",
                "Implement lazy loading and optimization",
                "Optimize Core Web Vitals"
              ],
              "intro": "Next.js provides automatic image optimization through the built-in Image component, which includes lazy loading, responsive images, and modern format serving.\n\nImage optimization is crucial for web performance and user experience, especially on mobile devices and slow connections.",
              "code": {
                "example": "import Image from 'next/image'\nimport profilePic from '../public/profile.jpg'\n\n// Basic usage\nexport default function Profile() {\n  return (\n    <div>\n      <Image\n        src={profilePic}\n        alt=\"Picture of the author\"\n        width={500}\n        height={500}\n        priority // Load immediately\n      />\n    </div>\n  )\n}\n\n// Remote images with domains configuration\n// next.config.js\nmodule.exports = {\n  images: {\n    domains: ['example.com', 'cdn.example.com'],\n    deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840],\n    imageSizes: [16, 32, 48, 64, 96, 128, 256, 384],\n    formats: ['image/webp', 'image/avif']\n  }\n}\n\n// Responsive images\nfunction ResponsiveImage() {\n  return (\n    <Image\n      src=\"/hero-image.jpg\"\n      alt=\"Hero image\"\n      fill\n      style={{\n        objectFit: 'cover'\n      }}\n      sizes=\"(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw\"\n    />\n  )\n}",
                "explanation": "Next.js Image optimization provides:\n\n1. Automatic format detection (WebP, AVIF)\n2. Responsive image serving\n3. Lazy loading by default\n4. Placeholder generation\n5. Size optimization\n\nThis dramatically improves Core Web Vitals scores.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not specifying image dimensions",
                  "solution": "Always provide width and height or use fill prop",
                  "severity": "medium"
                },
                {
                  "mistake": "Not configuring remote image domains",
                  "solution": "Add all external domains to next.config.js",
                  "severity": "high"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Optimize a Photo Gallery",
                  "description": "Build a responsive photo gallery with optimized images",
                  "checkpoints": [
                    "Implement Image component with proper sizing",
                    "Add lazy loading and placeholders",
                    "Configure remote image domains"
                  ]
                }
              ],
              "next": [
                "nextjs-advanced-lesson-7"
              ],
              "estimatedMinutes": 35,
              "difficulty": "Intermediate",
              "tags": [
                "Images",
                "Performance",
                "Optimization",
                "Core Web Vitals"
              ],
              "lastUpdated": "2025-10-01T12:00:00.000Z",
              "version": "1.0.0"
            },
            {
              "id": "nextjs-advanced-lesson-7",
              "moduleSlug": "nextjs-advanced",
              "title": "Middleware and Edge Functions",
              "order": 7,
              "objectives": [
                "Implement Next.js middleware",
                "Handle authentication at the edge",
                "Optimize performance with edge computing"
              ],
              "intro": "Next.js Middleware allows you to run code before a request is completed. Based on the user's request, you can modify the response by rewriting, redirecting, modifying headers, or setting cookies.\n\nMiddleware runs at the Edge Runtime, providing exceptional performance for authentication, redirects, and request/response modifications.",
              "code": {
                "example": "// middleware.ts\nimport { NextRequest, NextResponse } from 'next/server'\nimport { verify } from 'jsonwebtoken'\n\nexport function middleware(request: NextRequest) {\n  const { pathname } = request.nextUrl\n  \n  // Skip middleware for public paths\n  if (pathname.startsWith('/api/auth') || pathname.startsWith('/_next')) {\n    return NextResponse.next()\n  }\n  \n  // Authentication check\n  const token = request.cookies.get('token')?.value\n  \n  if (pathname.startsWith('/dashboard')) {\n    if (!token) {\n      return NextResponse.redirect(new URL('/login', request.url))\n    }\n    \n    try {\n      verify(token, process.env.JWT_SECRET!)\n      return NextResponse.next()\n    } catch {\n      return NextResponse.redirect(new URL('/login', request.url))\n    }\n  }\n  \n  // A/B Testing\n  if (pathname === '/') {\n    const bucket = request.cookies.get('bucket')?.value\n    \n    if (!bucket) {\n      const newBucket = Math.random() < 0.5 ? 'A' : 'B'\n      const response = NextResponse.next()\n      response.cookies.set('bucket', newBucket)\n      \n      if (newBucket === 'B') {\n        return NextResponse.rewrite(new URL('/home-variant', request.url))\n      }\n    }\n  }\n  \n  // Geolocation redirect\n  const country = request.geo?.country || 'US'\n  if (pathname === '/store' && country === 'GB') {\n    return NextResponse.redirect(new URL('/store/uk', request.url))\n  }\n  \n  // Security headers\n  const response = NextResponse.next()\n  response.headers.set('X-Frame-Options', 'DENY')\n  response.headers.set('X-Content-Type-Options', 'nosniff')\n  \n  return response\n}\n\nexport const config = {\n  matcher: [\n    '/((?!api|_next/static|_next/image|favicon.ico).*)',\n  ]\n}",
                "explanation": "This middleware demonstrates:\n\n1. Authentication: Token verification and redirects\n2. A/B Testing: Random bucket assignment\n3. Geolocation: Country-based redirects\n4. Security: Adding security headers\n5. Performance: Running at the edge\n\nMiddleware runs before pages and API routes.",
                "language": "typescript"
              },
              "pitfalls": [
                {
                  "mistake": "Running heavy computations in middleware",
                  "solution": "Keep middleware lightweight for edge performance",
                  "severity": "medium"
                },
                {
                  "mistake": "Not configuring matcher correctly",
                  "solution": "Use specific matchers to avoid unnecessary executions",
                  "severity": "medium"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Build Authentication Middleware",
                  "description": "Create middleware for route protection and redirects",
                  "checkpoints": [
                    "Implement token verification",
                    "Add protected route redirects",
                    "Configure proper matchers"
                  ]
                }
              ],
              "next": [
                "nextjs-advanced-lesson-8"
              ],
              "estimatedMinutes": 40,
              "difficulty": "Advanced",
              "tags": [
                "Middleware",
                "Edge",
                "Authentication",
                "Performance"
              ],
              "lastUpdated": "2025-10-01T12:00:00.000Z",
              "version": "1.0.0"
            },
            {
              "id": "nextjs-advanced-lesson-8",
              "moduleSlug": "nextjs-advanced",
              "title": "Advanced Data Fetching Patterns",
              "order": 8,
              "objectives": [
                "Master SWR and React Query integration",
                "Implement efficient caching strategies",
                "Handle complex data dependencies"
              ],
              "intro": "Advanced data fetching in Next.js goes beyond the built-in methods to include client-side libraries like SWR and React Query for sophisticated caching, revalidation, and state management.\n\nThese patterns are essential for building responsive, efficient applications that provide excellent user experience.",
              "code": {
                "example": "// Using SWR for client-side data fetching\nimport useSWR, { mutate } from 'swr'\nimport { useUser } from '../lib/auth'\n\nconst fetcher = (url: string) => fetch(url).then(r => r.json())\n\nfunction Profile() {\n  const { user } = useUser()\n  const { data, error, isLoading } = useSWR(\n    user ? `/api/user/${user.id}` : null,\n    fetcher,\n    {\n      refreshInterval: 30000, // Refresh every 30 seconds\n      revalidateOnFocus: true,\n      revalidateOnReconnect: true\n    }\n  )\n\n  if (error) return <div>Failed to load profile</div>\n  if (isLoading) return <div>Loading...</div>\n\n  return (\n    <div>\n      <h1>{data.name}</h1>\n      <p>{data.email}</p>\n      <button onClick={() => mutate(`/api/user/${user.id}`)}>\n        Refresh\n      </button>\n    </div>\n  )\n}\n\n// React Query with Next.js\nimport { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'\nimport { dehydrate, QueryClient } from '@tanstack/react-query'\n\nfunction PostsList() {\n  const queryClient = useQueryClient()\n  \n  const { data: posts, isLoading } = useQuery({\n    queryKey: ['posts'],\n    queryFn: () => fetch('/api/posts').then(res => res.json()),\n    staleTime: 5 * 60 * 1000, // 5 minutes\n  })\n\n  const deletePostMutation = useMutation({\n    mutationFn: (id: string) => fetch(`/api/posts/${id}`, { method: 'DELETE' }),\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: ['posts'] })\n    }\n  })\n\n  return (\n    <div>\n      {posts?.map(post => (\n        <div key={post.id}>\n          <h3>{post.title}</h3>\n          <button onClick={() => deletePostMutation.mutate(post.id)}>\n            Delete\n          </button>\n        </div>\n      ))}\n    </div>\n  )\n}\n\n// Server-side data prefetching\nexport async function getServerSideProps() {\n  const queryClient = new QueryClient()\n\n  await queryClient.prefetchQuery({\n    queryKey: ['posts'],\n    queryFn: () => fetch('http://localhost:3000/api/posts').then(res => res.json())\n  })\n\n  return {\n    props: {\n      dehydratedState: dehydrate(queryClient)\n    }\n  }\n}",
                "explanation": "Advanced data fetching patterns include:\n\n1. SWR: Automatic revalidation and caching\n2. React Query: Powerful state management for server state\n3. Optimistic updates: UI updates before server confirmation\n4. Background revalidation: Keep data fresh\n5. Server-side prefetching: Hydrate client cache\n\nThese patterns eliminate loading states and provide smooth UX.",
                "language": "typescript"
              },
              "pitfalls": [
                {
                  "mistake": "Over-fetching data on every render",
                  "solution": "Use proper cache keys and stale times",
                  "severity": "medium"
                },
                {
                  "mistake": "Not handling loading and error states",
                  "solution": "Always provide fallbacks for loading and error states",
                  "severity": "medium"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Build a Real-time Dashboard",
                  "description": "Create a dashboard with SWR and optimistic updates",
                  "checkpoints": [
                    "Implement SWR for data fetching",
                    "Add optimistic updates for mutations",
                    "Configure proper caching strategies"
                  ]
                }
              ],
              "next": [
                "nextjs-advanced-lesson-9"
              ],
              "estimatedMinutes": 45,
              "difficulty": "Advanced",
              "tags": [
                "SWR",
                "React Query",
                "Caching",
                "Data Fetching"
              ],
              "lastUpdated": "2025-10-01T12:00:00.000Z",
              "version": "1.0.0"
            },
            {
              "id": "nextjs-advanced-lesson-9",
              "moduleSlug": "nextjs-advanced",
              "title": "Authentication and Security",
              "order": 9,
              "objectives": [
                "Implement NextAuth.js for authentication",
                "Secure API routes and pages",
                "Handle multiple authentication providers"
              ],
              "intro": "Authentication is a critical aspect of modern web applications. NextAuth.js provides a complete authentication solution for Next.js applications with support for multiple providers, sessions, and security best practices.",
              "code": {
                "example": "// pages/api/auth/[...nextauth].ts\nimport NextAuth from 'next-auth'\nimport GoogleProvider from 'next-auth/providers/google'\nimport CredentialsProvider from 'next-auth/providers/credentials'\nimport { MongoDBAdapter } from '@next-auth/mongodb-adapter'\nimport { MongoClient } from 'mongodb'\n\nconst client = new MongoClient(process.env.MONGODB_URI!)\nconst clientPromise = client.connect()\n\nexport default NextAuth({\n  adapter: MongoDBAdapter(clientPromise),\n  providers: [\n    GoogleProvider({\n      clientId: process.env.GOOGLE_CLIENT_ID!,\n      clientSecret: process.env.GOOGLE_CLIENT_SECRET!\n    }),\n    CredentialsProvider({\n      name: 'credentials',\n      credentials: {\n        email: { label: 'Email', type: 'email' },\n        password: { label: 'Password', type: 'password' }\n      },\n      async authorize(credentials) {\n        const user = await authenticateUser(credentials?.email, credentials?.password)\n        return user ? { id: user.id, email: user.email, name: user.name } : null\n      }\n    })\n  ],\n  callbacks: {\n    async jwt({ token, user }) {\n      if (user) {\n        token.role = user.role\n      }\n      return token\n    },\n    async session({ session, token }) {\n      session.user.role = token.role\n      return session\n    }\n  },\n  pages: {\n    signIn: '/auth/signin',\n    error: '/auth/error'\n  },\n  session: {\n    strategy: 'jwt',\n    maxAge: 30 * 24 * 60 * 60 // 30 days\n  }\n})\n\n// Using authentication in components\nimport { useSession, signIn, signOut } from 'next-auth/react'\n\nfunction LoginButton() {\n  const { data: session, status } = useSession()\n\n  if (status === 'loading') return <p>Loading...</p>\n\n  if (session) {\n    return (\n      <div>\n        <p>Signed in as {session.user?.email}</p>\n        <button onClick={() => signOut()}>Sign out</button>\n      </div>\n    )\n  }\n  \n  return (\n    <div>\n      <p>Not signed in</p>\n      <button onClick={() => signIn()}>Sign in</button>\n    </div>\n  )\n}\n\n// Protecting pages with getServerSideProps\nexport async function getServerSideProps(context) {\n  const session = await getSession(context)\n\n  if (!session) {\n    return {\n      redirect: {\n        destination: '/api/auth/signin',\n        permanent: false\n      }\n    }\n  }\n\n  return {\n    props: { session }\n  }\n}",
                "explanation": "NextAuth.js provides:\n\n1. Multiple authentication providers (Google, GitHub, etc.)\n2. Database adapters for session storage\n3. JWT and database sessions\n4. Custom authentication logic\n5. Role-based access control\n6. Secure session management\n\nThe solution handles all security concerns automatically.",
                "language": "typescript"
              },
              "pitfalls": [
                {
                  "mistake": "Not securing API routes properly",
                  "solution": "Always verify sessions in API routes",
                  "severity": "high"
                },
                {
                  "mistake": "Storing sensitive data in JWT tokens",
                  "solution": "Keep JWTs minimal, store sensitive data in database",
                  "severity": "high"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Build Authentication System",
                  "description": "Implement complete authentication with multiple providers",
                  "checkpoints": [
                    "Set up NextAuth.js with Google provider",
                    "Add custom credentials provider",
                    "Protect pages and API routes"
                  ]
                }
              ],
              "next": [
                "nextjs-advanced-lesson-10"
              ],
              "estimatedMinutes": 50,
              "difficulty": "Advanced",
              "tags": [
                "Authentication",
                "NextAuth",
                "Security",
                "JWT"
              ],
              "lastUpdated": "2025-10-01T12:00:00.000Z",
              "version": "1.0.0"
            },
            {
              "id": "nextjs-advanced-lesson-10",
              "moduleSlug": "nextjs-advanced",
              "title": "Deployment and Production Optimization",
              "order": 10,
              "objectives": [
                "Deploy Next.js applications to various platforms",
                "Optimize for production performance",
                "Implement monitoring and analytics"
              ],
              "intro": "Deploying Next.js applications requires understanding of various hosting options, optimization techniques, and monitoring strategies to ensure optimal performance in production.",
              "code": {
                "example": "// next.config.js - Production optimization\nconst nextConfig = {\n  // Enable experimental features\n  experimental: {\n    appDir: true,\n    serverComponentsExternalPackages: ['mongoose']\n  },\n  \n  // Image optimization\n  images: {\n    domains: ['cdn.example.com'],\n    formats: ['image/webp', 'image/avif'],\n    minimumCacheTTL: 60\n  },\n  \n  // Compression and headers\n  compress: true,\n  poweredByHeader: false,\n  \n  // Custom headers for security\n  async headers() {\n    return [\n      {\n        source: '/(.*)',\n        headers: [\n          {\n            key: 'X-Frame-Options',\n            value: 'DENY'\n          },\n          {\n            key: 'X-Content-Type-Options',\n            value: 'nosniff'\n          },\n          {\n            key: 'Referrer-Policy',\n            value: 'origin-when-cross-origin'\n          }\n        ]\n      }\n    ]\n  },\n  \n  // Redirects for SEO\n  async redirects() {\n    return [\n      {\n        source: '/old-page',\n        destination: '/new-page',\n        permanent: true\n      }\n    ]\n  },\n  \n  // Bundle analyzer\n  webpack: (config, { isServer }) => {\n    if (!isServer) {\n      config.resolve.fallback = {\n        fs: false,\n        net: false,\n        tls: false\n      }\n    }\n    return config\n  }\n}\n\nmodule.exports = nextConfig\n\n// Vercel deployment configuration\n// vercel.json\n{\n  \"functions\": {\n    \"pages/api/**/*.js\": {\n      \"maxDuration\": 30\n    }\n  },\n  \"regions\": [\"iad1\"],\n  \"env\": {\n    \"NODE_ENV\": \"production\"\n  }\n}\n\n// Docker deployment\n# Dockerfile\nFROM node:18-alpine AS base\n\n# Install dependencies\nFROM base AS deps\nRUN apk add --no-cache libc6-compat\nWORKDIR /app\nCOPY package.json package-lock.json* ./\nRUN npm ci\n\n# Build application\nFROM base AS builder\nWORKDIR /app\nCOPY --from=deps /app/node_modules ./node_modules\nCOPY . .\nRUN npm run build\n\n# Production image\nFROM base AS runner\nWORKDIR /app\nENV NODE_ENV production\nRUN addgroup --system --gid 1001 nodejs\nRUN adduser --system --uid 1001 nextjs\n\nCOPY --from=builder /app/public ./public\nCOPY --from=builder --chown=nextjs:nodejs /app/.next/standalone ./\nCOPY --from=builder --chown=nextjs:nodejs /app/.next/static ./.next/static\n\nUSER nextjs\nEXPOSE 3000\nENV PORT 3000\nCMD [\"node\", \"server.js\"]",
                "explanation": "Production deployment involves:\n\n1. Configuration optimization: Compression, headers, security\n2. Platform-specific setup: Vercel, Docker, AWS\n3. Performance monitoring: Core Web Vitals, analytics\n4. Security hardening: Headers, environment variables\n5. CDN optimization: Static assets, images\n\nProper deployment ensures optimal performance and security.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not optimizing for Core Web Vitals",
                  "solution": "Use Lighthouse and optimize images, fonts, and loading",
                  "severity": "medium"
                },
                {
                  "mistake": "Exposing sensitive environment variables",
                  "solution": "Use proper environment variable management",
                  "severity": "high"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Deploy to Production",
                  "description": "Deploy a Next.js app with proper optimization",
                  "checkpoints": [
                    "Configure production settings",
                    "Deploy to Vercel or Docker",
                    "Set up monitoring and analytics"
                  ]
                }
              ],
              "next": [
                "nextjs-advanced-lesson-11"
              ],
              "estimatedMinutes": 45,
              "difficulty": "Advanced",
              "tags": [
                "Deployment",
                "Production",
                "Optimization",
                "Security"
              ],
              "lastUpdated": "2025-10-01T12:00:00.000Z",
              "version": "1.0.0"
            },
            {
              "id": "nextjs-advanced-lesson-11",
              "moduleSlug": "nextjs-advanced",
              "title": "Testing Next.js Applications",
              "order": 11,
              "objectives": [
                "Implement unit testing for components and API routes",
                "Set up integration and E2E testing",
                "Test SSR and SSG functionality"
              ],
              "intro": "Testing Next.js applications requires understanding of different testing strategies for components, API routes, and the various rendering methods that Next.js provides.",
              "code": {
                "example": "// jest.config.js\nconst nextJest = require('next/jest')\n\nconst createJestConfig = nextJest({\n  dir: './'\n})\n\nconst customJestConfig = {\n  setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],\n  moduleNameMapping: {\n    '^@/components/(.*)$': '<rootDir>/components/$1',\n    '^@/pages/(.*)$': '<rootDir>/pages/$1'\n  },\n  testEnvironment: 'jest-environment-jsdom'\n}\n\nmodule.exports = createJestConfig(customJestConfig)\n\n// Component testing\nimport { render, screen, fireEvent } from '@testing-library/react'\nimport { SessionProvider } from 'next-auth/react'\nimport LoginForm from '../components/LoginForm'\n\nconst mockSession = {\n  user: { email: 'test@example.com' },\n  expires: '2024-01-01'\n}\n\ndescribe('LoginForm', () => {\n  it('renders login form correctly', () => {\n    render(\n      <SessionProvider session={null}>\n        <LoginForm />\n      </SessionProvider>\n    )\n    \n    expect(screen.getByLabelText(/email/i)).toBeInTheDocument()\n    expect(screen.getByLabelText(/password/i)).toBeInTheDocument()\n    expect(screen.getByRole('button', { name: /sign in/i })).toBeInTheDocument()\n  })\n  \n  it('handles form submission', async () => {\n    const mockSignIn = jest.fn()\n    jest.mock('next-auth/react', () => ({\n      ...jest.requireActual('next-auth/react'),\n      signIn: mockSignIn\n    }))\n    \n    render(<LoginForm />)\n    \n    fireEvent.change(screen.getByLabelText(/email/i), {\n      target: { value: 'test@example.com' }\n    })\n    fireEvent.change(screen.getByLabelText(/password/i), {\n      target: { value: 'password' }\n    })\n    fireEvent.click(screen.getByRole('button', { name: /sign in/i }))\n    \n    expect(mockSignIn).toHaveBeenCalledWith('credentials', {\n      email: 'test@example.com',\n      password: 'password'\n    })\n  })\n})\n\n// API route testing\nimport { createMocks } from 'node-mocks-http'\nimport handler from '../pages/api/users/[id]'\n\ndescribe('/api/users/[id]', () => {\n  it('returns user data for GET request', async () => {\n    const { req, res } = createMocks({\n      method: 'GET',\n      query: { id: '123' }\n    })\n    \n    await handler(req, res)\n    \n    expect(res._getStatusCode()).toBe(200)\n    const data = JSON.parse(res._getData())\n    expect(data).toHaveProperty('id', '123')\n  })\n  \n  it('returns 404 for non-existent user', async () => {\n    const { req, res } = createMocks({\n      method: 'GET',\n      query: { id: 'non-existent' }\n    })\n    \n    await handler(req, res)\n    \n    expect(res._getStatusCode()).toBe(404)\n  })\n})\n\n// E2E testing with Playwright\nimport { test, expect } from '@playwright/test'\n\ntest.describe('Authentication Flow', () => {\n  test('should login and access protected page', async ({ page }) => {\n    await page.goto('/login')\n    \n    await page.fill('[data-testid=email]', 'test@example.com')\n    await page.fill('[data-testid=password]', 'password')\n    await page.click('[data-testid=submit]')\n    \n    await expect(page).toHaveURL('/dashboard')\n    await expect(page.locator('h1')).toContainText('Dashboard')\n  })\n  \n  test('should redirect to login when accessing protected page', async ({ page }) => {\n    await page.goto('/dashboard')\n    await expect(page).toHaveURL('/login')\n  })\n})",
                "explanation": "Next.js testing covers:\n\n1. Unit tests: Components and utilities\n2. Integration tests: API routes and data fetching\n3. E2E tests: Full user workflows\n4. SSR/SSG testing: Server-side functionality\n5. Mock strategies: External dependencies\n\nProper testing ensures application reliability and maintainability.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not testing server-side functionality",
                  "solution": "Test API routes and SSR/SSG functions separately",
                  "severity": "medium"
                },
                {
                  "mistake": "Not mocking external dependencies",
                  "solution": "Mock APIs, databases, and third-party services",
                  "severity": "medium"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Comprehensive Test Suite",
                  "description": "Build a complete testing setup for a Next.js app",
                  "checkpoints": [
                    "Set up Jest and Testing Library",
                    "Write component and API tests",
                    "Add E2E tests with Playwright"
                  ]
                }
              ],
              "next": [
                "nextjs-advanced-lesson-12"
              ],
              "estimatedMinutes": 50,
              "difficulty": "Advanced",
              "tags": [
                "Testing",
                "Jest",
                "Playwright",
                "E2E"
              ],
              "lastUpdated": "2025-10-01T12:00:00.000Z",
              "version": "1.0.0"
            },
            {
              "id": "nextjs-advanced-lesson-12",
              "moduleSlug": "nextjs-advanced",
              "title": "Advanced Next.js Patterns and Best Practices",
              "order": 12,
              "objectives": [
                "Implement advanced architectural patterns",
                "Optimize performance with advanced techniques",
                "Follow Next.js best practices for enterprise applications"
              ],
              "intro": "This final lesson covers advanced patterns, architectural decisions, and best practices for building large-scale Next.js applications in enterprise environments.",
              "code": {
                "example": "// Advanced error boundary with Next.js\nimport { ErrorBoundary } from 'react-error-boundary'\nimport { useRouter } from 'next/router'\n\nfunction ErrorFallback({ error, resetErrorBoundary }) {\n  const router = useRouter()\n  \n  return (\n    <div role=\"alert\" className=\"error-boundary\">\n      <h2>Something went wrong</h2>\n      <pre>{error.message}</pre>\n      <button onClick={resetErrorBoundary}>Try again</button>\n      <button onClick={() => router.push('/')}>Go home</button>\n    </div>\n  )\n}\n\n// Higher-order component for error boundaries\nexport function withErrorBoundary<T>(Component: React.ComponentType<T>) {\n  return function WrappedComponent(props: T) {\n    return (\n      <ErrorBoundary\n        FallbackComponent={ErrorFallback}\n        onError={(error, errorInfo) => {\n          console.error('Error boundary caught an error:', error, errorInfo)\n          // Send to error reporting service\n        }}\n      >\n        <Component {...props} />\n      </ErrorBoundary>\n    )\n  }\n}\n\n// Advanced layout pattern\ntype LayoutProps = {\n  children: React.ReactNode\n  title?: string\n  description?: string\n}\n\nexport function AppLayout({ children, title, description }: LayoutProps) {\n  return (\n    <>\n      <Head>\n        <title>{title ? `${title} | MyApp` : 'MyApp'}</title>\n        <meta name=\"description\" content={description || 'Default description'} />\n      </Head>\n      <Header />\n      <main className=\"min-h-screen\">\n        {children}\n      </main>\n      <Footer />\n    </>\n  )\n}\n\n// Page with layout\nconst AboutPage = () => {\n  return (\n    <AppLayout title=\"About\" description=\"Learn about our company\">\n      <div>About content</div>\n    </AppLayout>\n  )\n}\n\n// Performance optimization with React.memo and useMemo\nimport { memo, useMemo } from 'react'\n\ninterface ProductListProps {\n  products: Product[]\n  filters: FilterState\n}\n\nconst ProductList = memo(({ products, filters }: ProductListProps) => {\n  const filteredProducts = useMemo(() => {\n    return products.filter(product => {\n      return (!filters.category || product.category === filters.category) &&\n             (!filters.priceRange || isInPriceRange(product.price, filters.priceRange))\n    })\n  }, [products, filters])\n  \n  return (\n    <div className=\"grid grid-cols-1 md:grid-cols-3 gap-4\">\n      {filteredProducts.map(product => (\n        <ProductCard key={product.id} product={product} />\n      ))}\n    </div>\n  )\n})\n\n// Custom hook for data management\nfunction useProductData(initialFilters: FilterState) {\n  const [filters, setFilters] = useState(initialFilters)\n  const [isLoading, setIsLoading] = useState(false)\n  \n  const { data: products, error } = useSWR(\n    ['products', filters],\n    ([_, filters]) => fetchProducts(filters),\n    {\n      revalidateOnFocus: false,\n      dedupingInterval: 10000\n    }\n  )\n  \n  const updateFilters = useCallback((newFilters: Partial<FilterState>) => {\n    setFilters(prev => ({ ...prev, ...newFilters }))\n  }, [])\n  \n  return {\n    products: products || [],\n    filters,\n    updateFilters,\n    isLoading,\n    error\n  }\n}",
                "explanation": "Advanced Next.js patterns include:\n\n1. Error boundaries: Graceful error handling\n2. Layout patterns: Reusable page structures\n3. Performance optimization: Memoization and code splitting\n4. Custom hooks: Reusable state logic\n5. TypeScript integration: Type safety\n6. Error reporting: Production monitoring\n\nThese patterns ensure maintainable, scalable applications.",
                "language": "typescript"
              },
              "pitfalls": [
                {
                  "mistake": "Over-optimizing with useMemo and useCallback",
                  "solution": "Profile before optimizing, focus on actual bottlenecks",
                  "severity": "low"
                },
                {
                  "mistake": "Not implementing proper error boundaries",
                  "solution": "Add error boundaries at appropriate component levels",
                  "severity": "medium"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Enterprise-Ready Application",
                  "description": "Build a scalable Next.js application with all best practices",
                  "checkpoints": [
                    "Implement error boundaries and error handling",
                    "Create reusable layout patterns",
                    "Add performance optimizations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 55,
              "difficulty": "Advanced",
              "tags": [
                "Architecture",
                "Performance",
                "Best Practices",
                "Enterprise"
              ],
              "lastUpdated": "2025-10-01T12:00:00.000Z",
              "version": "1.0.0"
            },
            {
              "id": "nextjs-advanced-lesson-13",
              "moduleSlug": "nextjs-advanced",
              "title": "Real-time Features with WebSockets",
              "order": 13,
              "objectives": [
                "Implement WebSocket connections in Next.js applications",
                "Build real-time chat and notification systems",
                "Handle connection states and error recovery"
              ],
              "intro": "Real-time features are essential for modern web applications, from live chat systems to collaborative editing and real-time notifications. Next.js provides excellent support for WebSocket integration through API routes and custom server configurations.\n\nWebSockets enable bidirectional communication between the client and server, allowing for instant updates and interactive experiences that keep users engaged. This is particularly important for applications like social media platforms, trading dashboards, collaborative tools, and gaming applications.\n\nIn this comprehensive lesson, you'll learn to implement robust WebSocket solutions that handle connection management, error recovery, and state synchronization. We'll explore both simple implementations using socket.io and advanced patterns for scaling real-time features in production environments.\n\nBy the end of this lesson, you'll be equipped to build sophisticated real-time applications that provide seamless user experiences and maintain reliable connections even in challenging network conditions.",
              "code": {
                "example": "// Custom server with Socket.io\n// server.js\nconst express = require('express')\nconst next = require('next')\nconst { createServer } = require('http')\nconst { Server } = require('socket.io')\n\nconst dev = process.env.NODE_ENV !== 'production'\nconst app = next({ dev })\nconst handle = app.getRequestHandler()\n\napp.prepare().then(() => {\n  const server = express()\n  const httpServer = createServer(server)\n  const io = new Server(httpServer, {\n    cors: {\n      origin: process.env.CORS_ORIGIN || 'http://localhost:3000',\n      methods: ['GET', 'POST']\n    }\n  })\n\n  // Socket.io connection handling\n  io.on('connection', (socket) => {\n    console.log('User connected:', socket.id)\n\n    // Join user to specific rooms\n    socket.on('join-room', (roomId) => {\n      socket.join(roomId)\n      socket.to(roomId).emit('user-joined', {\n        userId: socket.id,\n        timestamp: new Date().toISOString()\n      })\n    })\n\n    // Handle chat messages\n    socket.on('send-message', async (data) => {\n      const { roomId, message, userId } = data\n      \n      // Validate and sanitize message\n      if (!message || message.trim().length === 0) return\n      \n      const messageData = {\n        id: Date.now().toString(),\n        message: message.trim(),\n        userId,\n        timestamp: new Date().toISOString()\n      }\n      \n      // Save to database\n      await saveMessage(messageData)\n      \n      // Broadcast to room\n      io.to(roomId).emit('new-message', messageData)\n    })\n\n    // Handle typing indicators\n    socket.on('typing', (data) => {\n      socket.to(data.roomId).emit('user-typing', {\n        userId: socket.id,\n        isTyping: data.isTyping\n      })\n    })\n\n    // Handle disconnection\n    socket.on('disconnect', () => {\n      console.log('User disconnected:', socket.id)\n    })\n  })\n\n  server.all('*', (req, res) => {\n    return handle(req, res)\n  })\n\n  const PORT = process.env.PORT || 3000\n  httpServer.listen(PORT, () => {\n    console.log(`Server running on port ${PORT}`)\n  })\n})",
                "explanation": "This WebSocket implementation demonstrates real-time communication with Socket.io, including room management, message broadcasting, and connection handling for building interactive applications.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not handling connection drops and reconnection",
                  "solution": "Implement proper error handling and automatic reconnection logic",
                  "severity": "high"
                },
                {
                  "mistake": "Exposing sensitive data through WebSocket messages",
                  "solution": "Always validate and sanitize data, implement proper authentication",
                  "severity": "high"
                }
              ],
              "exercises": [
                {
                  "title": "Build a Real-time Chat Application",
                  "description": "Create a chat system with rooms, typing indicators, and message persistence",
                  "checkpoints": [
                    "Set up WebSocket server with Socket.io",
                    "Implement real-time messaging",
                    "Add typing indicators and user presence",
                    "Handle connection states and errors"
                  ]
                }
              ],
              "next": [
                "nextjs-advanced-lesson-14"
              ],
              "estimatedMinutes": 60,
              "difficulty": "Advanced",
              "tags": [
                "WebSockets",
                "Real-time",
                "Socket.io",
                "Chat"
              ],
              "lastUpdated": "2025-01-27T10:15:00.000Z",
              "version": "1.0.0"
            },
            {
              "id": "nextjs-advanced-lesson-14",
              "moduleSlug": "nextjs-advanced",
              "title": "Internationalization (i18n) and Localization",
              "order": 14,
              "objectives": [
                "Implement multi-language support in Next.js applications",
                "Handle locale-specific routing and content delivery",
                "Optimize SEO for international markets"
              ],
              "intro": "Internationalization (i18n) is crucial for reaching global audiences and providing localized experiences that resonate with users from different cultures and languages. Next.js provides built-in support for i18n routing and integrates seamlessly with popular translation libraries.\n\nBuilding multilingual applications involves more than just translating text - you need to consider cultural differences, number formatting, date formats, reading directions, and even color preferences. Next.js i18n features make it easier to create applications that truly serve international markets.\n\nThis lesson covers the complete implementation of i18n in Next.js applications, from basic text translation to advanced features like locale-specific SSG, SEO optimization for different markets, and dynamic content loading. You'll learn to build applications that automatically detect user preferences and provide seamless language switching.\n\nBy mastering i18n patterns, you'll be able to expand your applications to global markets while maintaining excellent performance and user experience across all supported locales.",
              "code": {
                "example": "// next.config.js - i18n configuration\nmodule.exports = {\n  i18n: {\n    locales: ['en', 'es', 'fr', 'de', 'ja'],\n    defaultLocale: 'en',\n    domains: [\n      {\n        domain: 'example.com',\n        defaultLocale: 'en'\n      },\n      {\n        domain: 'example.es',\n        defaultLocale: 'es'\n      }\n    ],\n    localeDetection: true\n  }\n}\n\n// Translation usage with react-i18next\nimport { useTranslation } from 'next-i18next'\nimport { serverSideTranslations } from 'next-i18next/serverSideTranslations'\n\nexport default function HomePage() {\n  const { t } = useTranslation('common')\n\n  return (\n    <div>\n      <h1>{t('welcome')}</h1>\n      <p>{t('description')}</p>\n    </div>\n  )\n}\n\nexport async function getStaticProps({ locale }) {\n  return {\n    props: {\n      ...(await serverSideTranslations(locale, ['common']))\n    }\n  }\n}",
                "explanation": "This i18n implementation shows Next.js built-in internationalization features with react-i18next for translations, locale routing, and server-side rendering support.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not considering cultural differences beyond language",
                  "solution": "Research cultural preferences for colors, layouts, and user interactions",
                  "severity": "medium"
                },
                {
                  "mistake": "Poor SEO implementation for international content",
                  "solution": "Implement proper hreflang tags, canonical URLs, and localized meta data",
                  "severity": "high"
                }
              ],
              "exercises": [
                {
                  "title": "Build a Multilingual Website",
                  "description": "Create a multi-language website with proper SEO and cultural adaptations",
                  "checkpoints": [
                    "Set up i18n configuration for multiple locales",
                    "Implement translation files and components",
                    "Add language switching functionality",
                    "Optimize SEO for international markets"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 50,
              "difficulty": "Advanced",
              "tags": [
                "i18n",
                "Internationalization",
                "Localization",
                "SEO"
              ],
              "lastUpdated": "2025-01-27T10:15:00.000Z",
              "version": "1.0.0"
            }
          ],
          "issues": [
            "Lesson 10: Introduction too short (minimum 200 words)",
            "Lesson 11: Introduction too short (minimum 200 words)",
            "Lesson 12: Introduction too short (minimum 200 words)"
          ]
        },
        "quiz": {
          "exists": true,
          "count": 18,
          "questions": [
            {
              "id": "nextjs-advanced-q1",
              "question": "What is the main difference between SSR and SSG in Next.js?",
              "topic": "Rendering Methods",
              "difficulty": "Intermediate",
              "choices": [
                "SSR renders pages at request time, SSG renders pages at build time",
                "SSR is for dynamic content, SSG is for static content only",
                "SSR uses getServerSideProps, SSG uses getStaticProps",
                "All of the above"
              ],
              "correctIndex": 3,
              "explanation": "All statements are correct. SSR renders pages on each request using getServerSideProps, while SSG pre-renders pages at build time using getStaticProps. The choice depends on how dynamic your content needs to be.",
              "industryContext": "Next.js is widely adopted in enterprise applications for its flexibility in choosing the right rendering strategy based on content requirements.",
              "tags": [
                "SSR",
                "SSG",
                "Rendering",
                "Performance"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 120
            },
            {
              "id": "nextjs-advanced-q2",
              "question": "Which Next.js feature allows you to update statically generated pages after deployment?",
              "topic": "Static Generation",
              "difficulty": "Advanced",
              "choices": [
                "Server-Side Rendering",
                "Incremental Static Regeneration (ISR)",
                "Client-Side Rendering",
                "Dynamic Imports"
              ],
              "correctIndex": 1,
              "explanation": "Incremental Static Regeneration (ISR) allows you to update static content after deployment by setting a revalidate value in getStaticProps. This combines the benefits of static generation with the ability to update content.",
              "industryContext": "ISR is crucial for e-commerce and content sites that need fast loading times but occasionally updated content.",
              "tags": [
                "ISR",
                "Static Generation",
                "Performance"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90
            },
            {
              "id": "nextjs-advanced-q3",
              "question": "How do you create a dynamic API route in Next.js?",
              "topic": "API Routes",
              "difficulty": "Intermediate",
              "choices": [
                "Create a file named [param].js in the pages/api directory",
                "Use the useRouter hook in an API file",
                "Add dynamic: true to the API function",
                "Use getServerSideProps in the API route"
              ],
              "correctIndex": 0,
              "explanation": "Dynamic API routes in Next.js use square brackets in the filename, such as [id].js or [slug].js. The parameter name becomes available in req.query.",
              "industryContext": "Dynamic API routes are essential for RESTful APIs and CRUD operations in full-stack applications.",
              "tags": [
                "API Routes",
                "Dynamic Routing",
                "Backend"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90
            },
            {
              "id": "nextjs-advanced-q4",
              "question": "What is the correct way to optimize images in Next.js?",
              "topic": "Image Optimization",
              "difficulty": "Intermediate",
              "choices": [
                "Use the HTML img tag with manual optimization",
                "Use the Next.js Image component with automatic optimization",
                "Use CSS background-image for all images",
                "Manually convert all images to WebP format"
              ],
              "correctIndex": 1,
              "explanation": "The Next.js Image component provides automatic optimization including lazy loading, responsive images, modern format serving (WebP, AVIF), and size optimization based on device.",
              "industryContext": "Image optimization is critical for Core Web Vitals and user experience, especially on mobile devices and slow connections.",
              "tags": [
                "Images",
                "Performance",
                "Optimization",
                "Core Web Vitals"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90
            },
            {
              "id": "nextjs-advanced-q5",
              "question": "Which function should you use to fetch data on the server before rendering a page?",
              "topic": "Data Fetching",
              "difficulty": "Beginner",
              "choices": [
                "getServerSideProps",
                "getStaticProps",
                "useEffect",
                "Both A and B"
              ],
              "correctIndex": 3,
              "explanation": "Both getServerSideProps (for SSR) and getStaticProps (for SSG) can fetch data on the server before rendering. The choice depends on whether you need data at request time or build time.",
              "industryContext": "Server-side data fetching is essential for SEO and initial page load performance in production applications.",
              "tags": [
                "Data Fetching",
                "SSR",
                "SSG",
                "Performance"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90
            },
            {
              "id": "nextjs-advanced-q6",
              "question": "Which Next.js middleware function runs at the Edge Runtime?",
              "topic": "Middleware",
              "difficulty": "Advanced",
              "choices": [
                "middleware.ts in the root directory",
                "_middleware.js in pages directory",
                "api/middleware.js",
                "components/middleware.tsx"
              ],
              "correctIndex": 0,
              "explanation": "Next.js middleware runs at the Edge Runtime and should be defined in a middleware.ts file in the root directory. It executes before requests are completed and can modify responses.",
              "industryContext": "Edge middleware is crucial for authentication, redirects, and performance optimization in modern web applications.",
              "tags": [
                "Middleware",
                "Edge Runtime",
                "Performance"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90
            },
            {
              "id": "nextjs-advanced-q7",
              "question": "What is the purpose of the revalidate property in getStaticProps?",
              "topic": "ISR",
              "difficulty": "Intermediate",
              "choices": [
                "To enable Incremental Static Regeneration",
                "To set cache headers for the page",
                "To validate form data",
                "To check user authentication"
              ],
              "correctIndex": 0,
              "explanation": "The revalidate property in getStaticProps enables Incremental Static Regeneration (ISR), allowing static pages to be updated in the background after the specified number of seconds.",
              "industryContext": "ISR is essential for sites that need static performance with fresh content, like news sites and e-commerce platforms.",
              "tags": [
                "ISR",
                "Static Generation",
                "Performance"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90
            },
            {
              "id": "nextjs-advanced-q8",
              "question": "How do you create a catch-all dynamic route in Next.js?",
              "topic": "Routing",
              "difficulty": "Intermediate",
              "choices": [
                "[...slug].js",
                "[slug*].js",
                "[slug+].js",
                "[*slug].js"
              ],
              "correctIndex": 0,
              "explanation": "Catch-all routes in Next.js use the [...slug].js syntax with three dots before the parameter name. This captures multiple path segments as an array.",
              "industryContext": "Catch-all routes are useful for CMSs, documentation sites, and flexible routing structures.",
              "tags": [
                "Routing",
                "Dynamic Routes",
                "File System"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90
            },
            {
              "id": "nextjs-advanced-q9",
              "question": "Which Next.js configuration enables automatic image optimization?",
              "topic": "Image Optimization",
              "difficulty": "Beginner",
              "choices": [
                "It's enabled by default with the Image component",
                "images: { optimize: true }",
                "experimental: { imageOptimization: true }",
                "plugins: ['@next/image-optimizer']"
              ],
              "correctIndex": 0,
              "explanation": "Next.js Image optimization is enabled by default when using the next/image component. No additional configuration is required for basic optimization.",
              "industryContext": "Automatic image optimization significantly improves Core Web Vitals and user experience across devices.",
              "tags": [
                "Images",
                "Performance",
                "Optimization"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90
            },
            {
              "id": "nextjs-advanced-q10",
              "question": "What is the correct way to implement API authentication in Next.js?",
              "topic": "API Security",
              "difficulty": "Advanced",
              "choices": [
                "Check authentication in each API route handler",
                "Use middleware to protect API routes",
                "Implement a higher-order function for authentication",
                "All of the above"
              ],
              "correctIndex": 3,
              "explanation": "All approaches are valid for API authentication in Next.js. You can check auth in individual handlers, use middleware for route protection, or create reusable HOFs for authentication logic.",
              "industryContext": "Proper API authentication is critical for security in production applications handling sensitive data.",
              "tags": [
                "Authentication",
                "Security",
                "API Routes"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 120
            },
            {
              "id": "nextjs-advanced-q11",
              "question": "Which deployment platform is specifically optimized for Next.js?",
              "topic": "Deployment",
              "difficulty": "Beginner",
              "choices": [
                "Vercel",
                "Netlify",
                "AWS",
                "Heroku"
              ],
              "correctIndex": 0,
              "explanation": "Vercel is the platform created by the Next.js team and is specifically optimized for Next.js applications, offering zero-config deployments and automatic optimizations.",
              "industryContext": "While Next.js can deploy anywhere, Vercel provides the best developer experience and performance optimizations.",
              "tags": [
                "Deployment",
                "Vercel",
                "Performance"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 60
            },
            {
              "id": "nextjs-advanced-q12",
              "question": "How do you enable internationalization (i18n) in Next.js?",
              "topic": "Internationalization",
              "difficulty": "Intermediate",
              "choices": [
                "Configure i18n in next.config.js",
                "Install react-intl package",
                "Use the useTranslation hook",
                "Add locale files to public directory"
              ],
              "correctIndex": 0,
              "explanation": "Next.js i18n is enabled by configuring the i18n object in next.config.js with locales and defaultLocale. This enables automatic locale detection and routing.",
              "industryContext": "Built-in i18n support is essential for applications targeting global markets and multilingual audiences.",
              "tags": [
                "i18n",
                "Internationalization",
                "Configuration"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90
            },
            {
              "id": "nextjs-advanced-q13",
              "question": "What is the difference between fallback: false and fallback: 'blocking' in getStaticPaths?",
              "topic": "Static Generation",
              "difficulty": "Advanced",
              "choices": [
                "false shows 404 for missing paths, 'blocking' renders them on-demand",
                "false disables ISR, 'blocking' enables it",
                "false is for development, 'blocking' is for production",
                "false uses client-side rendering, 'blocking' uses server-side rendering"
              ],
              "correctIndex": 0,
              "explanation": "fallback: false returns 404 for paths not returned by getStaticPaths, while fallback: 'blocking' renders new paths on-demand server-side and caches them for future requests.",
              "industryContext": "Understanding fallback behavior is crucial for balancing build times with content availability in large-scale applications.",
              "tags": [
                "Static Generation",
                "getStaticPaths",
                "Performance"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 120
            },
            {
              "id": "nextjs-advanced-q14",
              "question": "Which Next.js feature helps prevent layout shift during navigation?",
              "topic": "Performance",
              "difficulty": "Intermediate",
              "choices": [
                "Automatic code splitting",
                "Link prefetching",
                "Image optimization",
                "CSS-in-JS"
              ],
              "correctIndex": 1,
              "explanation": "Link prefetching automatically prefetches pages in the viewport, loading them before navigation to prevent layout shifts and improve perceived performance.",
              "industryContext": "Link prefetching is a key optimization for improving Core Web Vitals and user experience in single-page applications.",
              "tags": [
                "Performance",
                "Navigation",
                "Core Web Vitals"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90
            },
            {
              "id": "nextjs-advanced-q15",
              "question": "How do you implement custom error pages in Next.js?",
              "topic": "Error Handling",
              "difficulty": "Intermediate",
              "choices": [
                "Create _error.js in the pages directory",
                "Create 404.js and 500.js in pages directory",
                "Use error boundaries in components",
                "All of the above"
              ],
              "correctIndex": 3,
              "explanation": "Next.js supports custom error pages through _error.js for general errors, specific files like 404.js and 500.js for HTTP errors, and React error boundaries for component-level errors.",
              "industryContext": "Proper error handling improves user experience and helps with debugging in production applications.",
              "tags": [
                "Error Handling",
                "User Experience",
                "Pages"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90
            },
            {
              "id": "nextjs-advanced-q16",
              "question": "What is the purpose of the next.config.js file?",
              "topic": "Configuration",
              "difficulty": "Beginner",
              "choices": [
                "To configure Next.js build and runtime behavior",
                "To define environment variables",
                "To set up API routes",
                "To configure database connections"
              ],
              "correctIndex": 0,
              "explanation": "next.config.js is the configuration file for Next.js that allows you to customize build behavior, webpack configuration, redirects, headers, and other framework settings.",
              "industryContext": "Proper configuration is essential for optimizing performance, security, and deployment settings in production applications.",
              "tags": [
                "Configuration",
                "Build",
                "Optimization"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 60
            },
            {
              "id": "nextjs-advanced-q17",
              "question": "Which approach is recommended for styling in Next.js applications?",
              "topic": "Styling",
              "difficulty": "Intermediate",
              "choices": [
                "CSS Modules for component-scoped styles",
                "Styled-components for CSS-in-JS",
                "Tailwind CSS for utility-first styling",
                "All approaches are supported and valid"
              ],
              "correctIndex": 3,
              "explanation": "Next.js supports multiple styling approaches including CSS Modules, styled-components, Tailwind CSS, and regular CSS. The choice depends on project requirements and team preferences.",
              "industryContext": "Flexible styling options allow teams to choose the approach that best fits their workflow and design system requirements.",
              "tags": [
                "Styling",
                "CSS",
                "Design Systems"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90
            },
            {
              "id": "nextjs-advanced-q18",
              "question": "How do you implement real-time features in Next.js applications?",
              "topic": "Real-time Features",
              "difficulty": "Advanced",
              "choices": [
                "Use WebSockets with a custom server",
                "Integrate Socket.io with Next.js",
                "Use Server-Sent Events (SSE)",
                "All of the above are viable approaches"
              ],
              "correctIndex": 3,
              "explanation": "Next.js supports multiple approaches for real-time features: WebSockets with custom servers, Socket.io integration, Server-Sent Events, and third-party services like Pusher or Ably.",
              "industryContext": "Real-time features are essential for modern applications like chat systems, live updates, collaborative tools, and real-time dashboards.",
              "tags": [
                "Real-time",
                "WebSockets",
                "Socket.io",
                "SSE"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 120
            }
          ],
          "issues": []
        },
        "meetsThresholds": true,
        "issues": [
          "Lesson 10: Introduction too short (minimum 200 words)",
          "Lesson 11: Introduction too short (minimum 200 words)",
          "Lesson 12: Introduction too short (minimum 200 words)"
        ]
      },
      "graphql-advanced": {
        "slug": "graphql-advanced",
        "title": "GraphQL Development",
        "tier": "specialized",
        "track": "Backend",
        "difficulty": "Advanced",
        "thresholds": {
          "requiredLessons": 13,
          "requiredQuestions": 17
        },
        "lessons": {
          "exists": true,
          "count": 13,
          "lessons": [
            {
              "id": "graphql-advanced-lesson-1",
              "moduleSlug": "graphql-advanced",
              "title": "Introduction to GraphQL and Query Language Basics",
              "order": 1,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on GraphQL Fundamentals.\n\nLearn what GraphQL is and how it differs from REST APIs, understanding the core concepts of queries, mutations, and subscriptions. GraphQL provides a flexible alternative to REST by allowing clients to request exactly the data they need.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "# Basic GraphQL query\nquery GetUser {\n  user(id: \"123\") {\n    id\n    name\n    email\n    posts {\n      title\n      content\n    }\n  }\n}\n\n# Query with variables\nquery GetUserPosts($userId: ID!, $limit: Int) {\n  user(id: $userId) {\n    name\n    posts(limit: $limit) {\n      title\n      publishedAt\n    }\n  }\n}",
                "explanation": "This example produces: {\n  \"data\": {\n    \"user\": {\n      \"id\": \"123\",\n      \"name\": \"John Doe\",\n      \"email\": \"john@example.com\",\n      \"posts\": [\n        {\n          \"title\": \"Getting Started with GraphQL\",\n          \"content\": \"GraphQL is a query language...\"\n        }\n      ]\n    }\n  }\n}\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "graphql"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Introduction to GraphQL and Query Language Basics",
                  "description": "Apply the concepts from this lesson on GraphQL Fundamentals",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Beginner",
              "tags": [
                "GraphQL Fundamentals",
                "graphql"
              ],
              "legacy": {
                "originalId": 1,
                "originalTopic": "GraphQL Fundamentals",
                "migrated": "2025-10-01T06:41:13.485Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.485Z",
              "version": "1.0.0"
            },
            {
              "id": "graphql-advanced-lesson-2",
              "moduleSlug": "graphql-advanced",
              "title": "Schema Definition Language and Type System",
              "order": 2,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on GraphQL Fundamentals.\n\nLearn how to define GraphQL schemas using the Schema Definition Language, including scalar types, object types, and relationships. The GraphQL type system is strongly typed and serves as a contract between client and server.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "# GraphQL Schema Definition\ntype User {\n  id: ID!\n  name: String!\n  email: String!\n  posts: [Post!]!\n}\n\ntype Post {\n  id: ID!\n  title: String!\n  content: String!\n  author: User!\n  publishedAt: DateTime\n}\n\nscalar DateTime\n\ntype Query {\n  user(id: ID!): User\n  users(limit: Int): [User!]!\n  post(id: ID!): Post\n}\n\ntype Mutation {\n  createUser(input: CreateUserInput!): User!\n  updateUser(id: ID!, input: UpdateUserInput!): User!\n}\n\ninput CreateUserInput {\n  name: String!\n  email: String!\n}",
                "explanation": "This example produces: Schema successfully defines type system with User, Post types, including relationships and input types for mutations\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "graphql"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Schema Definition Language and Type System",
                  "description": "Apply the concepts from this lesson on GraphQL Fundamentals",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "GraphQL Fundamentals",
                "graphql"
              ],
              "legacy": {
                "originalId": 2,
                "originalTopic": "GraphQL Fundamentals",
                "migrated": "2025-10-01T06:41:13.485Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.485Z",
              "version": "1.0.0"
            },
            {
              "id": "graphql-advanced-lesson-3",
              "moduleSlug": "graphql-advanced",
              "title": "Queries and Field Selection",
              "order": 3,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on GraphQL Operations.\n\nLearn how to write efficient GraphQL queries with field selection, nested queries, and aliases. GraphQL's field selection allows clients to request exactly the data they need, improving performance and reducing bandwidth usage.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "# Field selection and nested queries\nquery UserDashboard {\n  currentUser {\n    id\n    name\n    email\n    posts(limit: 5) {\n      id\n      title\n      publishedAt\n      comments(first: 3) {\n        content\n        author {\n          name\n        }\n      }\n    }\n  }\n}\n\n# Using aliases\nquery MultipleUsers {\n  admin: user(id: \"1\") {\n    name\n    role\n  }\n  author: user(id: \"2\") {\n    name\n    posts {\n      title\n    }\n  }\n}",
                "explanation": "This example produces: {\n  \"data\": {\n    \"currentUser\": {\n      \"id\": \"123\",\n      \"name\": \"John Doe\",\n      \"email\": \"john@example.com\",\n      \"posts\": [\n        {\n          \"id\": \"456\",\n          \"title\": \"GraphQL Best Practices\",\n          \"publishedAt\": \"2024-01-15T10:00:00Z\"\n        }\n      ]\n    }\n  }\n}\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "graphql"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Queries and Field Selection",
                  "description": "Apply the concepts from this lesson on GraphQL Operations",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Advanced",
              "tags": [
                "GraphQL Operations",
                "graphql"
              ],
              "legacy": {
                "originalId": 3,
                "originalTopic": "GraphQL Operations",
                "migrated": "2025-10-01T06:41:13.485Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.485Z",
              "version": "1.0.0"
            },
            {
              "id": "graphql-advanced-lesson-4",
              "moduleSlug": "graphql-advanced",
              "title": "Mutations and Data Modification",
              "order": 4,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on GraphQL Operations.\n\nLearn how to perform data modifications using GraphQL mutations, including creating, updating, and deleting data. Mutations provide a standardized way to modify server-side data while maintaining GraphQL's type safety.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "# Create user mutation\nmutation CreateUser($input: CreateUserInput!) {\n  createUser(input: $input) {\n    id\n    name\n    email\n    createdAt\n  }\n}\n\n# Update user mutation\nmutation UpdateUser($id: ID!, $input: UpdateUserInput!) {\n  updateUser(id: $id, input: $input) {\n    id\n    name\n    email\n    updatedAt\n  }\n}\n\n# Multiple mutations\nmutation CreatePostAndNotify($postInput: CreatePostInput!) {\n  createPost(input: $postInput) {\n    id\n    title\n  }\n  sendNotification {\n    success\n  }\n}",
                "explanation": "This example produces: {\n  \"data\": {\n    \"createUser\": {\n      \"id\": \"789\",\n      \"name\": \"Jane Smith\",\n      \"email\": \"jane@example.com\",\n      \"createdAt\": \"2024-01-15T12:00:00Z\"\n    }\n  }\n}\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "graphql"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Mutations and Data Modification",
                  "description": "Apply the concepts from this lesson on GraphQL Operations",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "GraphQL Operations",
                "graphql"
              ],
              "legacy": {
                "originalId": 4,
                "originalTopic": "GraphQL Operations",
                "migrated": "2025-10-01T06:41:13.485Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.485Z",
              "version": "1.0.0"
            },
            {
              "id": "graphql-advanced-lesson-5",
              "moduleSlug": "graphql-advanced",
              "title": "Subscriptions and Real-time Data",
              "order": 5,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on GraphQL Operations.\n\nLearn how to implement real-time functionality using GraphQL subscriptions for live data updates. Subscriptions allow clients to receive automatic updates when specific events occur on the server.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "# Basic subscription\nsubscription CommentAdded($postId: ID!) {\n  commentAdded(postId: $postId) {\n    id\n    content\n    author {\n      name\n    }\n    createdAt\n  }\n}\n\n# Real-time chat\nsubscription ChatMessages($roomId: ID!) {\n  messageAdded(roomId: $roomId) {\n    id\n    content\n    sender {\n      name\n    }\n    timestamp\n  }\n}\n\n# User status updates\nsubscription UserStatusUpdates {\n  userStatusChanged {\n    userId\n    status\n    lastSeen\n  }\n}",
                "explanation": "This example produces: Real-time WebSocket connection established:\n{\n  \"data\": {\n    \"commentAdded\": {\n      \"id\": \"comment_123\",\n      \"content\": \"Great article!\",\n      \"author\": {\n        \"name\": \"Alice Johnson\"\n      },\n      \"createdAt\": \"2024-01-15T14:30:00Z\"\n    }\n  }\n}\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "graphql"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Subscriptions and Real-time Data",
                  "description": "Apply the concepts from this lesson on GraphQL Operations",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "GraphQL Operations",
                "graphql"
              ],
              "legacy": {
                "originalId": 5,
                "originalTopic": "GraphQL Operations",
                "migrated": "2025-10-01T06:41:13.485Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.485Z",
              "version": "1.0.0"
            },
            {
              "id": "graphql-advanced-lesson-6",
              "moduleSlug": "graphql-advanced",
              "title": "Resolvers and Data Fetching",
              "order": 6,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Schema Design.\n\nLearn how to implement GraphQL resolvers to fetch and transform data from various sources including databases, REST APIs, and microservices. Resolvers are the heart of GraphQL servers.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "// GraphQL resolver implementation\nconst resolvers = {\n  Query: {\n    user: async (parent, args, context) => {\n      return await context.dataSources.userAPI.getUserById(args.id);\n    },\n    posts: async (parent, args, context) => {\n      return await context.dataSources.postAPI.getPosts(args);\n    }\n  },\n  \n  User: {\n    posts: async (user, args, context) => {\n      return await context.loaders.postsByAuthor.load(user.id);\n    }\n  },\n  \n  Post: {\n    author: async (post, args, context) => {\n      return await context.loaders.user.load(post.authorId);\n    }\n  },\n  \n  Mutation: {\n    createUser: async (parent, args, context) => {\n      const user = await context.dataSources.userAPI.createUser(args.input);\n      context.pubsub.publish('USER_CREATED', { userCreated: user });\n      return user;\n    }\n  }\n};",
                "explanation": "This example produces: Resolvers successfully fetch and return data from various sources with proper data loading optimization\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "graphql"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Resolvers and Data Fetching",
                  "description": "Apply the concepts from this lesson on Schema Design",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Schema Design",
                "graphql"
              ],
              "legacy": {
                "originalId": 6,
                "originalTopic": "Schema Design",
                "migrated": "2025-10-01T06:41:13.485Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.485Z",
              "version": "1.0.0"
            },
            {
              "id": "graphql-advanced-lesson-7",
              "moduleSlug": "graphql-advanced",
              "title": "Advanced Schema Patterns",
              "order": 7,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Schema Design.\n\nLearn advanced GraphQL schema design patterns including interfaces, unions, custom scalars, and schema stitching for building maintainable and scalable GraphQL APIs.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "# Interface for common fields\ninterface Node {\n  id: ID!\n  createdAt: DateTime!\n}\n\n# Union types\nunion SearchResult = User | Post | Comment\n\n# Implementing interface\ntype User implements Node {\n  id: ID!\n  createdAt: DateTime!\n  name: String!\n  email: String!\n}\n\n# Enums for type safety\nenum PostStatus {\n  DRAFT\n  PUBLISHED\n  ARCHIVED\n}\n\n# Custom scalars\nscalar DateTime\nscalar EmailAddress\n\n# Pagination pattern\ntype PostConnection {\n  edges: [PostEdge!]!\n  pageInfo: PageInfo!\n}\n\ntype PostEdge {\n  node: Post!\n  cursor: String!\n}\n\ntype PageInfo {\n  hasNextPage: Boolean!\n  hasPreviousPage: Boolean!\n}",
                "explanation": "This example produces: Advanced schema with interfaces, unions, custom scalars, and pagination patterns successfully defined\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "graphql"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Advanced Schema Patterns",
                  "description": "Apply the concepts from this lesson on Schema Design",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Advanced",
              "tags": [
                "Schema Design",
                "graphql"
              ],
              "legacy": {
                "originalId": 7,
                "originalTopic": "Schema Design",
                "migrated": "2025-10-01T06:41:13.485Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.485Z",
              "version": "1.0.0"
            },
            {
              "id": "graphql-advanced-lesson-8",
              "moduleSlug": "graphql-advanced",
              "title": "DataLoader and N+1 Query Problem",
              "order": 8,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Performance Optimization.\n\nLearn how to solve the N+1 query problem using DataLoader for efficient data fetching. DataLoader provides batching and caching to optimize database access patterns.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "// DataLoader implementation\nconst DataLoader = require('dataloader');\n\nconst createLoaders = () => {\n  const batchUsers = async (userIds) => {\n    const users = await User.findByIds(userIds);\n    return userIds.map(id => \n      users.find(user => user.id === id) || null\n    );\n  };\n  \n  return {\n    user: new DataLoader(batchUsers),\n    postsByAuthor: new DataLoader(async (authorIds) => {\n      const posts = await Post.findWhere({ authorId: { $in: authorIds } });\n      return authorIds.map(id => posts.filter(p => p.authorId === id));\n    })\n  };\n};\n\n// Using in resolvers\nconst resolvers = {\n  Post: {\n    author: async (post, args, context) => {\n      return await context.loaders.user.load(post.authorId);\n    }\n  }\n};",
                "explanation": "This example produces: DataLoader reduces N+1 queries from 1+N to 2 queries total, achieving 90% query reduction\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "graphql"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: DataLoader and N+1 Query Problem",
                  "description": "Apply the concepts from this lesson on Performance Optimization",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Performance Optimization",
                "graphql"
              ],
              "legacy": {
                "originalId": 8,
                "originalTopic": "Performance Optimization",
                "migrated": "2025-10-01T06:41:13.485Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.485Z",
              "version": "1.0.0"
            },
            {
              "id": "graphql-advanced-lesson-9",
              "moduleSlug": "graphql-advanced",
              "title": "Query Complexity Analysis and Rate Limiting",
              "order": 9,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Performance Optimization.\n\nLearn how to implement query complexity analysis and rate limiting to protect your GraphQL API from expensive or malicious queries.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "// Query complexity analysis\nconst depthLimit = require('graphql-depth-limit');\nconst costAnalysis = require('graphql-cost-analysis');\n\nconst server = new ApolloServer({\n  typeDefs,\n  resolvers,\n  plugins: [\n    {\n      requestDidStart() {\n        return {\n          didResolveOperation({ document }) {\n            const depthLimitResult = depthLimit(10)(document);\n            if (depthLimitResult) {\n              throw new Error('Query depth limit exceeded');\n            }\n          }\n        };\n      }\n    }\n  ],\n  validationRules: [\n    costAnalysis({\n      maximumCost: 1000,\n      defaultCost: 1,\n      costMap: {\n        User: {\n          posts: { complexity: 2, multipliers: ['first'] }\n        }\n      }\n    })\n  ]\n});",
                "explanation": "This example produces: Query complexity analysis prevents expensive queries and protects server resources\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "graphql"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Query Complexity Analysis and Rate Limiting",
                  "description": "Apply the concepts from this lesson on Performance Optimization",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Advanced",
              "tags": [
                "Performance Optimization",
                "graphql"
              ],
              "legacy": {
                "originalId": 9,
                "originalTopic": "Performance Optimization",
                "migrated": "2025-10-01T06:41:13.485Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.485Z",
              "version": "1.0.0"
            },
            {
              "id": "graphql-advanced-lesson-10",
              "moduleSlug": "graphql-advanced",
              "title": "GraphQL Testing Strategies",
              "order": 10,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Testing and Tools.\n\nLearn how to test GraphQL APIs effectively using various testing approaches including unit tests, integration tests, and end-to-end testing with proper mocking.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "// GraphQL testing with Jest\nconst { createTestClient } = require('apollo-server-testing');\nconst { ApolloServer } = require('apollo-server');\n\ndescribe('GraphQL API Tests', () => {\n  let server, query, mutate;\n  \n  beforeAll(() => {\n    server = new ApolloServer({ typeDefs, resolvers });\n    const testClient = createTestClient(server);\n    query = testClient.query;\n    mutate = testClient.mutate;\n  });\n  \n  test('should fetch user by ID', async () => {\n    const GET_USER = gql`\n      query GetUser($id: ID!) {\n        user(id: $id) {\n          id\n          name\n          email\n        }\n      }\n    `;\n    \n    const result = await query({\n      query: GET_USER,\n      variables: { id: '1' }\n    });\n    \n    expect(result.data.user).toEqual({\n      id: '1',\n      name: 'John Doe',\n      email: 'john@example.com'\n    });\n  });\n  \n  test('should create user', async () => {\n    const CREATE_USER = gql`\n      mutation CreateUser($input: CreateUserInput!) {\n        createUser(input: $input) {\n          id\n          name\n        }\n      }\n    `;\n    \n    const result = await mutate({\n      mutation: CREATE_USER,\n      variables: {\n        input: { name: 'Jane Doe', email: 'jane@example.com' }\n      }\n    });\n    \n    expect(result.data.createUser.name).toBe('Jane Doe');\n  });\n});",
                "explanation": "This example produces: All GraphQL tests pass with proper query and mutation validation\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "graphql"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: GraphQL Testing Strategies",
                  "description": "Apply the concepts from this lesson on Testing and Tools",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Testing and Tools",
                "graphql"
              ],
              "legacy": {
                "originalId": 10,
                "originalTopic": "Testing and Tools",
                "migrated": "2025-10-01T06:41:13.485Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.485Z",
              "version": "1.0.0"
            },
            {
              "id": "graphql-advanced-lesson-11",
              "moduleSlug": "graphql-advanced",
              "title": "GraphQL Development Tools and Debugging",
              "order": 11,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Testing and Tools.\n\nLearn how to use GraphQL development tools including GraphQL Playground, Apollo Studio, and debugging techniques for building and maintaining GraphQL APIs.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "// GraphQL Playground setup\nconst { ApolloServer } = require('apollo-server-express');\nconst express = require('express');\n\nconst server = new ApolloServer({\n  typeDefs,\n  resolvers,\n  introspection: true, // Enable for development\n  playground: {\n    settings: {\n      'editor.theme': 'dark',\n      'editor.reuseHeaders': true,\n      'tracing.hideTracingResponse': false,\n    }\n  },\n  tracing: true, // Enable Apollo tracing\n  plugins: [\n    {\n      requestDidStart() {\n        return {\n          willSendResponse(requestContext) {\n            console.log('Query executed:', requestContext.request.query);\n            console.log('Variables:', requestContext.request.variables);\n          }\n        };\n      }\n    }\n  ]\n});\n\n// Apollo Studio integration\nconst server2 = new ApolloServer({\n  typeDefs,\n  resolvers,\n  plugins: [\n    require('apollo-server-plugin-response-cache')(),\n    {\n      requestDidStart() {\n        return {\n          didResolveOperation(requestContext) {\n            // Log to Apollo Studio\n            console.log('Operation:', requestContext.request.operationName);\n          }\n        };\n      }\n    }\n  ]\n});",
                "explanation": "This example produces: GraphQL Playground and Apollo Studio successfully configured for development and monitoring\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "graphql"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: GraphQL Development Tools and Debugging",
                  "description": "Apply the concepts from this lesson on Testing and Tools",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Testing and Tools",
                "graphql"
              ],
              "legacy": {
                "originalId": 11,
                "originalTopic": "Testing and Tools",
                "migrated": "2025-10-01T06:41:13.485Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.485Z",
              "version": "1.0.0"
            },
            {
              "id": "graphql-advanced-lesson-12",
              "moduleSlug": "graphql-advanced",
              "title": "GraphQL Security and Production Best Practices",
              "order": 12,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Production Deployment.\n\nLearn essential security practices and production deployment strategies for GraphQL APIs including authentication, authorization, and monitoring.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "// Security implementation\nconst { shield, rule, and, or } = require('graphql-shield');\nconst jwt = require('jsonwebtoken');\n\n// Authentication rule\nconst isAuthenticated = rule({ cache: 'contextual' })(\n  async (parent, args, context) => {\n    return context.user !== null;\n  }\n);\n\n// Authorization rule\nconst isOwner = rule({ cache: 'strict' })(\n  async (parent, args, context) => {\n    return context.user.id === args.id;\n  }\n);\n\n// Permission shield\nconst permissions = shield({\n  Query: {\n    user: isAuthenticated,\n    users: and(isAuthenticated, isAdmin),\n    posts: isAuthenticated\n  },\n  Mutation: {\n    createPost: isAuthenticated,\n    updatePost: and(isAuthenticated, isOwner),\n    deletePost: and(isAuthenticated, isOwner)\n  }\n});\n\n// Production server setup\nconst server = new ApolloServer({\n  typeDefs,\n  resolvers,\n  middlewares: [permissions],\n  context: ({ req }) => {\n    const token = req.headers.authorization?.replace('Bearer ', '');\n    const user = token ? jwt.verify(token, process.env.JWT_SECRET) : null;\n    return { user };\n  },\n  introspection: process.env.NODE_ENV !== 'production',\n  playground: process.env.NODE_ENV !== 'production',\n  formatError: (error) => {\n    console.error(error);\n    return process.env.NODE_ENV === 'production' \n      ? new Error('Internal server error')\n      : error;\n  }\n});",
                "explanation": "This example produces: Secure GraphQL API with authentication, authorization, and production-ready error handling\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "graphql"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: GraphQL Security and Production Best Practices",
                  "description": "Apply the concepts from this lesson on Production Deployment",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Production Deployment",
                "graphql"
              ],
              "legacy": {
                "originalId": 12,
                "originalTopic": "Production Deployment",
                "migrated": "2025-10-01T06:41:13.485Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.485Z",
              "version": "1.0.0"
            },
            {
              "id": "graphql-advanced-lesson-13",
              "moduleSlug": "graphql-advanced",
              "title": "GraphQL Federation and Microservices Architecture",
              "order": 13,
              "objectives": [
                "Understand GraphQL Federation concepts and implementation",
                "Learn to compose schemas from multiple services",
                "Implement federated GraphQL architecture for microservices"
              ],
              "intro": "Welcome to this comprehensive lesson on GraphQL Federation and Microservices Architecture.\n\nLearn how to implement GraphQL Federation to compose schemas from multiple microservices, enabling distributed GraphQL architectures. Federation allows different teams to own and develop their GraphQL schemas independently while providing a unified API gateway.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "// User Service Schema\ntype User @key(fields: \"id\") {\n  id: ID!\n  name: String!\n  email: String!\n}\n\nextend type Query {\n  user(id: ID!): User\n  users: [User!]!\n}\n\n// Posts Service Schema\ntype Post @key(fields: \"id\") {\n  id: ID!\n  title: String!\n  content: String!\n  authorId: ID!\n  author: User\n}\n\nextend type User @key(fields: \"id\") {\n  id: ID! @external\n  posts: [Post!]!\n}\n\nextend type Query {\n  post(id: ID!): Post\n  posts: [Post!]!\n}\n\n// Gateway Configuration\nconst { ApolloGateway } = require('@apollo/gateway');\nconst { ApolloServer } = require('apollo-server');\n\nconst gateway = new ApolloGateway({\n  serviceList: [\n    { name: 'users', url: 'http://localhost:4001/graphql' },\n    { name: 'posts', url: 'http://localhost:4002/graphql' },\n    { name: 'comments', url: 'http://localhost:4003/graphql' }\n  ],\n  buildService: ({ url }) => {\n    return new RemoteGraphQLDataSource({\n      url,\n      willSendRequest: ({ request, context }) => {\n        request.http.headers.set('user-id', context.userId);\n      }\n    });\n  }\n});\n\nconst server = new ApolloServer({\n  gateway,\n  subscriptions: false,\n  context: ({ req }) => {\n    return {\n      userId: req.headers['user-id']\n    };\n  }\n});\n\n// User Service Resolver\nconst resolvers = {\n  User: {\n    __resolveReference: (reference) => {\n      return users.find(user => user.id === reference.id);\n    }\n  },\n  Query: {\n    user: (parent, { id }) => users.find(user => user.id === id),\n    users: () => users\n  }\n};\n\n// Posts Service Resolver\nconst resolvers = {\n  Post: {\n    __resolveReference: (reference) => {\n      return posts.find(post => post.id === reference.id);\n    },\n    author: (post) => {\n      return { __typename: 'User', id: post.authorId };\n    }\n  },\n  User: {\n    posts: (user) => posts.filter(post => post.authorId === user.id)\n  },\n  Query: {\n    post: (parent, { id }) => posts.find(post => post.id === id),\n    posts: () => posts\n  }\n};\n\n// Federated Query Example\nquery GetUserWithPosts {\n  user(id: \"1\") {\n    id\n    name\n    email\n    posts {\n      id\n      title\n      content\n    }\n  }\n}",
                "explanation": "This example demonstrates GraphQL Federation implementation with multiple services (users, posts) that compose into a single federated schema. The gateway handles query planning and execution across services.\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not properly handling entity resolution across services",
                  "solution": "Implement proper __resolveReference methods and use @key directives correctly",
                  "severity": "high"
                },
                {
                  "mistake": "Creating circular dependencies between federated services",
                  "solution": "Design clear service boundaries and avoid tight coupling between services",
                  "severity": "medium"
                },
                {
                  "mistake": "Not implementing proper error handling in federated queries",
                  "solution": "Handle partial failures gracefully and provide meaningful error messages",
                  "severity": "medium"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: GraphQL Federation and Microservices Architecture",
                  "description": "Implement a federated GraphQL architecture with multiple microservices",
                  "checkpoints": [
                    "Set up multiple GraphQL services with federated schemas",
                    "Configure Apollo Gateway for service composition",
                    "Implement entity resolution across services",
                    "Test federated queries and handle errors",
                    "Deploy federated architecture to production"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 50,
              "difficulty": "Advanced",
              "tags": [
                "Federation",
                "Microservices",
                "Architecture",
                "graphql"
              ],
              "lastUpdated": "2025-10-01T06:41:13.485Z",
              "version": "1.0.0"
            }
          ],
          "issues": []
        },
        "quiz": {
          "exists": true,
          "count": 20,
          "questions": [
            {
              "id": "graphql-advanced-q1",
              "question": "What is GraphQL?",
              "topic": "GraphQL Fundamentals",
              "difficulty": "Beginner",
              "choices": [
                "A query language for APIs and a runtime for executing queries",
                "A database management system",
                "A REST API framework",
                "A JavaScript library for building user interfaces"
              ],
              "correctIndex": 0,
              "explanation": "GraphQL is a query language for APIs and a runtime for executing those queries by using a type system you define for your data. It provides a more efficient, powerful and flexible alternative to REST.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "GraphQL Fundamentals",
                "beginner",
                "graphql"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 1,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.486Z"
              }
            },
            {
              "id": "graphql-advanced-q2",
              "question": "Which of the following is NOT a core operation type in GraphQL?",
              "topic": "GraphQL Fundamentals",
              "difficulty": "Intermediate",
              "choices": [
                "Query",
                "Mutation",
                "Subscription",
                "Transaction"
              ],
              "correctIndex": 3,
              "explanation": "GraphQL has three core operation types: Query (for reading data), Mutation (for modifying data), and Subscription (for real-time data). Transaction is not a GraphQL operation type.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "GraphQL Fundamentals",
                "intermediate",
                "graphql"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 2,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.486Z"
              }
            },
            {
              "id": "graphql-advanced-q3",
              "question": "Explain the main advantages of GraphQL over REST APIs.",
              "topic": "GraphQL Fundamentals",
              "difficulty": "Intermediate",
              "choices": [
                "Open-ended question - no multiple choice",
                "This is a conceptual question",
                "Answer requires explanation",
                "Multiple approaches possible"
              ],
              "correctIndex": 0,
              "explanation": "GraphQL offers several advantages over REST: 1) Clients can request exactly the data they need, avoiding over-fetching and under-fetching, 2) Single endpoint for all operations instead of multiple URLs, 3) Strong type system provides better tooling and validation, 4) Real-time subscriptions built-in, 5) Introspection allows for automatic documentation and tooling.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "GraphQL Fundamentals",
                "intermediate",
                "graphql"
              ],
              "questionType": "open-ended",
              "estimatedTime": 180,
              "legacy": {
                "originalId": 3,
                "originalType": "open-ended",
                "migrated": "2025-10-01T06:41:13.486Z"
              }
            },
            {
              "id": "graphql-advanced-q4",
              "question": "In GraphQL schema definition, what does the exclamation mark (!) indicate?",
              "topic": "Schema Design",
              "difficulty": "Intermediate",
              "choices": [
                "The field is required and cannot be null",
                "The field is deprecated",
                "The field is an array",
                "The field is a custom scalar"
              ],
              "correctIndex": 0,
              "explanation": "The exclamation mark (!) in GraphQL schema definition indicates that a field is non-nullable, meaning it must always return a value and cannot be null.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Schema Design",
                "intermediate",
                "graphql"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 4,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.486Z"
              }
            },
            {
              "id": "graphql-advanced-q5",
              "question": "What is the purpose of resolvers in GraphQL?",
              "topic": "Schema Design",
              "difficulty": "Beginner",
              "choices": [
                "To define the schema structure",
                "To fetch data for each field in a query",
                "To validate user input",
                "To handle authentication"
              ],
              "correctIndex": 1,
              "explanation": "Resolvers are functions that fetch the actual data for each field in a GraphQL query. They define how to retrieve data from databases, APIs, or other sources for each field in the schema.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Schema Design",
                "beginner",
                "graphql"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 5,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.486Z"
              }
            },
            {
              "id": "graphql-advanced-q6",
              "question": "What is the difference between a GraphQL query and a mutation?",
              "topic": "GraphQL Operations",
              "difficulty": "Beginner",
              "choices": [
                "Open-ended question - no multiple choice",
                "This is a conceptual question",
                "Answer requires explanation",
                "Multiple approaches possible"
              ],
              "correctIndex": 0,
              "explanation": "Queries are used for reading/fetching data and should be side-effect free, while mutations are used for modifying data (create, update, delete operations). Queries can be executed in parallel, but mutations are executed sequentially to ensure data consistency.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "GraphQL Operations",
                "beginner",
                "graphql"
              ],
              "questionType": "open-ended",
              "estimatedTime": 180,
              "legacy": {
                "originalId": 6,
                "originalType": "open-ended",
                "migrated": "2025-10-01T06:41:13.486Z"
              }
            },
            {
              "id": "graphql-advanced-q7",
              "question": "How do you pass variables to a GraphQL query?",
              "topic": "GraphQL Operations",
              "difficulty": "Beginner",
              "choices": [
                "Using the variables object alongside the query",
                "Directly interpolating values in the query string",
                "Using query parameters in the URL",
                "Variables cannot be used in GraphQL"
              ],
              "correctIndex": 0,
              "explanation": "Variables are passed to GraphQL queries using a variables object that is sent alongside the query. The query defines variable types and names using $ syntax, and values are provided in the variables object.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "GraphQL Operations",
                "beginner",
                "graphql"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 7,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.486Z"
              }
            },
            {
              "id": "graphql-advanced-q8",
              "question": "What are GraphQL subscriptions used for?",
              "topic": "GraphQL Operations",
              "difficulty": "Intermediate",
              "choices": [
                "Real-time data updates and live connections",
                "Batching multiple queries together",
                "Caching query results",
                "User authentication"
              ],
              "correctIndex": 0,
              "explanation": "GraphQL subscriptions are used for real-time data updates, allowing clients to receive live updates when specific events occur on the server, typically implemented using WebSockets.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "GraphQL Operations",
                "intermediate",
                "graphql"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 8,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.486Z"
              }
            },
            {
              "id": "graphql-advanced-q9",
              "question": "What is the N+1 query problem in GraphQL and how can it be solved?",
              "topic": "Performance Optimization",
              "difficulty": "Beginner",
              "choices": [
                "Open-ended question - no multiple choice",
                "This is a conceptual question",
                "Answer requires explanation",
                "Multiple approaches possible"
              ],
              "correctIndex": 0,
              "explanation": "The N+1 query problem occurs when fetching a list of N items requires N+1 database queries (1 for the list + N queries for related data). It can be solved using DataLoader, which batches and caches database requests, or by using more efficient database queries with joins.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Performance Optimization",
                "beginner",
                "graphql"
              ],
              "questionType": "open-ended",
              "estimatedTime": 180,
              "legacy": {
                "originalId": 9,
                "originalType": "open-ended",
                "migrated": "2025-10-01T06:41:13.486Z"
              }
            },
            {
              "id": "graphql-advanced-q10",
              "question": "What is DataLoader used for in GraphQL?",
              "topic": "Performance Optimization",
              "difficulty": "Beginner",
              "choices": [
                "Batching and caching data requests to solve N+1 queries",
                "Loading GraphQL schema definitions",
                "Validating incoming queries",
                "Handling user authentication"
              ],
              "correctIndex": 0,
              "explanation": "DataLoader is a utility for batching and caching data fetching operations. It helps solve the N+1 query problem by collecting individual loads and batching them into single requests.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Performance Optimization",
                "beginner",
                "graphql"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 10,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.486Z"
              }
            },
            {
              "id": "graphql-advanced-q11",
              "question": "What is a GraphQL interface?",
              "topic": "Schema Design",
              "difficulty": "Beginner",
              "choices": [
                "A way to define common fields that multiple types can implement",
                "A method for connecting to external APIs",
                "A type of scalar value",
                "A security mechanism"
              ],
              "correctIndex": 0,
              "explanation": "A GraphQL interface defines a set of common fields that multiple object types can implement, similar to interfaces in programming languages. It allows for polymorphic queries and better schema organization.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Schema Design",
                "beginner",
                "graphql"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 11,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.486Z"
              }
            },
            {
              "id": "graphql-advanced-q12",
              "question": "When would you use a union type in GraphQL?",
              "topic": "Schema Design",
              "difficulty": "Intermediate",
              "choices": [
                "Open-ended question - no multiple choice",
                "This is a conceptual question",
                "Answer requires explanation",
                "Multiple approaches possible"
              ],
              "correctIndex": 0,
              "explanation": "Union types are used when a field can return one of several different types. Common use cases include search results that can return different types of objects, polymorphic relationships, or error handling where a field might return either a success object or an error object.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Schema Design",
                "intermediate",
                "graphql"
              ],
              "questionType": "open-ended",
              "estimatedTime": 180,
              "legacy": {
                "originalId": 12,
                "originalType": "open-ended",
                "migrated": "2025-10-01T06:41:13.486Z"
              }
            },
            {
              "id": "graphql-advanced-q13",
              "question": "What is query depth limiting in GraphQL?",
              "topic": "Performance Optimization",
              "difficulty": "Beginner",
              "choices": [
                "A security measure to prevent deeply nested queries that could cause performance issues",
                "A way to limit the number of fields in a query",
                "A method for caching query results",
                "A technique for optimizing resolver performance"
              ],
              "correctIndex": 0,
              "explanation": "Query depth limiting is a security measure that prevents clients from sending deeply nested queries that could consume excessive server resources. It sets a maximum depth for query nesting.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Performance Optimization",
                "beginner",
                "graphql"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 13,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.486Z"
              }
            },
            {
              "id": "graphql-advanced-q14",
              "question": "What is GraphQL Playground?",
              "topic": "Testing and Tools",
              "difficulty": "Beginner",
              "choices": [
                "An in-browser IDE for exploring GraphQL APIs",
                "A testing framework for GraphQL",
                "A GraphQL schema validation tool",
                "A performance monitoring tool"
              ],
              "correctIndex": 0,
              "explanation": "GraphQL Playground is an in-browser IDE for exploring GraphQL APIs. It provides features like query execution, schema exploration, documentation browsing, and query history.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Testing and Tools",
                "beginner",
                "graphql"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 14,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.486Z"
              }
            },
            {
              "id": "graphql-advanced-q15",
              "question": "How would you test a GraphQL API effectively?",
              "topic": "Testing and Tools",
              "difficulty": "Intermediate",
              "choices": [
                "Open-ended question - no multiple choice",
                "This is a conceptual question",
                "Answer requires explanation",
                "Multiple approaches possible"
              ],
              "correctIndex": 0,
              "explanation": "GraphQL APIs should be tested at multiple levels: 1) Unit tests for individual resolvers, 2) Integration tests for complete queries/mutations, 3) Schema validation tests, 4) Performance tests for complex queries, 5) Security tests for rate limiting and authentication. Tools like Jest, Apollo Server Testing, and GraphQL testing utilities help automate these tests.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Testing and Tools",
                "intermediate",
                "graphql"
              ],
              "questionType": "open-ended",
              "estimatedTime": 180,
              "legacy": {
                "originalId": 15,
                "originalType": "open-ended",
                "migrated": "2025-10-01T06:41:13.486Z"
              }
            },
            {
              "id": "graphql-advanced-q16",
              "question": "Which of the following is a security best practice for GraphQL APIs?",
              "topic": "Production Deployment",
              "difficulty": "Advanced",
              "choices": [
                "All of the above",
                "Implement query depth limiting",
                "Use authentication and authorization",
                "Disable introspection in production"
              ],
              "correctIndex": 0,
              "explanation": "All mentioned practices are important for GraphQL security: query depth limiting prevents expensive queries, authentication/authorization controls access, and disabling introspection in production prevents schema discovery by unauthorized users.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Production Deployment",
                "advanced",
                "graphql"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 16,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.486Z"
              }
            },
            {
              "id": "graphql-advanced-q17",
              "question": "What considerations should you make when deploying GraphQL to production?",
              "topic": "Production Deployment",
              "difficulty": "Intermediate",
              "choices": [
                "Open-ended question - no multiple choice",
                "This is a conceptual question",
                "Answer requires explanation",
                "Multiple approaches possible"
              ],
              "correctIndex": 0,
              "explanation": "Production GraphQL deployment requires: 1) Security measures (authentication, authorization, rate limiting, query complexity analysis), 2) Performance optimization (DataLoader, caching, query analysis), 3) Monitoring and logging, 4) Error handling and reporting, 5) Schema versioning strategy, 6) Disabling development features like introspection and playground.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Production Deployment",
                "intermediate",
                "graphql"
              ],
              "questionType": "open-ended",
              "estimatedTime": 180,
              "legacy": {
                "originalId": 17,
                "originalType": "open-ended",
                "migrated": "2025-10-01T06:41:13.486Z"
              }
            },
            {
              "id": "graphql-advanced-q18",
              "question": "What are fragments in GraphQL?",
              "topic": "GraphQL Operations",
              "difficulty": "Intermediate",
              "choices": [
                "Reusable units of query logic that can be included in multiple queries",
                "Broken query parts that cause errors",
                "A type of mutation operation",
                "Database transaction components"
              ],
              "correctIndex": 0,
              "explanation": "Fragments are reusable units of query logic that allow you to define a set of fields once and include them in multiple queries. They help reduce duplication and improve query maintainability.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "GraphQL Operations",
                "intermediate",
                "graphql"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 18,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.486Z"
              }
            },
            {
              "id": "graphql-advanced-q19",
              "question": "What is the purpose of input types in GraphQL?",
              "topic": "Schema Design",
              "difficulty": "Beginner",
              "choices": [
                "To define the structure of data passed as arguments to mutations and queries",
                "To handle user authentication",
                "To define database schemas",
                "To validate query syntax"
              ],
              "correctIndex": 0,
              "explanation": "Input types define the structure of complex data that can be passed as arguments to GraphQL mutations and queries. They ensure type safety for input validation and provide clear documentation for required data structures.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Schema Design",
                "beginner",
                "graphql"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 19,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.486Z"
              }
            },
            {
              "id": "graphql-advanced-q20",
              "question": "Explain query complexity analysis in GraphQL and why it's important.",
              "topic": "Performance Optimization",
              "difficulty": "Advanced",
              "choices": [
                "Open-ended question - no multiple choice",
                "This is a conceptual question",
                "Answer requires explanation",
                "Multiple approaches possible"
              ],
              "correctIndex": 0,
              "explanation": "Query complexity analysis assigns complexity scores to GraphQL operations based on the fields requested and their relationships. It's important because it helps prevent expensive queries from overwhelming the server, provides a standardized way to rate-limit based on resource usage rather than just request count, and helps identify potentially problematic queries before they impact performance.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Performance Optimization",
                "advanced",
                "graphql"
              ],
              "questionType": "open-ended",
              "estimatedTime": 180,
              "legacy": {
                "originalId": 20,
                "originalType": "open-ended",
                "migrated": "2025-10-01T06:41:13.486Z"
              }
            }
          ],
          "issues": []
        },
        "meetsThresholds": true,
        "issues": []
      },
      "sass-advanced": {
        "slug": "sass-advanced",
        "title": "Sass/SCSS Development",
        "tier": "specialized",
        "track": "Frontend",
        "difficulty": "Advanced",
        "thresholds": {
          "requiredLessons": 12,
          "requiredQuestions": 15
        },
        "lessons": {
          "exists": true,
          "count": 12,
          "lessons": [
            {
              "id": "sass-advanced-lesson-1",
              "moduleSlug": "sass-advanced",
              "title": "Introduction to SASS",
              "order": 1,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Basics.\n\nLearn the fundamentals of SASS and how it extends CSS with powerful features.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "// SCSS syntax\n$font-stack: Helvetica, sans-serif;\n$primary-color: #333;\n\nbody {\n  font: 100% $font-stack;\n  color: $primary-color;\n}\n\n// Compiled CSS output\nbody {\n  font: 100% Helvetica, sans-serif;\n  color: #333;\n}",
                "explanation": "This example produces: body {\n  font: 100% Helvetica, sans-serif;\n  color: #333;\n}\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "scss"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Introduction to SASS",
                  "description": "Apply the concepts from this lesson on Basics",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Beginner",
              "tags": [
                "Basics",
                "sass"
              ],
              "legacy": {
                "originalId": 1,
                "originalTopic": "Basics",
                "migrated": "2025-10-01T06:41:13.486Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.486Z",
              "version": "1.0.0"
            },
            {
              "id": "sass-advanced-lesson-2",
              "moduleSlug": "sass-advanced",
              "title": "Variables in SASS",
              "order": 2,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Basics.\n\nLearn how to use variables to store and reuse values throughout your stylesheet.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "// Defining variables\n$primary-color: #3498db;\n$secondary-color: #2ecc71;\n$font-size-large: 1.5rem;\n$border-radius: 4px;\n\n// Using variables\n.button {\n  background-color: $primary-color;\n  color: white;\n  font-size: $font-size-large;\n  border-radius: $border-radius;\n  padding: 10px 20px;\n  \n  &:hover {\n    background-color: $secondary-color;\n  }\n}",
                "explanation": "This example produces: .button {\n  background-color: #3498db;\n  color: white;\n  font-size: 1.5rem;\n  border-radius: 4px;\n  padding: 10px 20px;\n}\n\n.button:hover {\n  background-color: #2ecc71;\n}\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "scss"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Variables in SASS",
                  "description": "Apply the concepts from this lesson on Basics",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Basics",
                "sass"
              ],
              "legacy": {
                "originalId": 2,
                "originalTopic": "Basics",
                "migrated": "2025-10-01T06:41:13.486Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.486Z",
              "version": "1.0.0"
            },
            {
              "id": "sass-advanced-lesson-3",
              "moduleSlug": "sass-advanced",
              "title": "Nesting in SASS",
              "order": 3,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Nesting.\n\nLearn how to nest selectors and properties to write more organized CSS.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "// SASS nesting\nnav {\n  ul {\n    margin: 0;\n    padding: 0;\n    list-style: none;\n    \n    li { \n      display: inline-block;\n      \n      a {\n        display: block;\n        padding: 6px 12px;\n        text-decoration: none;\n      }\n    }\n  }\n}\n\n// Compiled CSS\nnav ul {\n  margin: 0;\n  padding: 0;\n  list-style: none;\n}\nnav ul li {\n  display: inline-block;\n}\nnav ul li a {\n  display: block;\n  padding: 6px 12px;\n  text-decoration: none;\n}",
                "explanation": "This example produces: nav ul {\n  margin: 0;\n  padding: 0;\n  list-style: none;\n}\nnav ul li {\n  display: inline-block;\n}\nnav ul li a {\n  display: block;\n  padding: 6px 12px;\n  text-decoration: none;\n}\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "scss"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Nesting in SASS",
                  "description": "Apply the concepts from this lesson on Nesting",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Nesting",
                "sass"
              ],
              "legacy": {
                "originalId": 3,
                "originalTopic": "Nesting",
                "migrated": "2025-10-01T06:41:13.486Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.486Z",
              "version": "1.0.0"
            },
            {
              "id": "sass-advanced-lesson-4",
              "moduleSlug": "sass-advanced",
              "title": "Creating and Using Mixins",
              "order": 4,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Mixins.\n\nLearn how to create reusable blocks of CSS with mixins in SASS.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "// Defining a mixin\n@mixin button-style($bg-color, $text-color: white) {\n  background-color: $bg-color;\n  color: $text-color;\n  padding: 10px 15px;\n  border: none;\n  border-radius: 4px;\n  cursor: pointer;\n  \n  &:hover {\n    background-color: darken($bg-color, 10%);\n  }\n}\n\n// Using mixins\n.primary-button {\n  @include button-style(#3498db);\n}\n\n.success-button {\n  @include button-style(#2ecc71, #333);\n}",
                "explanation": "This example produces: .primary-button {\n  background-color: #3498db;\n  color: white;\n  padding: 10px 15px;\n  border: none;\n  border-radius: 4px;\n  cursor: pointer;\n}\n\n.primary-button:hover {\n  background-color: #217dbb;\n}\n\n.success-button {\n  background-color: #2ecc71;\n  color: #333;\n  padding: 10px 15px;\n  border: none;\n  border-radius: 4px;\n  cursor: pointer;\n}\n\n.success-button:hover {\n  background-color: #25a25a;\n}\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "scss"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Creating and Using Mixins",
                  "description": "Apply the concepts from this lesson on Mixins",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Mixins",
                "sass"
              ],
              "legacy": {
                "originalId": 4,
                "originalTopic": "Mixins",
                "migrated": "2025-10-01T06:41:13.486Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.486Z",
              "version": "1.0.0"
            },
            {
              "id": "sass-advanced-lesson-5",
              "moduleSlug": "sass-advanced",
              "title": "SASS Functions and Operations",
              "order": 5,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Functions.\n\nLearn how to use built-in functions and create custom functions in SASS.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "// Built-in functions\n$base-color: #3498db;\n\n.card {\n  background-color: lighten($base-color, 20%);\n  border-color: darken($base-color, 15%);\n  font-size: 16px * 1.2;\n  width: 200px + 50px;\n}\n\n// Custom function\n@function calculate-rem($size) {\n  $rem-size: $size / 16px;\n  @return #{$rem-size}rem;\n}\n\n.text {\n  font-size: calculate-rem(18px);\n}",
                "explanation": "This example produces: .card {\n  background-color: #aed6f1;\n  border-color: #1d6fa5;\n  font-size: 19.2px;\n  width: 250px;\n}\n\n.text {\n  font-size: 1.125rem;\n}\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "scss"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: SASS Functions and Operations",
                  "description": "Apply the concepts from this lesson on Functions",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Advanced",
              "tags": [
                "Functions",
                "sass"
              ],
              "legacy": {
                "originalId": 5,
                "originalTopic": "Functions",
                "migrated": "2025-10-01T06:41:13.486Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.486Z",
              "version": "1.0.0"
            },
            {
              "id": "sass-advanced-lesson-6",
              "moduleSlug": "sass-advanced",
              "title": "Control Directives and Loops",
              "order": 6,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Control Directives.\n\nLearn how to use control directives like @if, @for, @each, and @while in SASS.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "// @if directive\n@mixin respond-to($breakpoint) {\n  @if $breakpoint == small {\n    @media (max-width: 767px) { @content; }\n  }\n  @else if $breakpoint == medium {\n    @media (min-width: 768px) and (max-width: 1023px) { @content; }\n  }\n  @else if $breakpoint == large {\n    @media (min-width: 1024px) { @content; }\n  }\n}\n\n// @for loop\n@for $i from 1 through 4 {\n  .column-#{$i} {\n    width: percentage($i / 4);\n  }\n}\n\n// @each loop\n$colors: (primary: #3498db, success: #2ecc71, danger: #e74c3c);\n\n@each $name, $color in $colors {\n  .btn-#{$name} {\n    background-color: $color;\n    \n    &:hover {\n      background-color: darken($color, 10%);\n    }\n  }\n}\n\n// @while loop\n$columns: 12;\n$i: 1;\n\n@while $i <= $columns {\n  .grid-#{$i} {\n    width: percentage($i / $columns);\n  }\n  $i: $i + 1;\n}",
                "explanation": "This example produces: Responsive mixins, column widths, colored buttons, and grid system generated programmatically\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "scss"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Control Directives and Loops",
                  "description": "Apply the concepts from this lesson on Control Directives",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Control Directives",
                "sass"
              ],
              "legacy": {
                "originalId": 6,
                "originalTopic": "Control Directives",
                "migrated": "2025-10-01T06:41:13.486Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.486Z",
              "version": "1.0.0"
            },
            {
              "id": "sass-advanced-lesson-7",
              "moduleSlug": "sass-advanced",
              "title": "Inheritance with @extend",
              "order": 7,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Advanced Features.\n\nLearn how to use @extend to share styles between selectors and create efficient CSS.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "// Base styles\n%button-base {\n  padding: 10px 15px;\n  border: none;\n  border-radius: 4px;\n  cursor: pointer;\n  font-weight: bold;\n  text-align: center;\n  text-decoration: none;\n  display: inline-block;\n  transition: all 0.3s ease;\n}\n\n%message-shared {\n  border: 1px solid #ccc;\n  padding: 10px;\n  color: #333;\n  border-radius: 4px;\n  margin-bottom: 15px;\n}\n\n// Extending base styles\n.button {\n  @extend %button-base;\n  background-color: #3498db;\n  color: white;\n  \n  &:hover {\n    background-color: darken(#3498db, 10%);\n  }\n}\n\n.button-large {\n  @extend .button;\n  padding: 15px 25px;\n  font-size: 1.2em;\n}\n\n.success {\n  @extend %message-shared;\n  border-color: #d4edda;\n  background-color: #d1ecf1;\n  color: #155724;\n}\n\n.error {\n  @extend %message-shared;\n  border-color: #f5c6cb;\n  background-color: #f8d7da;\n  color: #721c24;\n}",
                "explanation": "This example produces: Efficient CSS with shared styles using @extend, creating maintainable button and message components\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "scss"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Inheritance with @extend",
                  "description": "Apply the concepts from this lesson on Advanced Features",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Advanced Features",
                "sass"
              ],
              "legacy": {
                "originalId": 7,
                "originalTopic": "Advanced Features",
                "migrated": "2025-10-01T06:41:13.486Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.486Z",
              "version": "1.0.0"
            },
            {
              "id": "sass-advanced-lesson-8",
              "moduleSlug": "sass-advanced",
              "title": "Organizing Code with Partials and @import",
              "order": 8,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Partials.\n\nLearn how to organize SASS code using partials and the @import directive.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "// _variables.scss\n$primary-color: #3498db;\n$secondary-color: #2ecc71;\n$font-family: 'Helvetica Neue', Arial, sans-serif;\n$border-radius: 4px;\n\n// _mixins.scss\n@mixin flex-center {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n\n@mixin card-shadow($level: 1) {\n  @if $level == 1 {\n    box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n  } @else if $level == 2 {\n    box-shadow: 0 4px 8px rgba(0,0,0,0.15);\n  } @else if $level == 3 {\n    box-shadow: 0 8px 16px rgba(0,0,0,0.2);\n  }\n}\n\n// _components.scss\n@import 'variables';\n@import 'mixins';\n\n.card {\n  background: white;\n  border-radius: $border-radius;\n  padding: 20px;\n  @include card-shadow(2);\n  \n  &__header {\n    border-bottom: 1px solid #eee;\n    padding-bottom: 15px;\n    margin-bottom: 15px;\n  }\n  \n  &__title {\n    font-family: $font-family;\n    color: $primary-color;\n    margin: 0;\n  }\n}\n\n// main.scss\n@import 'variables';\n@import 'mixins';\n@import 'components';\n\nbody {\n  font-family: $font-family;\n  line-height: 1.6;\n  color: #333;\n}\n\n.container {\n  max-width: 1200px;\n  margin: 0 auto;\n  padding: 20px;\n  @include flex-center;\n  flex-direction: column;\n}",
                "explanation": "This example produces: Modular SASS architecture with organized partials for variables, mixins, and components\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "scss"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Organizing Code with Partials and @import",
                  "description": "Apply the concepts from this lesson on Partials",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Partials",
                "sass"
              ],
              "legacy": {
                "originalId": 8,
                "originalTopic": "Partials",
                "migrated": "2025-10-01T06:41:13.486Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.486Z",
              "version": "1.0.0"
            },
            {
              "id": "sass-advanced-lesson-9",
              "moduleSlug": "sass-advanced",
              "title": "Working with Maps and Lists",
              "order": 9,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Maps and Lists.\n\nLearn how to use SASS maps and lists for advanced data structures and dynamic styles.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "// SASS Lists\n$font-sizes: 12px, 14px, 16px, 18px, 24px, 32px;\n$font-weights: normal, bold, 100, 200, 300, 400, 500, 600, 700, 800, 900;\n\n// SASS Maps\n$breakpoints: (\n  small: 480px,\n  medium: 768px,\n  large: 1024px,\n  xlarge: 1200px\n);\n\n$theme-colors: (\n  primary: (\n    base: #3498db,\n    light: #5dade2,\n    dark: #2980b9\n  ),\n  secondary: (\n    base: #95a5a6,\n    light: #bdc3c7,\n    dark: #7f8c8d\n  )\n);\n\n// Functions to work with maps\n@function color($color-name, $tone: base) {\n  @return map-get(map-get($theme-colors, $color-name), $tone);\n}\n\n@function breakpoint($bp-name) {\n  @return map-get($breakpoints, $bp-name);\n}\n\n// Mixins using maps\n@mixin respond-above($breakpoint) {\n  @media (min-width: #{map-get($breakpoints, $breakpoint)}) {\n    @content;\n  }\n}\n\n// Generate utility classes from lists\n@each $size in $font-sizes {\n  .font-size-#{$size} {\n    font-size: $size;\n  }\n}\n\n// Generate color classes from maps\n@each $color-name, $color-map in $theme-colors {\n  .bg-#{$color-name} {\n    background-color: map-get($color-map, base);\n    \n    &-light {\n      background-color: map-get($color-map, light);\n    }\n    \n    &-dark {\n      background-color: map-get($color-map, dark);\n    }\n  }\n}\n\n// Usage examples\n.header {\n  background-color: color(primary);\n  color: white;\n  \n  @include respond-above(medium) {\n    padding: 20px;\n  }\n}",
                "explanation": "This example produces: Dynamic utility classes, responsive design system, and theme color management using SASS data structures\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "scss"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Working with Maps and Lists",
                  "description": "Apply the concepts from this lesson on Maps and Lists",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Advanced",
              "tags": [
                "Maps and Lists",
                "sass"
              ],
              "legacy": {
                "originalId": 9,
                "originalTopic": "Maps and Lists",
                "migrated": "2025-10-01T06:41:13.486Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.486Z",
              "version": "1.0.0"
            },
            {
              "id": "sass-advanced-lesson-10",
              "moduleSlug": "sass-advanced",
              "title": "SASS Architecture and BEM Methodology",
              "order": 10,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Architecture.\n\nLearn how to structure large SASS projects using the 7-1 pattern and BEM methodology.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "// 7-1 SASS Architecture\n/*\nsass/\n|\n| abstracts/\n|   | _variables.scss    // Sass Variables\n|   | _functions.scss    // Sass Functions\n|   | _mixins.scss       // Sass Mixins\n|   | _placeholders.scss // Sass Placeholders\n|\n| base/\n|   | _reset.scss        // Reset/normalize\n|   | _typography.scss   // Typography rules\n|\n| components/\n|   | _buttons.scss      // Buttons\n|   | _carousel.scss     // Carousel\n|   | _cover.scss        // Cover\n|   | _dropdown.scss     // Dropdown\n|\n| layout/\n|   | _navigation.scss   // Navigation\n|   | _grid.scss         // Grid system\n|   | _header.scss       // Header\n|   | _footer.scss       // Footer\n|   | _sidebar.scss      // Sidebar\n|   | _forms.scss        // Forms\n|\n| pages/\n|   | _home.scss         // Home specific styles\n|   | _contact.scss      // Contact specific styles\n|\n| themes/\n|   | _theme.scss        // Default theme\n|   | _admin.scss        // Admin theme\n|\n| vendors/\n|   | _bootstrap.scss    // Bootstrap\n|   | _jquery-ui.scss    // jQuery UI\n|\n` main.scss              // Main Sass file\n*/\n\n// BEM Methodology Example\n// Block__Element--Modifier\n\n.card {\n  background: white;\n  border-radius: 8px;\n  box-shadow: 0 2px 8px rgba(0,0,0,0.1);\n  padding: 20px;\n  \n  // Element\n  &__header {\n    border-bottom: 1px solid #eee;\n    padding-bottom: 15px;\n    margin-bottom: 15px;\n  }\n  \n  &__title {\n    font-size: 1.5rem;\n    font-weight: bold;\n    margin: 0;\n    color: #333;\n  }\n  \n  &__body {\n    line-height: 1.6;\n  }\n  \n  &__footer {\n    border-top: 1px solid #eee;\n    padding-top: 15px;\n    margin-top: 15px;\n    text-align: right;\n  }\n  \n  // Modifiers\n  &--featured {\n    border: 2px solid #3498db;\n    box-shadow: 0 4px 16px rgba(52, 152, 219, 0.2);\n  }\n  \n  &--large {\n    padding: 30px;\n    \n    .card__title {\n      font-size: 2rem;\n    }\n  }\n  \n  &--compact {\n    padding: 10px;\n    \n    .card__header {\n      padding-bottom: 8px;\n      margin-bottom: 8px;\n    }\n  }\n}\n\n// Main SASS file structure\n@import 'abstracts/variables';\n@import 'abstracts/functions';\n@import 'abstracts/mixins';\n@import 'abstracts/placeholders';\n\n@import 'base/reset';\n@import 'base/typography';\n\n@import 'layout/navigation';\n@import 'layout/grid';\n@import 'layout/header';\n@import 'layout/footer';\n\n@import 'components/buttons';\n@import 'components/carousel';\n@import 'components/dropdown';",
                "explanation": "This example produces: Scalable SASS architecture with organized file structure and BEM naming convention for maintainable code\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "scss"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: SASS Architecture and BEM Methodology",
                  "description": "Apply the concepts from this lesson on Architecture",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Architecture",
                "sass"
              ],
              "legacy": {
                "originalId": 10,
                "originalTopic": "Architecture",
                "migrated": "2025-10-01T06:41:13.486Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.486Z",
              "version": "1.0.0"
            },
            {
              "id": "sass-advanced-lesson-11",
              "moduleSlug": "sass-advanced",
              "title": "SASS Performance and Optimization",
              "order": 11,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Optimization.\n\nLearn best practices for optimizing SASS compilation and output CSS performance.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "// Efficient variable organization\n$colors: (\n  primary: #3498db,\n  secondary: #2ecc71,\n  accent: #e74c3c,\n  neutral: #95a5a6\n) !default;\n\n// Optimized mixin for performance\n@mixin generate-spacing($property, $sizes: (5, 10, 15, 20, 25, 30)) {\n  @each $size in $sizes {\n    .#{str-slice($property, 1, 1)}-#{$size} {\n      #{$property}: #{$size}px;\n    }\n  }\n}\n\n// Generate utilities efficiently\n@include generate-spacing('margin');\n@include generate-spacing('padding');\n\n// Conditional compilation\n$include-print-styles: false !default;\n$include-ie-support: false !default;\n\n@if $include-print-styles {\n  @media print {\n    .no-print { display: none; }\n    .print-only { display: block; }\n  }\n}\n\n@if $include-ie-support {\n  .ie-fallback {\n    filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#3498db', endColorstr='#2980b9');\n  }\n}\n\n// Optimize selector nesting (max 3 levels)\n.navigation {\n  ul {\n    li {\n      a {\n        // This is the maximum recommended nesting depth\n        text-decoration: none;\n        \n        // Use parent selector instead of deeper nesting\n        &:hover,\n        &:focus {\n          color: #3498db;\n        }\n      }\n    }\n  }\n}\n\n// Efficient placeholder usage\n%clearfix {\n  &::after {\n    content: '';\n    display: table;\n    clear: both;\n  }\n}\n\n%sr-only {\n  position: absolute;\n  width: 1px;\n  height: 1px;\n  padding: 0;\n  margin: -1px;\n  overflow: hidden;\n  clip: rect(0, 0, 0, 0);\n  border: 0;\n}\n\n// Use placeholders for shared styles\n.row {\n  @extend %clearfix;\n}\n\n.screen-reader-text {\n  @extend %sr-only;\n}\n\n// Performance monitoring mixin\n@mixin performance-critical {\n  /* Critical CSS - inline this */\n  @content;\n}\n\n@include performance-critical {\n  body {\n    font-family: system-ui, -apple-system, sans-serif;\n    line-height: 1.6;\n  }\n  \n  .header {\n    background: #fff;\n    position: sticky;\n    top: 0;\n  }\n}",
                "explanation": "This example produces: Optimized SASS code with efficient compilation, conditional includes, and performance-conscious patterns\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "scss"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: SASS Performance and Optimization",
                  "description": "Apply the concepts from this lesson on Optimization",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Advanced",
              "tags": [
                "Optimization",
                "sass"
              ],
              "legacy": {
                "originalId": 11,
                "originalTopic": "Optimization",
                "migrated": "2025-10-01T06:41:13.486Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.486Z",
              "version": "1.0.0"
            },
            {
              "id": "sass-advanced-lesson-12",
              "moduleSlug": "sass-advanced",
              "title": "Modern SASS Features and CSS Grid Integration",
              "order": 12,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Modern Features.\n\nLearn about modern SASS features and how to integrate with CSS Grid and other modern CSS technologies.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "// Modern SASS with CSS Custom Properties\n:root {\n  --color-primary: #{color(primary)};\n  --color-secondary: #{color(secondary)};\n  --spacing-unit: 1rem;\n  --border-radius: 8px;\n}\n\n// CSS Grid helpers\n@mixin grid-container($columns: 12, $gap: 1rem) {\n  display: grid;\n  grid-template-columns: repeat($columns, 1fr);\n  gap: $gap;\n}\n\n@mixin grid-item($column-start: auto, $column-end: auto, $row-start: auto, $row-end: auto) {\n  grid-column: $column-start / $column-end;\n  grid-row: $row-start / $row-end;\n}\n\n// Modern layout system\n.layout {\n  @include grid-container(12, 2rem);\n  min-height: 100vh;\n  \n  &__header {\n    @include grid-item(1, -1, 1, 2);\n    background: var(--color-primary);\n    color: white;\n    padding: var(--spacing-unit);\n  }\n  \n  &__sidebar {\n    @include grid-item(1, 4, 2, -1);\n    background: #f8f9fa;\n    padding: var(--spacing-unit);\n    \n    @media (max-width: 768px) {\n      @include grid-item(1, -1, 2, 3);\n    }\n  }\n  \n  &__main {\n    @include grid-item(4, -1, 2, -1);\n    padding: var(--spacing-unit);\n    \n    @media (max-width: 768px) {\n      @include grid-item(1, -1, 3, -1);\n    }\n  }\n}\n\n// Container queries preparation\n@mixin container-query($min-width) {\n  @container (min-width: #{$min-width}) {\n    @content;\n  }\n}\n\n.card {\n  container-type: inline-size;\n  background: white;\n  border-radius: var(--border-radius);\n  padding: var(--spacing-unit);\n  \n  @include container-query(300px) {\n    .card__content {\n      display: flex;\n      gap: 1rem;\n    }\n  }\n}\n\n// Modern color functions\n@function get-contrast-color($color) {\n  $lightness: lightness($color);\n  @return if($lightness > 50%, #000, #fff);\n}\n\n@mixin theme-colors($theme-map) {\n  @each $name, $color in $theme-map {\n    .bg-#{$name} {\n      background-color: $color;\n      color: get-contrast-color($color);\n    }\n    \n    .text-#{$name} {\n      color: $color;\n    }\n    \n    .border-#{$name} {\n      border-color: $color;\n    }\n  }\n}\n\n// Generate modern color system\n@include theme-colors($colors);\n\n// CSS logical properties with SASS\n@mixin logical-spacing($block-start: 0, $inline-end: 0, $block-end: 0, $inline-start: 0) {\n  padding-block-start: $block-start;\n  padding-inline-end: $inline-end;\n  padding-block-end: $block-end;\n  padding-inline-start: $inline-start;\n}\n\n.content {\n  @include logical-spacing(2rem, 1rem, 2rem, 1rem);\n  margin-inline: auto;\n  max-inline-size: 80ch;\n}",
                "explanation": "This example produces: Modern SASS integration with CSS Grid, custom properties, container queries, and logical properties for future-proof styling\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "scss"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Modern SASS Features and CSS Grid Integration",
                  "description": "Apply the concepts from this lesson on Modern Features",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Modern Features",
                "sass"
              ],
              "legacy": {
                "originalId": 12,
                "originalTopic": "Modern Features",
                "migrated": "2025-10-01T06:41:13.486Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.486Z",
              "version": "1.0.0"
            }
          ],
          "issues": []
        },
        "quiz": {
          "exists": true,
          "count": 15,
          "questions": [
            {
              "id": "sass-advanced-q1",
              "question": "What is SASS?",
              "topic": "Basics",
              "difficulty": "Beginner",
              "choices": [
                "A CSS preprocessor that extends CSS with programming features",
                "A JavaScript framework",
                "A CSS framework like Bootstrap",
                "A build tool for web applications"
              ],
              "correctIndex": 0,
              "explanation": "SASS (Syntactically Awesome Style Sheets) is a CSS preprocessor that adds features like variables, nesting, and mixins to CSS, which are then compiled into regular CSS.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Basics",
                "beginner",
                "sass"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 1,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.487Z"
              }
            },
            {
              "id": "sass-advanced-q2",
              "question": "What symbol is used to define a variable in SASS?",
              "topic": "Basics",
              "difficulty": "Intermediate",
              "choices": [
                "$",
                "@",
                "%",
                "#"
              ],
              "correctIndex": 0,
              "explanation": "In SASS, variables are defined using the $ symbol followed by the variable name.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Basics",
                "intermediate",
                "sass"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 2,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.487Z"
              }
            },
            {
              "id": "sass-advanced-q3",
              "question": "How does nesting work in SASS and what are its benefits?",
              "topic": "Nesting",
              "difficulty": "Intermediate",
              "choices": [
                "Open-ended question - no multiple choice",
                "This is a conceptual question",
                "Answer requires explanation",
                "Multiple approaches possible"
              ],
              "correctIndex": 0,
              "explanation": "Nesting in SASS allows you to write selectors inside other selectors, creating a visual hierarchy that mirrors the HTML structure. This makes stylesheets more organized and easier to read, and reduces repetition in selector names.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Nesting",
                "intermediate",
                "sass"
              ],
              "questionType": "open-ended",
              "estimatedTime": 180,
              "legacy": {
                "originalId": 3,
                "originalType": "open-ended",
                "migrated": "2025-10-01T06:41:13.487Z"
              }
            },
            {
              "id": "sass-advanced-q4",
              "question": "How do you reference the parent selector in a nested rule in SASS?",
              "topic": "Nesting",
              "difficulty": "Beginner",
              "choices": [
                "&",
                "$parent",
                ":parent",
                "::parent"
              ],
              "correctIndex": 0,
              "explanation": "The & symbol is used to reference the parent selector in nested SASS rules, commonly used for pseudo-classes and modifiers.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Nesting",
                "beginner",
                "sass"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 4,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.487Z"
              }
            },
            {
              "id": "sass-advanced-q5",
              "question": "What is a mixin in SASS?",
              "topic": "Mixins",
              "difficulty": "Beginner",
              "choices": [
                "A reusable block of CSS declarations",
                "A function that returns a value",
                "A variable that stores CSS properties",
                "A selector that combines multiple classes"
              ],
              "correctIndex": 0,
              "explanation": "A mixin in SASS is a reusable block of CSS declarations that can be included in other stylesheets. Mixins can also take arguments to make them more flexible.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Mixins",
                "beginner",
                "sass"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 5,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.487Z"
              }
            },
            {
              "id": "sass-advanced-q6",
              "question": "Which function is used to make a color lighter in SASS?",
              "topic": "Functions",
              "difficulty": "Intermediate",
              "choices": [
                "lighten()",
                "brighten()",
                "fade-in()",
                "adjust-color()"
              ],
              "correctIndex": 0,
              "explanation": "The lighten() function in SASS is used to make a color lighter by increasing its lightness value.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Functions",
                "intermediate",
                "sass"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 6,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.487Z"
              }
            },
            {
              "id": "sass-advanced-q7",
              "question": "What is the difference between .scss and .sass syntax?",
              "topic": "Compilation",
              "difficulty": "Beginner",
              "choices": [
                "Open-ended question - no multiple choice",
                "This is a conceptual question",
                "Answer requires explanation",
                "Multiple approaches possible"
              ],
              "correctIndex": 0,
              "explanation": "SASS offers two syntaxes: .scss (Sassy CSS) which is CSS-compatible and uses braces and semicolons, and .sass (indented syntax) which uses indentation instead of braces and line breaks instead of semicolons. Both compile to the same CSS.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Compilation",
                "beginner",
                "sass"
              ],
              "questionType": "open-ended",
              "estimatedTime": 180,
              "legacy": {
                "originalId": 7,
                "originalType": "open-ended",
                "migrated": "2025-10-01T06:41:13.487Z"
              }
            },
            {
              "id": "sass-advanced-q8",
              "question": "What is the purpose of @extend in SASS?",
              "topic": "Extend",
              "difficulty": "Beginner",
              "choices": [
                "To share CSS properties between selectors",
                "To import external stylesheets",
                "To create reusable functions",
                "To define variables"
              ],
              "correctIndex": 0,
              "explanation": "The @extend directive in SASS allows one selector to inherit the styles of another selector, reducing code duplication by sharing CSS properties.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Extend",
                "beginner",
                "sass"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 8,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.487Z"
              }
            },
            {
              "id": "sass-advanced-q9",
              "question": "What is the 7-1 SASS architecture pattern?",
              "topic": "Architecture",
              "difficulty": "Beginner",
              "choices": [
                "7 folders, 1 main file structure",
                "7 variables, 1 mixin pattern",
                "7 components, 1 layout system",
                "7 breakpoints, 1 grid system"
              ],
              "correctIndex": 0,
              "explanation": "The 7-1 pattern organizes SASS files into 7 folders (base, components, layout, pages, themes, abstracts, vendors) and 1 main file that imports all partials.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Architecture",
                "beginner",
                "sass"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 9,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.487Z"
              }
            },
            {
              "id": "sass-advanced-q10",
              "question": "What is the best practice for organizing SASS imports?",
              "topic": "Performance",
              "difficulty": "Beginner",
              "choices": [
                "Import abstracts first, then base, components, and pages",
                "Import in alphabetical order",
                "Import largest files first",
                "Import randomly"
              ],
              "correctIndex": 0,
              "explanation": "Best practice is to import in dependency order: abstracts (variables, functions, mixins), base styles, layout, components, pages, themes, and vendors.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Performance",
                "beginner",
                "sass"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 10,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.487Z"
              }
            },
            {
              "id": "sass-advanced-q11",
              "question": "When should you use @extend vs mixins in SASS?",
              "topic": "Advanced Features",
              "difficulty": "Intermediate",
              "choices": [
                "Open-ended question - no multiple choice",
                "This is a conceptual question",
                "Answer requires explanation",
                "Multiple approaches possible"
              ],
              "correctIndex": 0,
              "explanation": "Use @extend for shared base styles that don't need parameters (creates grouped selectors). Use mixins for reusable patterns with parameters or complex logic. @extend can cause bloated CSS if overused, while mixins provide more flexibility but duplicate code.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Advanced Features",
                "intermediate",
                "sass"
              ],
              "questionType": "open-ended",
              "estimatedTime": 180,
              "legacy": {
                "originalId": 11,
                "originalType": "open-ended",
                "migrated": "2025-10-01T06:41:13.487Z"
              }
            },
            {
              "id": "sass-advanced-q12",
              "question": "Which SASS data type is best for storing multiple related values?",
              "topic": "Data Types",
              "difficulty": "Intermediate",
              "choices": [
                "Maps",
                "Lists",
                "Strings",
                "Numbers"
              ],
              "correctIndex": 0,
              "explanation": "Maps are ideal for storing key-value pairs of related data, like color themes or breakpoint definitions, providing better organization than lists.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Data Types",
                "intermediate",
                "sass"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 12,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.487Z"
              }
            },
            {
              "id": "sass-advanced-q13",
              "question": "What does the @return directive do in SASS functions?",
              "topic": "Functions",
              "difficulty": "Intermediate",
              "choices": [
                "Returns a value from a function",
                "Returns to previous file",
                "Reverses a calculation",
                "Returns an error"
              ],
              "correctIndex": 0,
              "explanation": "@return specifies the value that a SASS function should return when called, similar to return statements in programming languages.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Functions",
                "intermediate",
                "sass"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 13,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.487Z"
              }
            },
            {
              "id": "sass-advanced-q14",
              "question": "What are the main control directives in SASS and when would you use them?",
              "topic": "Control Directives",
              "difficulty": "Intermediate",
              "choices": [
                "Open-ended question - no multiple choice",
                "This is a conceptual question",
                "Answer requires explanation",
                "Multiple approaches possible"
              ],
              "correctIndex": 0,
              "explanation": "Main control directives: @if/@else for conditional logic, @for for counted loops, @each for iterating over lists/maps, @while for conditional loops. Use them to generate utility classes, responsive breakpoints, color variations, and other repetitive CSS patterns.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Control Directives",
                "intermediate",
                "sass"
              ],
              "questionType": "open-ended",
              "estimatedTime": 180,
              "legacy": {
                "originalId": 14,
                "originalType": "open-ended",
                "migrated": "2025-10-01T06:41:13.487Z"
              }
            },
            {
              "id": "sass-advanced-q15",
              "question": "What is the difference between SASS and SCSS syntax?",
              "topic": "Compilation",
              "difficulty": "Beginner",
              "choices": [
                "SASS uses indentation, SCSS uses brackets and semicolons",
                "SASS is newer than SCSS",
                "SCSS is faster than SASS",
                "No functional difference"
              ],
              "correctIndex": 0,
              "explanation": "SASS (indented syntax) uses indentation and newlines like Python, while SCSS (Sassy CSS) uses brackets and semicolons like CSS. Both compile to the same CSS output.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Compilation",
                "beginner",
                "sass"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 15,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.487Z"
              }
            }
          ],
          "issues": []
        },
        "meetsThresholds": true,
        "issues": []
      },
      "tailwind-advanced": {
        "slug": "tailwind-advanced",
        "title": "Tailwind CSS Framework",
        "tier": "specialized",
        "track": "Frontend",
        "difficulty": "Advanced",
        "thresholds": {
          "requiredLessons": 13,
          "requiredQuestions": 16
        },
        "lessons": {
          "exists": true,
          "count": 13,
          "lessons": [
            {
              "id": "tailwind-advanced-lesson-1",
              "moduleSlug": "tailwind-advanced",
              "title": "Introduction to Tailwind CSS",
              "order": 1,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Basics.\n\nLearn the fundamentals of Tailwind CSS and how it differs from traditional CSS frameworks.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "<!-- Traditional CSS -->\n<button class=\"btn btn-blue\">Click me</button>\n\n<style>\n  .btn {\n    padding: 0.5rem 1rem;\n    border-radius: 0.25rem;\n    font-weight: 500;\n  }\n  .btn-blue {\n    background-color: #3b82f6;\n    color: white;\n  }\n</style>\n\n<!-- Tailwind CSS -->\n<button class=\"px-4 py-2 bg-blue-500 text-white font-medium rounded\">Click me</button>",
                "explanation": "This example produces: Button with blue background and white text, padding, and rounded corners\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "css"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Introduction to Tailwind CSS",
                  "description": "Apply the concepts from this lesson on Basics",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Beginner",
              "tags": [
                "Basics",
                "tailwind"
              ],
              "legacy": {
                "originalId": 1,
                "originalTopic": "Basics",
                "migrated": "2025-10-01T06:41:13.487Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.487Z",
              "version": "1.0.0"
            },
            {
              "id": "tailwind-advanced-lesson-2",
              "moduleSlug": "tailwind-advanced",
              "title": "Utility-First Fundamentals",
              "order": 2,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Basics.\n\nLearn how to build designs using Tailwind's utility classes instead of writing custom CSS.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "<!-- Building a card component with utility classes -->\n<div class=\"max-w-sm rounded overflow-hidden shadow-lg\">\n  <img class=\"w-full\" src=\"/img/card-top.jpg\" alt=\"Sunset in the mountains\">\n  <div class=\"px-6 py-4\">\n    <div class=\"font-bold text-xl mb-2\">The Coldest Sunset</div>\n    <p class=\"text-gray-700 text-base\">\n      Lorem ipsum dolor sit amet, consectetur adipisicing elit.\n    </p>\n  </div>\n  <div class=\"px-6 pt-4 pb-2\">\n    <span class=\"inline-block bg-gray-200 rounded-full px-3 py-1 text-sm font-semibold text-gray-700 mr-2 mb-2\">#photography</span>\n  </div>\n</div>",
                "explanation": "This example produces: Card component with image, title, description, and tag\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "css"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Utility-First Fundamentals",
                  "description": "Apply the concepts from this lesson on Basics",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Beginner",
              "tags": [
                "Basics",
                "tailwind"
              ],
              "legacy": {
                "originalId": 2,
                "originalTopic": "Basics",
                "migrated": "2025-10-01T06:41:13.487Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.487Z",
              "version": "1.0.0"
            },
            {
              "id": "tailwind-advanced-lesson-3",
              "moduleSlug": "tailwind-advanced",
              "title": "Flexbox and Grid",
              "order": 3,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Layout.\n\nLearn how to create layouts using Tailwind's flexbox and grid utilities.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "<!-- Flexbox example -->\n<div class=\"flex items-center justify-between\">\n  <div>Left content</div>\n  <div>Center content</div>\n  <div>Right content</div>\n</div>\n\n<!-- Grid example -->\n<div class=\"grid grid-cols-3 gap-4\">\n  <div class=\"bg-gray-200 p-4\">Column 1</div>\n  <div class=\"bg-gray-300 p-4\">Column 2</div>\n  <div class=\"bg-gray-400 p-4\">Column 3</div>\n</div>",
                "explanation": "This example produces: Flexbox layout with evenly spaced items and grid layout with three columns\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "css"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Flexbox and Grid",
                  "description": "Apply the concepts from this lesson on Layout",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Layout",
                "tailwind"
              ],
              "legacy": {
                "originalId": 3,
                "originalTopic": "Layout",
                "migrated": "2025-10-01T06:41:13.487Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.487Z",
              "version": "1.0.0"
            },
            {
              "id": "tailwind-advanced-lesson-4",
              "moduleSlug": "tailwind-advanced",
              "title": "Responsive Design",
              "order": 4,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Layout.\n\nLearn how to make your designs responsive using Tailwind's responsive prefixes.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "<!-- Responsive design with breakpoints -->\n<div class=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4\">\n  <div class=\"bg-blue-500 p-4 text-white\">Card 1</div>\n  <div class=\"bg-green-500 p-4 text-white\">Card 2</div>\n  <div class=\"bg-red-500 p-4 text-white\">Card 3</div>\n</div>\n\n<!-- Responsive text sizing -->\n<h1 class=\"text-lg sm:text-xl md:text-2xl lg:text-3xl xl:text-4xl\">\n  Responsive Heading\n</h1>",
                "explanation": "This example produces: Grid that changes from 1 column on mobile to 2 on medium screens to 3 on large screens, and heading that scales with screen size\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "css"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Responsive Design",
                  "description": "Apply the concepts from this lesson on Layout",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Layout",
                "tailwind"
              ],
              "legacy": {
                "originalId": 4,
                "originalTopic": "Layout",
                "migrated": "2025-10-01T06:41:13.487Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.487Z",
              "version": "1.0.0"
            },
            {
              "id": "tailwind-advanced-lesson-5",
              "moduleSlug": "tailwind-advanced",
              "title": "Customizing Tailwind",
              "order": 5,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Customization.\n\nLearn how to customize Tailwind's default theme and add your own utility classes.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "// tailwind.config.js\nmodule.exports = {\n  theme: {\n    extend: {\n      colors: {\n        'brand-blue': '#1971c2',\n        'brand-green': '#2b8a3e',\n      },\n      spacing: {\n        '128': '32rem',\n      }\n    }\n  },\n  plugins: [\n    function({ addUtilities }) {\n      const newUtilities = {\n        '.text-shadow': {\n          textShadow: '1px 1px 2px rgba(0, 0, 0, 0.5)'\n        }\n      }\n      addUtilities(newUtilities)\n    }\n  ]\n}",
                "explanation": "This example produces: Custom color palette and spacing scale added to Tailwind configuration\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "css"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Customizing Tailwind",
                  "description": "Apply the concepts from this lesson on Customization",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Advanced",
              "tags": [
                "Customization",
                "tailwind"
              ],
              "legacy": {
                "originalId": 5,
                "originalTopic": "Customization",
                "migrated": "2025-10-01T06:41:13.487Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.487Z",
              "version": "1.0.0"
            },
            {
              "id": "tailwind-advanced-lesson-6",
              "moduleSlug": "tailwind-advanced",
              "title": "Building Reusable Components",
              "order": 6,
              "objectives": [
                "Master component creation and usage",
                "Implement practical solutions"
              ],
              "intro": "Welcome to this comprehensive lesson on Components.\n\nLearn how to create reusable components with Tailwind CSS.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "<!-- Button component variations -->\n<button class=\"btn btn-primary\">Primary</button>\n<button class=\"btn btn-secondary\">Secondary</button>\n\n@layer components {\n  .btn {\n    @apply px-4 py-2 rounded font-medium focus:outline-none focus:ring-2;\n  }\n  .btn-primary {\n    @apply bg-blue-500 text-white hover:bg-blue-600 focus:ring-blue-300;\n  }\n  .btn-secondary {\n    @apply bg-gray-500 text-white hover:bg-gray-600 focus:ring-gray-300;\n  }\n}",
                "explanation": "This example produces: Reusable button components with consistent styling and hover states\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "css"
              },
              "pitfalls": [
                {
                  "mistake": "Not using keys in lists",
                  "solution": "Always provide unique keys for list items",
                  "severity": "high"
                },
                {
                  "mistake": "Mutating props directly",
                  "solution": "Props are read-only, create new objects for updates",
                  "severity": "medium"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Building Reusable Components",
                  "description": "Apply the concepts from this lesson on Components",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Components",
                "tailwind"
              ],
              "legacy": {
                "originalId": 6,
                "originalTopic": "Components",
                "migrated": "2025-10-01T06:41:13.487Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.487Z",
              "version": "1.0.0"
            },
            {
              "id": "tailwind-advanced-lesson-7",
              "moduleSlug": "tailwind-advanced",
              "title": "Styling Forms",
              "order": 7,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Forms.\n\nLearn how to style forms and form controls with Tailwind.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "<form class=\"max-w-md mx-auto\">\n  <div class=\"mb-4\">\n    <label class=\"block text-gray-700 text-sm font-bold mb-2\">\n      Email\n    </label>\n    <input class=\"w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500\" type=\"email\">\n  </div>\n  <button class=\"w-full bg-blue-500 text-white py-2 px-4 rounded-md hover:bg-blue-600\">\n    Submit\n  </button>\n</form>",
                "explanation": "This example produces: Styled form with input field and submit button\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "css"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Styling Forms",
                  "description": "Apply the concepts from this lesson on Forms",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Forms",
                "tailwind"
              ],
              "legacy": {
                "originalId": 7,
                "originalTopic": "Forms",
                "migrated": "2025-10-01T06:41:13.487Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.487Z",
              "version": "1.0.0"
            },
            {
              "id": "tailwind-advanced-lesson-8",
              "moduleSlug": "tailwind-advanced",
              "title": "Animations and Transitions",
              "order": 8,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Animation.\n\nLearn how to add animations and transitions using Tailwind.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "<!-- Hover animations -->\n<div class=\"transform transition duration-300 hover:scale-105\">\n  Hover to scale\n</div>\n\n<!-- Loading spinner -->\n<div class=\"animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500\"></div>\n\n<!-- Custom animation -->\n@keyframes bounce {\n  0%, 100% { transform: translateY(-25%); }\n  50% { transform: none; }\n}\n\n.animate-bounce { animation: bounce 1s infinite; }",
                "explanation": "This example produces: Elements with hover effects, loading spinner, and bounce animation\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "css"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Animations and Transitions",
                  "description": "Apply the concepts from this lesson on Animation",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Animation",
                "tailwind"
              ],
              "legacy": {
                "originalId": 8,
                "originalTopic": "Animation",
                "migrated": "2025-10-01T06:41:13.487Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.487Z",
              "version": "1.0.0"
            },
            {
              "id": "tailwind-advanced-lesson-9",
              "moduleSlug": "tailwind-advanced",
              "title": "Dark Mode Implementation",
              "order": 9,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Dark Mode.\n\nLearn how to implement dark mode with Tailwind CSS.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "<!-- Dark mode configuration -->\nmodule.exports = {\n  darkMode: 'class',\n  // ...\n}\n\n<!-- Dark mode styles -->\n<div class=\"bg-white dark:bg-gray-800 text-gray-900 dark:text-white\">\n  <h1 class=\"text-gray-900 dark:text-white\">Title</h1>\n  <p class=\"text-gray-600 dark:text-gray-300\">Content</p>\n</div>\n\n<!-- Toggle dark mode -->\n<button onclick=\"document.documentElement.classList.toggle('dark')\">\n  Toggle Dark Mode\n</button>",
                "explanation": "This example produces: Component with light and dark mode styling variations\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "css"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Dark Mode Implementation",
                  "description": "Apply the concepts from this lesson on Dark Mode",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Dark Mode",
                "tailwind"
              ],
              "legacy": {
                "originalId": 9,
                "originalTopic": "Dark Mode",
                "migrated": "2025-10-01T06:41:13.487Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.487Z",
              "version": "1.0.0"
            },
            {
              "id": "tailwind-advanced-lesson-10",
              "moduleSlug": "tailwind-advanced",
              "title": "Performance Optimization",
              "order": 10,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Optimization.\n\nLearn how to optimize Tailwind CSS for production.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "// Production optimization\nmodule.exports = {\n  content: ['./src/**/*.{html,js,jsx,ts,tsx}'],\n  theme: { extend: {} },\n  plugins: [],\n}\n\n// PurgeCSS configuration\nconst purgecss = require('@fullhuman/postcss-purgecss')\n\nmodule.exports = {\n  plugins: [\n    require('tailwindcss'),\n    require('autoprefixer'),\n    ...(process.env.NODE_ENV === 'production' ? [purgecss] : [])\n  ]\n}",
                "explanation": "This example produces: Optimized build configuration for smaller CSS bundles in production\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "css"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Performance Optimization",
                  "description": "Apply the concepts from this lesson on Optimization",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Advanced",
              "tags": [
                "Optimization",
                "tailwind"
              ],
              "legacy": {
                "originalId": 10,
                "originalTopic": "Optimization",
                "migrated": "2025-10-01T06:41:13.487Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.487Z",
              "version": "1.0.0"
            },
            {
              "id": "tailwind-advanced-lesson-11",
              "moduleSlug": "tailwind-advanced",
              "title": "Using Tailwind Plugins",
              "order": 11,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Plugins.\n\nLearn how to extend Tailwind with plugins.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "// Install and configure plugins\nnpm install @tailwindcss/forms @tailwindcss/typography\n\n// tailwind.config.js\nmodule.exports = {\n  plugins: [\n    require('@tailwindcss/forms'),\n    require('@tailwindcss/typography'),\n  ],\n}\n\n<!-- Typography plugin usage -->\n<article class=\"prose lg:prose-xl\">\n  <h1>Article Title</h1>\n  <p>Article content with beautiful typography.</p>\n</article>",
                "explanation": "This example produces: Enhanced forms and typography styling with official Tailwind plugins\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "css"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Using Tailwind Plugins",
                  "description": "Apply the concepts from this lesson on Plugins",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Plugins",
                "tailwind"
              ],
              "legacy": {
                "originalId": 11,
                "originalTopic": "Plugins",
                "migrated": "2025-10-01T06:41:13.487Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.487Z",
              "version": "1.0.0"
            },
            {
              "id": "tailwind-advanced-lesson-12",
              "moduleSlug": "tailwind-advanced",
              "title": "Framework Integration",
              "order": 12,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Integration.\n\nLearn how to integrate Tailwind with popular frameworks.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "// React integration\nimport './tailwind.css'\n\nfunction Button({ children, variant = 'primary' }) {\n  const baseClasses = 'px-4 py-2 rounded font-medium'\n  const variants = {\n    primary: 'bg-blue-500 text-white hover:bg-blue-600',\n    secondary: 'bg-gray-200 text-gray-800 hover:bg-gray-300'\n  }\n  \n  return (\n    <button className={`${baseClasses} ${variants[variant]}`}>\n      {children}\n    </button>\n  )\n}\n\n// Vue integration\n<template>\n  <button :class=\"buttonClasses\">\n    <slot />\n  </button>\n</template>\n\n<script>\nexport default {\n  computed: {\n    buttonClasses() {\n      return 'px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600'\n    }\n  }\n}\n</script>",
                "explanation": "This example produces: Tailwind CSS integrated with React and Vue components for reusable styling\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "css"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Framework Integration",
                  "description": "Apply the concepts from this lesson on Integration",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Integration",
                "tailwind"
              ],
              "legacy": {
                "originalId": 12,
                "originalTopic": "Integration",
                "migrated": "2025-10-01T06:41:13.487Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.487Z",
              "version": "1.0.0"
            },
            {
              "id": "tailwind-advanced-lesson-13",
              "moduleSlug": "tailwind-advanced",
              "title": "Advanced Tailwind CSS Patterns and Best Practices",
              "order": 13,
              "objectives": [
                "Master advanced Tailwind CSS patterns and techniques",
                "Implement scalable design systems with Tailwind",
                "Optimize Tailwind CSS for production applications"
              ],
              "intro": "Welcome to this comprehensive lesson on Advanced Tailwind CSS Patterns and Best Practices.\n\nLearn advanced techniques for building scalable, maintainable design systems with Tailwind CSS. This lesson covers complex patterns, performance optimization, and production-ready strategies.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "<!-- Advanced Component Patterns -->\n<!-- Configurable Button Component with Variants -->\n<div class=\"space-y-4\">\n  <!-- Primary Button -->\n  <button class=\"group relative inline-flex items-center justify-center px-4 py-2 text-sm font-medium rounded-md text-white bg-blue-600 border border-transparent hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:opacity-50 disabled:cursor-not-allowed transition-colors duration-200\">\n    <svg class=\"w-4 h-4 mr-2 transition-transform duration-200 group-hover:scale-110\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n      <path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M12 6v6m0 0v6m0-6h6m-6 0H6\"></path>\n    </svg>\n    Add Item\n  </button>\n\n  <!-- Outline Button with Loading State -->\n  <button class=\"group relative inline-flex items-center justify-center px-4 py-2 text-sm font-medium rounded-md text-blue-700 bg-transparent border border-blue-300 hover:bg-blue-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:opacity-50 transition-all duration-200\">\n    <div class=\"hidden group-disabled:inline-flex absolute inset-0 items-center justify-center\">\n      <svg class=\"animate-spin h-4 w-4 text-blue-600\" xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\">\n        <circle class=\"opacity-25\" cx=\"12\" cy=\"12\" r=\"10\" stroke=\"currentColor\" stroke-width=\"4\"></circle>\n        <path class=\"opacity-75\" fill=\"currentColor\" d=\"m4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z\"></path>\n      </svg>\n    </div>\n    <span class=\"group-disabled:invisible\">Save Changes</span>\n  </button>\n</div>\n\n<!-- Advanced Layout Patterns -->\n<!-- Sticky Header with Backdrop Blur -->\n<header class=\"sticky top-0 z-50 w-full border-b bg-white/80 backdrop-blur-md supports-[backdrop-filter]:bg-white/60\">\n  <div class=\"container flex h-16 items-center space-x-4 sm:justify-between sm:space-x-0\">\n    <div class=\"flex gap-6 md:gap-10\">\n      <a class=\"flex items-center space-x-2\" href=\"/\">\n        <span class=\"inline-block font-bold\">Logo</span>\n      </a>\n      <nav class=\"hidden gap-6 md:flex\">\n        <a class=\"flex items-center text-sm font-medium text-muted-foreground hover:text-foreground transition-colors\" href=\"/docs\">Documentation</a>\n      </nav>\n    </div>\n  </div>\n</header>\n\n<!-- Complex Grid Layout with Auto-fit -->\n<div class=\"grid gap-6 auto-fit-minmax-300 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4\">\n  <div class=\"group overflow-hidden rounded-lg border bg-card text-card-foreground shadow transition-all hover:shadow-lg\">\n    <div class=\"aspect-video overflow-hidden bg-muted\">\n      <img class=\"h-full w-full object-cover transition-transform duration-200 group-hover:scale-105\" src=\"/placeholder.jpg\" alt=\"Card image\" />\n    </div>\n    <div class=\"p-6\">\n      <h3 class=\"font-semibold leading-none tracking-tight\">Card Title</h3>\n      <p class=\"text-sm text-muted-foreground mt-2\">Card description goes here.</p>\n    </div>\n  </div>\n</div>\n\n<!-- Advanced Form Patterns with Validation States -->\n<form class=\"space-y-6\">\n  <div class=\"space-y-2\">\n    <label class=\"text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70\" for=\"email\">\n      Email\n    </label>\n    <input \n      class=\"peer flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 invalid:border-red-500 invalid:ring-red-500\"\n      id=\"email\"\n      type=\"email\"\n      placeholder=\"Enter your email\"\n      required\n    />\n    <p class=\"text-sm text-red-600 hidden peer-invalid:block\">Please enter a valid email address.</p>\n  </div>\n</form>\n\n<!-- Advanced Animation Patterns -->\n<div class=\"relative overflow-hidden\">\n  <!-- Staggered Animation with CSS Variables -->\n  <div class=\"grid gap-4 grid-cols-1 sm:grid-cols-2 lg:grid-cols-3\">\n    <div class=\"animate-fade-in-up [animation-delay:0ms] opacity-0 [animation-fill-mode:forwards]\">\n      <div class=\"h-32 bg-gradient-to-br from-purple-400 to-blue-600 rounded-lg\"></div>\n    </div>\n    <div class=\"animate-fade-in-up [animation-delay:100ms] opacity-0 [animation-fill-mode:forwards]\">\n      <div class=\"h-32 bg-gradient-to-br from-pink-400 to-red-600 rounded-lg\"></div>\n    </div>\n    <div class=\"animate-fade-in-up [animation-delay:200ms] opacity-0 [animation-fill-mode:forwards]\">\n      <div class=\"h-32 bg-gradient-to-br from-green-400 to-blue-600 rounded-lg\"></div>\n    </div>\n  </div>\n</div>\n\n<!-- CSS Additions for Custom Animations -->\n<style>\n@keyframes fade-in-up {\n  from {\n    opacity: 0;\n    transform: translateY(20px);\n  }\n  to {\n    opacity: 1;\n    transform: translateY(0);\n  }\n}\n\n.animate-fade-in-up {\n  animation: fade-in-up 0.6s ease-out;\n}\n\n.auto-fit-minmax-300 {\n  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));\n}\n</style>\n\n<!-- Tailwind Config for Custom Utilities -->\n/*\nmodule.exports = {\n  theme: {\n    extend: {\n      animation: {\n        'fade-in-up': 'fade-in-up 0.6s ease-out',\n      },\n      keyframes: {\n        'fade-in-up': {\n          'from': {\n            opacity: '0',\n            transform: 'translateY(20px)',\n          },\n          'to': {\n            opacity: '1',\n            transform: 'translateY(0)',\n          },\n        }\n      }\n    }\n  }\n}\n*/",
                "explanation": "This example demonstrates advanced Tailwind CSS patterns including configurable components with variants, complex layouts with backdrop blur effects, advanced form validation states, staggered animations, and custom utility integration. These patterns are essential for building production-ready applications.\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "html"
              },
              "pitfalls": [
                {
                  "mistake": "Over-engineering components with too many utility classes",
                  "solution": "Extract commonly used patterns into reusable components or use @apply directive for complex combinations",
                  "severity": "medium"
                },
                {
                  "mistake": "Not optimizing for production bundle size",
                  "solution": "Use PurgeCSS properly and configure content paths to remove unused styles",
                  "severity": "high"
                },
                {
                  "mistake": "Inconsistent design tokens across the application",
                  "solution": "Define consistent spacing, colors, and typography scales in Tailwind config",
                  "severity": "medium"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Advanced Tailwind CSS Patterns and Best Practices",
                  "description": "Implement a comprehensive design system using advanced Tailwind CSS techniques",
                  "checkpoints": [
                    "Create configurable component variants with Tailwind utilities",
                    "Implement complex layouts with responsive design patterns",
                    "Build advanced form components with validation states",
                    "Create custom animations and integrate with Tailwind config",
                    "Optimize for production and implement design system consistency"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 50,
              "difficulty": "Advanced",
              "tags": [
                "Advanced Patterns",
                "Design Systems",
                "Performance",
                "tailwind"
              ],
              "lastUpdated": "2025-10-01T06:41:13.487Z",
              "version": "1.0.0"
            }
          ],
          "issues": []
        },
        "quiz": {
          "exists": true,
          "count": 16,
          "questions": [
            {
              "id": "tailwind-advanced-q1",
              "question": "What is Tailwind CSS?",
              "topic": "Basics",
              "difficulty": "Beginner",
              "choices": [
                "A utility-first CSS framework",
                "A component-based CSS framework",
                "A CSS preprocessor",
                "A JavaScript framework"
              ],
              "correctIndex": 0,
              "explanation": "Tailwind CSS is a utility-first CSS framework that provides low-level utility classes to build designs without writing custom CSS.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Basics",
                "beginner",
                "tailwind"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 1,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.488Z"
              }
            },
            {
              "id": "tailwind-advanced-q2",
              "question": "How do you add padding to an element in Tailwind CSS?",
              "topic": "Basics",
              "difficulty": "Beginner",
              "choices": [
                "p-4",
                "m-4",
                "w-4",
                "h-4"
              ],
              "correctIndex": 0,
              "explanation": "In Tailwind, p-* classes are used for padding. The number represents the spacing scale where p-4 equals 1rem (16px).",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Basics",
                "beginner",
                "tailwind"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 2,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.488Z"
              }
            },
            {
              "id": "tailwind-advanced-q3",
              "question": "How does Tailwind's mobile-first responsive design approach work?",
              "topic": "Layout",
              "difficulty": "Intermediate",
              "choices": [
                "Open-ended question - no multiple choice",
                "This is a conceptual question",
                "Answer requires explanation",
                "Multiple approaches possible"
              ],
              "correctIndex": 0,
              "explanation": "Tailwind uses a mobile-first approach where unprefixed classes apply to all screen sizes, and responsive prefixes (sm:, md:, lg:, xl:) apply to specific breakpoints and larger screens. This means styles stack as the screen size increases.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Layout",
                "intermediate",
                "tailwind"
              ],
              "questionType": "open-ended",
              "estimatedTime": 180,
              "legacy": {
                "originalId": 3,
                "originalType": "open-ended",
                "migrated": "2025-10-01T06:41:13.488Z"
              }
            },
            {
              "id": "tailwind-advanced-q4",
              "question": "Which class is used to create a flex container in Tailwind?",
              "topic": "Layout",
              "difficulty": "Intermediate",
              "choices": [
                "flex",
                "grid",
                "block",
                "inline"
              ],
              "correctIndex": 0,
              "explanation": "The flex class creates a flex container in Tailwind CSS, enabling flexbox layout for its children.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Layout",
                "intermediate",
                "tailwind"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 4,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.488Z"
              }
            },
            {
              "id": "tailwind-advanced-q5",
              "question": "Where do you customize Tailwind's default theme?",
              "topic": "Customization",
              "difficulty": "Intermediate",
              "choices": [
                "tailwind.config.js",
                "package.json",
                "postcss.config.js",
                "styles.css"
              ],
              "correctIndex": 0,
              "explanation": "Tailwind's configuration file (tailwind.config.js) is where you customize the default theme, add plugins, and configure other options.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Customization",
                "intermediate",
                "tailwind"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 5,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.488Z"
              }
            },
            {
              "id": "tailwind-advanced-q6",
              "question": "How do you make text bold in Tailwind CSS?",
              "topic": "Utilities",
              "difficulty": "Beginner",
              "choices": [
                "font-bold",
                "text-bold",
                "bold",
                "font-weight-bold"
              ],
              "correctIndex": 0,
              "explanation": "The font-bold class makes text bold in Tailwind CSS. Tailwind uses the font-* naming convention for font weight utilities.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Utilities",
                "beginner",
                "tailwind"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 6,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.488Z"
              }
            },
            {
              "id": "tailwind-advanced-q7",
              "question": "What are the default breakpoints in Tailwind CSS?",
              "topic": "Responsive",
              "difficulty": "Intermediate",
              "choices": [
                "Open-ended question - no multiple choice",
                "This is a conceptual question",
                "Answer requires explanation",
                "Multiple approaches possible"
              ],
              "correctIndex": 0,
              "explanation": "Tailwind's default breakpoints are: sm (640px), md (768px), lg (1024px), xl (1280px), and 2xl (1536px). These can be customized in the tailwind.config.js file.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Responsive",
                "intermediate",
                "tailwind"
              ],
              "questionType": "open-ended",
              "estimatedTime": 180,
              "legacy": {
                "originalId": 7,
                "originalType": "open-ended",
                "migrated": "2025-10-01T06:41:13.488Z"
              }
            },
            {
              "id": "tailwind-advanced-q8",
              "question": "How do you set a background color to blue-500 in Tailwind?",
              "topic": "Colors",
              "difficulty": "Beginner",
              "choices": [
                "bg-blue-500",
                "background-blue-500",
                "color-blue-500",
                "blue-500-bg"
              ],
              "correctIndex": 0,
              "explanation": "In Tailwind, background colors are set using the bg-* naming convention, so bg-blue-500 sets the background color to the 500 shade of blue.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Colors",
                "beginner",
                "tailwind"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 8,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.488Z"
              }
            },
            {
              "id": "tailwind-advanced-q9",
              "question": "How do you add custom colors to Tailwind CSS?",
              "topic": "Customization",
              "difficulty": "Beginner",
              "choices": [
                "Extend the theme in tailwind.config.js",
                "Create new CSS classes",
                "Use inline styles",
                "Modify the core framework"
              ],
              "correctIndex": 0,
              "explanation": "Custom colors are added by extending the theme configuration in tailwind.config.js, which generates utility classes for your custom color palette.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Customization",
                "beginner",
                "tailwind"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 9,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.488Z"
              }
            },
            {
              "id": "tailwind-advanced-q10",
              "question": "What is PurgeCSS and why is it important for Tailwind?",
              "topic": "Performance",
              "difficulty": "Beginner",
              "choices": [
                "Removes unused CSS classes to reduce bundle size",
                "Validates CSS syntax",
                "Compresses images",
                "Optimizes JavaScript"
              ],
              "correctIndex": 0,
              "explanation": "PurgeCSS (now built into Tailwind) removes unused utility classes from the final CSS bundle, dramatically reducing file size from hundreds of KB to just a few KB.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Performance",
                "beginner",
                "tailwind"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 10,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.488Z"
              }
            },
            {
              "id": "tailwind-advanced-q11",
              "question": "How do you implement dark mode in Tailwind CSS?",
              "topic": "Dark Mode",
              "difficulty": "Beginner",
              "choices": [
                "Open-ended question - no multiple choice",
                "This is a conceptual question",
                "Answer requires explanation",
                "Multiple approaches possible"
              ],
              "correctIndex": 0,
              "explanation": "Enable dark mode by setting darkMode: 'class' in config, then use dark: prefixed utilities like 'bg-white dark:bg-gray-800'. Toggle by adding/removing 'dark' class on document element.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Dark Mode",
                "beginner",
                "tailwind"
              ],
              "questionType": "open-ended",
              "estimatedTime": 180,
              "legacy": {
                "originalId": 11,
                "originalType": "open-ended",
                "migrated": "2025-10-01T06:41:13.488Z"
              }
            },
            {
              "id": "tailwind-advanced-q12",
              "question": "What is the @apply directive used for in Tailwind?",
              "topic": "Components",
              "difficulty": "Beginner",
              "choices": [
                "Applying utility classes in custom CSS",
                "Creating animations",
                "Importing external CSS",
                "Optimizing performance"
              ],
              "correctIndex": 0,
              "explanation": "@apply allows you to use Tailwind utilities within custom CSS classes, useful for creating component classes while maintaining utility-first approach.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Components",
                "beginner",
                "tailwind"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 12,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.488Z"
              }
            },
            {
              "id": "tailwind-advanced-q13",
              "question": "How does Tailwind handle responsive design?",
              "topic": "Responsive Design",
              "difficulty": "Intermediate",
              "choices": [
                "Mobile-first breakpoint prefixes (sm:, md:, lg:, xl:)",
                "Desktop-first approach",
                "Automatic responsive scaling",
                "Media query mixins"
              ],
              "correctIndex": 0,
              "explanation": "Tailwind uses mobile-first responsive design with breakpoint prefixes that apply styles at specific screen sizes and larger.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Responsive Design",
                "intermediate",
                "tailwind"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 13,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.488Z"
              }
            },
            {
              "id": "tailwind-advanced-q14",
              "question": "What are Tailwind plugins and how do they extend functionality?",
              "topic": "Plugins",
              "difficulty": "Intermediate",
              "choices": [
                "Open-ended question - no multiple choice",
                "This is a conceptual question",
                "Answer requires explanation",
                "Multiple approaches possible"
              ],
              "correctIndex": 0,
              "explanation": "Tailwind plugins extend the framework by adding new utilities, components, or base styles. Official plugins include @tailwindcss/forms, @tailwindcss/typography, and @tailwindcss/aspect-ratio. Custom plugins can add project-specific utilities.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Plugins",
                "intermediate",
                "tailwind"
              ],
              "questionType": "open-ended",
              "estimatedTime": 180,
              "legacy": {
                "originalId": 14,
                "originalType": "open-ended",
                "migrated": "2025-10-01T06:41:13.488Z"
              }
            },
            {
              "id": "tailwind-advanced-q15",
              "question": "What is a recommended approach for managing long utility class lists?",
              "topic": "Best Practices",
              "difficulty": "Beginner",
              "choices": [
                "Extract to component classes or use @apply",
                "Use inline comments",
                "Group by functionality",
                "Use shorter class names"
              ],
              "correctIndex": 0,
              "explanation": "For maintainability, extract frequently used utility combinations into component classes using @apply, or create framework-specific components that encapsulate the styling.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Best Practices",
                "beginner",
                "tailwind"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 15,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.488Z"
              }
            },
            {
              "id": "tailwind-advanced-q16",
              "question": "What are the advanced techniques for building scalable design systems with Tailwind CSS?",
              "topic": "Advanced Patterns",
              "difficulty": "Advanced",
              "choices": [
                "Open-ended question - no multiple choice",
                "This is a conceptual question",
                "Answer requires explanation",
                "Multiple approaches possible"
              ],
              "correctIndex": 0,
              "explanation": "Advanced techniques include: creating configurable component variants using utility combinations, implementing consistent design tokens through Tailwind config customization, using CSS-in-JS libraries like styled-components with Tailwind, leveraging @apply directive for complex patterns, implementing staggered animations with CSS custom properties, optimizing bundle size with PurgeCSS, and building reusable component libraries with variant APIs.",
              "industryContext": "Advanced Tailwind patterns are essential for large-scale applications and design system implementation in enterprise environments.",
              "tags": [
                "Advanced Patterns",
                "advanced",
                "tailwind"
              ],
              "questionType": "open-ended",
              "estimatedTime": 180
            }
          ],
          "issues": []
        },
        "meetsThresholds": true,
        "issues": []
      },
      "vue-advanced": {
        "slug": "vue-advanced",
        "title": "Vue.js Framework",
        "tier": "specialized",
        "track": "Frontend",
        "difficulty": "Advanced",
        "thresholds": {
          "requiredLessons": 14,
          "requiredQuestions": 18
        },
        "lessons": {
          "exists": true,
          "count": 14,
          "lessons": [
            {
              "id": "vue-advanced-lesson-1",
              "moduleSlug": "vue-advanced",
              "title": "Vue Instance and Lifecycle",
              "order": 1,
              "objectives": [
                "Master component creation and usage",
                "Understand state management and lifecycle",
                "Implement practical solutions"
              ],
              "intro": "Welcome to this comprehensive lesson on Core Concepts.\n\nLearn about the Vue instance and its lifecycle hooks, which control the behavior of components throughout their existence.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "const app = Vue.createApp({\n  data() {\n    return {\n      message: 'Hello Vue!'\n    }\n  },\n  // Lifecycle hooks\n  beforeCreate() {\n    console.log('Before create - data and events are not set up yet')\n  },\n  created() {\n    console.log('Created - data and events are active, but DOM not mounted')\n    // Good place for API calls\n  },\n  beforeMount() {\n    console.log('Before mount - template and render functions about to be compiled')\n  },\n  mounted() {\n    console.log('Component is mounted!')\n    // Good place for DOM manipulation\n  },\n  beforeUpdate() {\n    console.log('Before update - called when data changes, before DOM update')\n  },\n  updated() {\n    console.log('Updated - called after DOM update')\n  },\n  beforeUnmount() {\n    console.log('Before unmount - called before component is destroyed')\n  },\n  unmounted() {\n    console.log('Unmounted - called after component is destroyed')\n  }\n})\n\napp.mount('#app')",
                "explanation": "This example produces: Hello Vue!\nComponent lifecycle logs in console showing the order of execution\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Vue Instance and Lifecycle",
                  "description": "Apply the concepts from this lesson on Core Concepts",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Core Concepts",
                "vue"
              ],
              "legacy": {
                "originalId": 1,
                "originalTopic": "Core Concepts",
                "migrated": "2025-10-01T06:41:13.488Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.488Z",
              "version": "1.0.0"
            },
            {
              "id": "vue-advanced-lesson-2",
              "moduleSlug": "vue-advanced",
              "title": "Template Syntax and Directives",
              "order": 2,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Core Concepts.\n\nLearn how to use Vue's powerful template syntax for data binding, conditional rendering, and list rendering with built-in directives.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "<div id=\"app\">\n  <!-- Text interpolation -->\n  <p>{{ message }}</p>\n  \n  <!-- Raw HTML (be careful with XSS) -->\n  <p v-html=\"rawHtml\"></p>\n  \n  <!-- Attribute binding -->\n  <div v-bind:id=\"dynamicId\">Bound ID</div>\n  <button v-bind:disabled=\"isButtonDisabled\">Button</button>\n  \n  <!-- Conditional rendering -->\n  <p v-if=\"seen\">Now you see me</p>\n  <p v-else>Now you don't</p>\n  \n  <!-- List rendering -->\n  <ul>\n    <li v-for=\"item in items\" :key=\"item.id\">\n      {{ item.text }}\n    </li>\n  </ul>\n  \n  <!-- Event handling -->\n  <button v-on:click=\"reverseMessage\">Reverse Message</button>\n  <button @click=\"counter += 1\">Count: {{ counter }}</button>\n  \n  <!-- Two-way binding -->\n  <input v-model=\"userInput\" placeholder=\"Type something\">\n  <p>You typed: {{ userInput }}</p>\n</div>\n\nconst app = Vue.createApp({\n  data() {\n    return {\n      message: 'Hello Vue!',\n      rawHtml: '<span style=\"color: red\">This is red</span>',\n      dynamicId: 'dynamic-id',\n      isButtonDisabled: false,\n      seen: true,\n      counter: 0,\n      userInput: '',\n      items: [\n        { id: 1, text: 'Item 1' },\n        { id: 2, text: 'Item 2' },\n        { id: 3, text: 'Item 3' }\n      ]\n    }\n  },\n  methods: {\n    reverseMessage() {\n      this.message = this.message.split('').reverse().join('')\n    }\n  }\n})",
                "explanation": "This example produces: Interactive component with text interpolation, attribute binding, conditional rendering, list rendering, event handling, and two-way binding\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Template Syntax and Directives",
                  "description": "Apply the concepts from this lesson on Core Concepts",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Core Concepts",
                "vue"
              ],
              "legacy": {
                "originalId": 2,
                "originalTopic": "Core Concepts",
                "migrated": "2025-10-01T06:41:13.488Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.488Z",
              "version": "1.0.0"
            },
            {
              "id": "vue-advanced-lesson-3",
              "moduleSlug": "vue-advanced",
              "title": "Component Basics and Communication",
              "order": 3,
              "objectives": [
                "Master component creation and usage",
                "Implement practical solutions"
              ],
              "intro": "Welcome to this comprehensive lesson on Components.\n\nLearn how to create and use Vue components with props for parent-to-child communication and events for child-to-parent communication.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "// Define a child component\nconst BlogPost = {\n  template: `\n    <div class=\"blog-post\">\n      <h3>{{ title }}</h3>\n      <p>{{ content }}</p>\n      <button @click=\"$emit('enlarge-text', 0.1)\">Enlarge text</button>\n      <button @click=\"$emit('delete-post')\">Delete</button>\n    </div>\n  `,\n  // Declare props\n  props: ['title', 'content'],\n  // Emits declaration (optional but recommended)\n  emits: ['enlarge-text', 'delete-post']\n}\n\nconst app = Vue.createApp({\n  data() {\n    return {\n      posts: [\n        { id: 1, title: 'My Journey with Vue', content: 'Content of post 1...' },\n        { id: 2, title: 'Blogging with Vue', content: 'Content of post 2...' },\n        { id: 3, title: 'Why Vue is Great', content: 'Content of post 3...' }\n      ],\n      postFontSize: 1\n    }\n  },\n  components: {\n    BlogPost\n  },\n  methods: {\n    onEnlargeText(enlargeAmount) {\n      this.postFontSize += enlargeAmount\n    },\n    onDeletePost() {\n      // Handle delete logic\n      console.log('Post deleted')\n    }\n  }\n})\n\n// In template:\n// <div :style=\"{ fontSize: postFontSize + 'em' }\">\n//   <blog-post\n//     v-for=\"post in posts\"\n//     :key=\"post.id\"\n//     :title=\"post.title\"\n//     :content=\"post.content\"\n//     @enlarge-text=\"onEnlargeText\"\n//     @delete-post=\"onDeletePost\"\n//   ></blog-post>\n// </div>",
                "explanation": "This example produces: A list of blog posts with interactive buttons to enlarge text or delete posts, demonstrating component communication\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not using keys in lists",
                  "solution": "Always provide unique keys for list items",
                  "severity": "high"
                },
                {
                  "mistake": "Mutating props directly",
                  "solution": "Props are read-only, create new objects for updates",
                  "severity": "medium"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Component Basics and Communication",
                  "description": "Apply the concepts from this lesson on Components",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Beginner",
              "tags": [
                "Components",
                "vue"
              ],
              "legacy": {
                "originalId": 3,
                "originalTopic": "Components",
                "migrated": "2025-10-01T06:41:13.488Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.488Z",
              "version": "1.0.0"
            },
            {
              "id": "vue-advanced-lesson-4",
              "moduleSlug": "vue-advanced",
              "title": "Slots and Dynamic Components",
              "order": 4,
              "objectives": [
                "Master component creation and usage",
                "Implement practical solutions"
              ],
              "intro": "Welcome to this comprehensive lesson on Components.\n\nLearn how to use slots for content distribution and dynamic components for flexible UI composition.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "// Component with slots\nconst BaseLayout = {\n  template: `\n    <div class=\"container\">\n      <header>\n        <slot name=\"header\">Default header</slot>\n      </header>\n      <main>\n        <slot></slot>\n      </main>\n      <footer>\n        <slot name=\"footer\">Default footer</slot>\n      </footer>\n    </div>\n  `\n}\n\n// Dynamic component example\nconst Home = {\n  template: `<div>Home Component</div>`\n}\n\nconst About = {\n  template: `<div>About Component</div>`\n}\n\nconst Contact = {\n  template: `<div>Contact Component</div>`\n}\n\nconst app = Vue.createApp({\n  data() {\n    return {\n      currentComponent: 'Home'\n    }\n  },\n  components: {\n    BaseLayout,\n    Home,\n    About,\n    Contact\n  }\n})\n\n// In template:\n// <base-layout>\n//   <template #header>\n//     <h1>Here might be a page title</h1>\n//   </template>\n// \n//   <p>A paragraph for the main content.</p>\n//   <p>And another one.</p>\n// \n//   <template #footer>\n//     <p>Here's some contact info</p>\n//   </template>\n// </base-layout>\n// \n// <!-- Dynamic component -->\n// <component :is=\"currentComponent\"></component>\n// <button @click=\"currentComponent = 'Home'\">Home</button>\n// <button @click=\"currentComponent = 'About'\">About</button>\n// <button @click=\"currentComponent = 'Contact'\">Contact</button>",
                "explanation": "This example produces: Flexible layout component with named slots and dynamic component switching\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not using keys in lists",
                  "solution": "Always provide unique keys for list items",
                  "severity": "high"
                },
                {
                  "mistake": "Mutating props directly",
                  "solution": "Props are read-only, create new objects for updates",
                  "severity": "medium"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Slots and Dynamic Components",
                  "description": "Apply the concepts from this lesson on Components",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Components",
                "vue"
              ],
              "legacy": {
                "originalId": 4,
                "originalTopic": "Components",
                "migrated": "2025-10-01T06:41:13.488Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.488Z",
              "version": "1.0.0"
            },
            {
              "id": "vue-advanced-lesson-5",
              "moduleSlug": "vue-advanced",
              "title": "Reactive References and Composables",
              "order": 5,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Composition API.\n\nLearn how to use reactive references with the Composition API and create reusable composables for complex logic.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "const { createApp, ref, reactive, computed, watch, onMounted } = Vue\n\n// Reusable composable function\nfunction useCounter(initialValue = 0) {\n  const count = ref(initialValue)\n  const increment = () => count.value++\n  const decrement = () => count.value--\n  const reset = () => count.value = initialValue\n  \n  const isEven = computed(() => count.value % 2 === 0)\n  \n  watch(count, (newVal, oldVal) => {\n    console.log(`Count changed from ${oldVal} to ${newVal}`)\n  })\n  \n  return { count, increment, decrement, reset, isEven }\n}\n\nconst app = createApp({\n  setup() {\n    // Using reactive references\n    const message = ref('Hello Vue 3!')\n    const user = reactive({\n      name: 'John Doe',\n      age: 30,\n      email: 'john@example.com'\n    })\n    \n    // Using computed property\n    const userInfo = computed(() => {\n      return `${user.name} (${user.age}) - ${user.email}`\n    })\n    \n    // Using composable\n    const { count, increment, decrement, reset, isEven } = useCounter(10)\n    \n    // Lifecycle hook\n    onMounted(() => {\n      console.log('Component mounted!')\n    })\n    \n    // Methods\n    const updateUser = () => {\n      user.name = 'Jane Doe'\n      user.age = 25\n    }\n    \n    return {\n      message,\n      user,\n      userInfo,\n      count,\n      increment,\n      decrement,\n      reset,\n      isEven,\n      updateUser\n    }\n  }\n})",
                "explanation": "This example produces: Reactive component with computed properties, watchers, and reusable composable functions\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Reactive References and Composables",
                  "description": "Apply the concepts from this lesson on Composition API",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Advanced",
              "tags": [
                "Composition API",
                "vue"
              ],
              "legacy": {
                "originalId": 5,
                "originalTopic": "Composition API",
                "migrated": "2025-10-01T06:41:13.488Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.488Z",
              "version": "1.0.0"
            },
            {
              "id": "vue-advanced-lesson-6",
              "moduleSlug": "vue-advanced",
              "title": "Pinia State Management",
              "order": 6,
              "objectives": [
                "Understand state management and lifecycle",
                "Implement practical solutions"
              ],
              "intro": "Welcome to this comprehensive lesson on State Management.\n\nLearn modern state management with Pinia for Vue 3 applications.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "// stores/counter.js\nimport { defineStore } from 'pinia'\n\nexport const useCounterStore = defineStore('counter', {\n  state: () => ({\n    count: 0,\n    name: 'Eduardo'\n  }),\n  getters: {\n    doubleCount: (state) => state.count * 2\n  },\n  actions: {\n    increment() {\n      this.count++\n    }\n  }\n})\n\n// Component usage\nimport { useCounterStore } from '@/stores/counter'\n\nexport default {\n  setup() {\n    const counter = useCounterStore()\n    return { counter }\n  }\n}",
                "explanation": "This example produces: Centralized state management with reactive stores\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Pinia State Management",
                  "description": "Apply the concepts from this lesson on State Management",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "State Management",
                "vue"
              ],
              "legacy": {
                "originalId": 6,
                "originalTopic": "State Management",
                "migrated": "2025-10-01T06:41:13.488Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.488Z",
              "version": "1.0.0"
            },
            {
              "id": "vue-advanced-lesson-7",
              "moduleSlug": "vue-advanced",
              "title": "Vue Router Navigation",
              "order": 7,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Routing.\n\nLearn client-side routing with Vue Router for single-page applications.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "import { createRouter, createWebHistory } from 'vue-router'\nimport Home from './views/Home.vue'\nimport About from './views/About.vue'\n\nconst routes = [\n  { path: '/', component: Home },\n  { path: '/about', component: About },\n  { path: '/user/:id', component: UserProfile, props: true }\n]\n\nconst router = createRouter({\n  history: createWebHistory(),\n  routes\n})\n\n// Navigation guards\nrouter.beforeEach((to, from, next) => {\n  console.log('Navigating to:', to.path)\n  next()\n})\n\nexport default router",
                "explanation": "This example produces: Single-page application with dynamic routing and navigation guards\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Vue Router Navigation",
                  "description": "Apply the concepts from this lesson on Routing",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Routing",
                "vue"
              ],
              "legacy": {
                "originalId": 7,
                "originalTopic": "Routing",
                "migrated": "2025-10-01T06:41:13.488Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.488Z",
              "version": "1.0.0"
            },
            {
              "id": "vue-advanced-lesson-8",
              "moduleSlug": "vue-advanced",
              "title": "Form Handling and Validation",
              "order": 8,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Forms.\n\nLearn comprehensive form handling with validation in Vue applications.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "<template>\n  <form @submit.prevent=\"submitForm\">\n    <input v-model=\"form.email\" :class=\"{ error: errors.email }\" />\n    <span v-if=\"errors.email\">{{ errors.email }}</span>\n    <button type=\"submit\" :disabled=\"!isValid\">Submit</button>\n  </form>\n</template>\n\n<script setup>\nimport { reactive, computed } from 'vue'\n\nconst form = reactive({\n  email: '',\n  password: ''\n})\n\nconst errors = reactive({})\n\nconst isValid = computed(() => {\n  return form.email && form.password && !Object.keys(errors).length\n})\n\nconst validateEmail = () => {\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/\n  errors.email = emailRegex.test(form.email) ? '' : 'Invalid email'\n}\n</script>",
                "explanation": "This example produces: Reactive form with real-time validation and error handling\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Form Handling and Validation",
                  "description": "Apply the concepts from this lesson on Forms",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Forms",
                "vue"
              ],
              "legacy": {
                "originalId": 8,
                "originalTopic": "Forms",
                "migrated": "2025-10-01T06:41:13.488Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.488Z",
              "version": "1.0.0"
            },
            {
              "id": "vue-advanced-lesson-9",
              "moduleSlug": "vue-advanced",
              "title": "Performance Optimization",
              "order": 9,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Performance.\n\nLearn techniques to optimize Vue application performance.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "// Lazy loading components\nconst AsyncComponent = defineAsyncComponent(() => import('./HeavyComponent.vue'))\n\n// Memoization with computed\nconst expensiveValue = computed(() => {\n  return heavyCalculation(props.data)\n})\n\n// Virtual scrolling for large lists\n<template>\n  <RecycleScroller\n    class=\"scroller\"\n    :items=\"items\"\n    :item-size=\"32\"\n    key-field=\"id\"\n    v-slot=\"{ item }\"\n  >\n    <div class=\"user\">{{ item.name }}</div>\n  </RecycleScroller>\n</template>",
                "explanation": "This example produces: Optimized application with lazy loading and virtual scrolling\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Performance Optimization",
                  "description": "Apply the concepts from this lesson on Performance",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Advanced",
              "tags": [
                "Performance",
                "vue"
              ],
              "legacy": {
                "originalId": 9,
                "originalTopic": "Performance",
                "migrated": "2025-10-01T06:41:13.488Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.488Z",
              "version": "1.0.0"
            },
            {
              "id": "vue-advanced-lesson-10",
              "moduleSlug": "vue-advanced",
              "title": "Component Testing",
              "order": 10,
              "objectives": [
                "Master component creation and usage",
                "Implement practical solutions"
              ],
              "intro": "Welcome to this comprehensive lesson on Testing.\n\nLearn how to test Vue components using Vue Test Utils and Vitest.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "// Counter.test.js\nimport { mount } from '@vue/test-utils'\nimport Counter from '@/components/Counter.vue'\n\ndescribe('Counter', () => {\n  test('increments count when button is clicked', async () => {\n    const wrapper = mount(Counter)\n    \n    expect(wrapper.text()).toContain('0')\n    \n    await wrapper.find('button').trigger('click')\n    \n    expect(wrapper.text()).toContain('1')\n  })\n  \n  test('accepts initial count prop', () => {\n    const wrapper = mount(Counter, {\n      props: { initialCount: 5 }\n    })\n    \n    expect(wrapper.text()).toContain('5')\n  })\n})",
                "explanation": "This example produces:  increments count when button is clicked\n accepts initial count prop\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Component Testing",
                  "description": "Apply the concepts from this lesson on Testing",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Testing",
                "vue"
              ],
              "legacy": {
                "originalId": 10,
                "originalTopic": "Testing",
                "migrated": "2025-10-01T06:41:13.488Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.488Z",
              "version": "1.0.0"
            },
            {
              "id": "vue-advanced-lesson-11",
              "moduleSlug": "vue-advanced",
              "title": "Teleport and Portal Patterns",
              "order": 11,
              "objectives": [
                "Master component creation and usage",
                "Implement practical solutions"
              ],
              "intro": "Welcome to this comprehensive lesson on Teleport.\n\nLearn how to use Teleport for rendering components outside the normal DOM hierarchy.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "<template>\n  <div>\n    <button @click=\"showModal = true\">Open Modal</button>\n    \n    <Teleport to=\"body\">\n      <div v-if=\"showModal\" class=\"modal\">\n        <div class=\"modal-content\">\n          <h2>Modal Title</h2>\n          <p>Modal content here</p>\n          <button @click=\"showModal = false\">Close</button>\n        </div>\n      </div>\n    </Teleport>\n  </div>\n</template>\n\n<script setup>\nimport { ref } from 'vue'\nconst showModal = ref(false)\n</script>",
                "explanation": "This example produces: Modal component rendered outside component hierarchy using Teleport\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Teleport and Portal Patterns",
                  "description": "Apply the concepts from this lesson on Teleport",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Teleport",
                "vue"
              ],
              "legacy": {
                "originalId": 11,
                "originalTopic": "Teleport",
                "migrated": "2025-10-01T06:41:13.488Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.488Z",
              "version": "1.0.0"
            },
            {
              "id": "vue-advanced-lesson-12",
              "moduleSlug": "vue-advanced",
              "title": "Custom Directives and Plugins",
              "order": 12,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Advanced.\n\nLearn how to create custom directives and plugins to extend Vue functionality.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "// Custom directive\nconst vFocus = {\n  mounted(el) {\n    el.focus()\n  }\n}\n\n// Plugin\nconst myPlugin = {\n  install(app, options) {\n    app.config.globalProperties.$translate = (key) => {\n      return key.split('.').reduce((o, i) => o[i], options)\n    }\n    \n    app.provide('i18n', options)\n    \n    app.directive('focus', vFocus)\n  }\n}\n\n// Usage\napp.use(myPlugin, { hello: 'Bonjour!' })\n\n// In component\n<input v-focus />\n<p>{{ $translate('hello') }}</p>",
                "explanation": "This example produces: Custom functionality with directives and plugins extending Vue capabilities\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Custom Directives and Plugins",
                  "description": "Apply the concepts from this lesson on Advanced",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Advanced",
              "tags": [
                "Advanced",
                "vue"
              ],
              "legacy": {
                "originalId": 12,
                "originalTopic": "Advanced",
                "migrated": "2025-10-01T06:41:13.488Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.488Z",
              "version": "1.0.0"
            },
            {
              "id": "vue-advanced-lesson-13",
              "moduleSlug": "vue-advanced",
              "title": "Advanced Component Patterns",
              "order": 13,
              "objectives": [
                "Master advanced component composition patterns",
                "Implement render functions and JSX",
                "Create flexible component APIs with provide/inject"
              ],
              "intro": "Advanced component patterns in Vue enable the creation of highly flexible and reusable components that can adapt to various use cases while maintaining clean APIs. This lesson explores sophisticated techniques that go beyond basic component composition to create powerful, developer-friendly component libraries.\n\nYou'll learn to implement render functions for maximum flexibility, leverage provide/inject for dependency injection, and create component patterns that solve complex UI challenges. These patterns are essential for building design systems, component libraries, and applications with complex component hierarchies.\n\nWe'll explore practical examples including compound components, renderless components, and higher-order components that demonstrate real-world applications of these patterns. You'll also learn when to use each pattern and how to balance flexibility with simplicity.\n\nMastering these advanced patterns will enable you to create components that are not only reusable but also maintainable and easy to work with, even as your application grows in complexity.",
              "code": {
                "example": "// Render function component\nconst DynamicHeading = {\n  props: ['level', 'text'],\n  render() {\n    const tag = `h${this.level}`\n    return h(tag, {\n      class: `heading-${this.level}`\n    }, this.text)\n  }\n}\n\n// Renderless component pattern\nconst DataProvider = {\n  props: ['url'],\n  setup(props, { slots }) {\n    const data = ref(null)\n    const loading = ref(false)\n    const error = ref(null)\n\n    const fetchData = async () => {\n      loading.value = true\n      try {\n        const response = await fetch(props.url)\n        data.value = await response.json()\n      } catch (err) {\n        error.value = err.message\n      } finally {\n        loading.value = false\n      }\n    }\n\n    onMounted(fetchData)\n\n    return () => slots.default({\n      data: data.value,\n      loading: loading.value,\n      error: error.value,\n      refetch: fetchData\n    })\n  }\n}\n\n// Provide/Inject pattern for theme\nconst ThemeProvider = {\n  setup(props, { slots }) {\n    const theme = reactive({\n      primaryColor: '#007bff',\n      secondaryColor: '#6c757d',\n      spacing: {\n        sm: '0.5rem',\n        md: '1rem',\n        lg: '1.5rem'\n      }\n    })\n\n    provide('theme', theme)\n\n    return () => slots.default()\n  }\n}\n\n// Consumer component\nconst ThemedButton = {\n  setup() {\n    const theme = inject('theme')\n\n    const buttonStyle = computed(() => ({\n      backgroundColor: theme.primaryColor,\n      padding: theme.spacing.md,\n      border: 'none',\n      borderRadius: '4px',\n      color: 'white',\n      cursor: 'pointer'\n    }))\n\n    return { buttonStyle }\n  },\n  template: `\n    <button :style=\"buttonStyle\">\n      <slot></slot>\n    </button>\n  `\n}\n\n// Compound component pattern\nconst Card = {\n  name: 'Card',\n  template: `\n    <div class=\"card\">\n      <slot></slot>\n    </div>\n  `\n}\n\nconst CardHeader = {\n  name: 'CardHeader',\n  template: `\n    <div class=\"card-header\">\n      <slot></slot>\n    </div>\n  `\n}\n\nconst CardBody = {\n  name: 'CardBody',\n  template: `\n    <div class=\"card-body\">\n      <slot></slot>\n    </div>\n  `\n}\n\nconst CardFooter = {\n  name: 'CardFooter',\n  template: `\n    <div class=\"card-footer\">\n      <slot></slot>\n    </div>\n  `\n}\n\n// Higher-order component for loading state\nconst withLoading = (WrappedComponent) => {\n  return {\n    props: ['loading', ...Object.keys(WrappedComponent.props || {})],\n    setup(props, context) {\n      const wrappedProps = computed(() => {\n        const { loading, ...rest } = props\n        return rest\n      })\n\n      return () => {\n        if (props.loading) {\n          return h('div', { class: 'loading-spinner' }, 'Loading...')\n        }\n        return h(WrappedComponent, wrappedProps.value, context.slots)\n      }\n    }\n  }\n}\n\n// Usage examples:\n// <theme-provider>\n//   <themed-button>Click me</themed-button>\n// </theme-provider>\n\n// <data-provider url=\"/api/users\" v-slot=\"{ data, loading, error }\">\n//   <div v-if=\"loading\">Loading...</div>\n//   <div v-else-if=\"error\">Error: {{ error }}</div>\n//   <ul v-else>\n//     <li v-for=\"user in data\" :key=\"user.id\">{{ user.name }}</li>\n//   </ul>\n// </data-provider>\n\n// <card>\n//   <card-header>Card Title</card-header>\n//   <card-body>Card content goes here</card-body>\n//   <card-footer>Card footer</card-footer>\n// </card>",
                "explanation": "This example demonstrates advanced Vue component patterns including render functions for dynamic HTML generation, renderless components for logic reuse, provide/inject for dependency injection, compound components for flexible APIs, and higher-order components for cross-cutting concerns like loading states.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Overusing render functions when templates would suffice",
                  "solution": "Use render functions only when you need dynamic tag names or complex conditional rendering",
                  "severity": "medium"
                },
                {
                  "mistake": "Creating overly complex component APIs",
                  "solution": "Balance flexibility with simplicity, provide sensible defaults",
                  "severity": "medium"
                },
                {
                  "mistake": "Not properly typing provide/inject with TypeScript",
                  "solution": "Use injection keys and type definitions for better type safety",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Build a Flexible Data Table Component",
                  "description": "Create a reusable data table using advanced patterns including compound components for header/body/footer, renderless logic for sorting/filtering, and provide/inject for configuration",
                  "checkpoints": [
                    "Implement compound component pattern for table structure",
                    "Create renderless component for data logic",
                    "Use provide/inject for table configuration",
                    "Add render function for dynamic cell rendering"
                  ]
                }
              ],
              "next": [
                "vue-advanced-lesson-14"
              ],
              "estimatedMinutes": 45,
              "difficulty": "Advanced",
              "tags": [
                "Advanced Patterns",
                "Render Functions",
                "Provide/Inject",
                "Component Design",
                "vue"
              ],
              "lastUpdated": "2025-01-27T10:15:00.000Z",
              "version": "1.0.0"
            },
            {
              "id": "vue-advanced-lesson-14",
              "moduleSlug": "vue-advanced",
              "title": "Vue 3 Ecosystem and Production Deployment",
              "order": 14,
              "objectives": [
                "Master Vue 3 ecosystem tools and libraries",
                "Implement production-ready build and deployment strategies",
                "Optimize applications for performance and SEO"
              ],
              "intro": "Building production-ready Vue applications requires mastery of the Vue ecosystem and deployment best practices. This comprehensive lesson covers the essential tools, libraries, and strategies needed to take your Vue applications from development to production successfully.\n\nYou'll explore the modern Vue ecosystem including Vite for lightning-fast development and building, Vue Router for sophisticated routing needs, Pinia for state management, and various UI libraries. We'll also cover testing strategies, performance optimization techniques, and SEO considerations for Vue applications.\n\nDeployment strategies vary significantly based on your application needs, from static site generation with Nuxt.js to server-side rendering and traditional SPA deployments. You'll learn to choose the right approach and implement it effectively with proper monitoring and error handling.\n\nBy the end of this lesson, you'll have the knowledge to architect, build, and deploy robust Vue applications that perform well in production environments and provide excellent user experiences across different devices and network conditions.",
              "code": {
                "example": "// vite.config.js - Production optimization\nimport { defineConfig } from 'vite'\nimport vue from '@vitejs/plugin-vue'\nimport { resolve } from 'path'\n\nexport default defineConfig({\n  plugins: [vue()],\n  resolve: {\n    alias: {\n      '@': resolve(__dirname, 'src')\n    }\n  },\n  build: {\n    target: 'esnext',\n    minify: 'terser',\n    terserOptions: {\n      compress: {\n        drop_console: true,\n        drop_debugger: true\n      }\n    },\n    rollupOptions: {\n      output: {\n        manualChunks: {\n          'vendor': ['vue', 'vue-router', 'pinia'],\n          'ui': ['@headlessui/vue', '@heroicons/vue']\n        }\n      }\n    },\n    chunkSizeWarningLimit: 1000\n  },\n  server: {\n    port: 3000,\n    proxy: {\n      '/api': {\n        target: 'http://localhost:8000',\n        changeOrigin: true\n      }\n    }\n  }\n})\n\n// Production-ready router configuration\n// router/index.js\nimport { createRouter, createWebHistory } from 'vue-router'\nimport { useAuthStore } from '@/stores/auth'\n\nconst router = createRouter({\n  history: createWebHistory(import.meta.env.BASE_URL),\n  routes: [\n    {\n      path: '/',\n      name: 'Home',\n      component: () => import('@/views/HomeView.vue'),\n      meta: { requiresAuth: false }\n    },\n    {\n      path: '/dashboard',\n      name: 'Dashboard',\n      component: () => import('@/views/DashboardView.vue'),\n      meta: { requiresAuth: true }\n    },\n    {\n      path: '/login',\n      name: 'Login',\n      component: () => import('@/views/LoginView.vue'),\n      meta: { guest: true }\n    },\n    {\n      path: '/:pathMatch(.*)*',\n      name: 'NotFound',\n      component: () => import('@/views/NotFoundView.vue')\n    }\n  ],\n  scrollBehavior(to, from, savedPosition) {\n    if (savedPosition) {\n      return savedPosition\n    } else {\n      return { top: 0 }\n    }\n  }\n})\n\n// Global navigation guard\nrouter.beforeEach(async (to, from, next) => {\n  const authStore = useAuthStore()\n  \n  // Check if route requires authentication\n  if (to.meta.requiresAuth && !authStore.isAuthenticated) {\n    next({ name: 'Login', query: { redirect: to.fullPath } })\n    return\n  }\n  \n  // Redirect authenticated users away from guest-only pages\n  if (to.meta.guest && authStore.isAuthenticated) {\n    next({ name: 'Dashboard' })\n    return\n  }\n  \n  next()\n})\n\nexport default router\n\n// Production-ready Pinia store\n// stores/auth.js\nimport { defineStore } from 'pinia'\nimport { ref, computed } from 'vue'\nimport api from '@/services/api'\n\nexport const useAuthStore = defineStore('auth', () => {\n  const user = ref(null)\n  const token = ref(localStorage.getItem('token'))\n  const isLoading = ref(false)\n  const error = ref(null)\n\n  const isAuthenticated = computed(() => !!token.value && !!user.value)\n\n  const login = async (credentials) => {\n    isLoading.value = true\n    error.value = null\n    \n    try {\n      const response = await api.post('/auth/login', credentials)\n      const { token: authToken, user: userData } = response.data\n      \n      token.value = authToken\n      user.value = userData\n      localStorage.setItem('token', authToken)\n      \n      return { success: true }\n    } catch (err) {\n      error.value = err.response?.data?.message || 'Login failed'\n      return { success: false, error: error.value }\n    } finally {\n      isLoading.value = false\n    }\n  }\n\n  const logout = () => {\n    user.value = null\n    token.value = null\n    localStorage.removeItem('token')\n  }\n\n  const checkAuth = async () => {\n    if (!token.value) return\n\n    try {\n      const response = await api.get('/auth/me')\n      user.value = response.data\n    } catch (err) {\n      logout()\n    }\n  }\n\n  return {\n    user: readonly(user),\n    token: readonly(token),\n    isLoading: readonly(isLoading),\n    error: readonly(error),\n    isAuthenticated,\n    login,\n    logout,\n    checkAuth\n  }\n})\n\n// Error boundary composable\n// composables/useErrorHandler.js\nimport { ref, onErrorCaptured } from 'vue'\n\nexport function useErrorHandler() {\n  const error = ref(null)\n  const isError = ref(false)\n\n  const handleError = (err) => {\n    error.value = err\n    isError.value = true\n    \n    // Log to external service\n    if (import.meta.env.PROD) {\n      console.error('Production error:', err)\n      // Send to error tracking service\n      // Sentry.captureException(err)\n    }\n  }\n\n  const clearError = () => {\n    error.value = null\n    isError.value = false\n  }\n\n  onErrorCaptured((err) => {\n    handleError(err)\n    return false\n  })\n\n  return {\n    error: readonly(error),\n    isError: readonly(isError),\n    handleError,\n    clearError\n  }\n}\n\n// Docker deployment configuration\n# Dockerfile\nFROM node:18-alpine AS build\n\nWORKDIR /app\nCOPY package*.json ./\nRUN npm ci --only=production\n\nCOPY . .\nRUN npm run build\n\nFROM nginx:alpine AS production\nCOPY --from=build /app/dist /usr/share/nginx/html\nCOPY nginx.conf /etc/nginx/nginx.conf\n\nEXPOSE 80\nCMD [\"nginx\", \"-g\", \"daemon off;\"]",
                "explanation": "This comprehensive example shows production-ready Vue 3 application setup including Vite configuration for optimized builds, router with authentication guards, Pinia store with error handling, error boundary composable, and Docker deployment configuration for scalable production deployment.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not implementing proper error boundaries",
                  "solution": "Use error boundaries and global error handlers to gracefully handle runtime errors",
                  "severity": "high"
                },
                {
                  "mistake": "Ignoring bundle size optimization",
                  "solution": "Implement code splitting, tree shaking, and analyze bundle sizes regularly",
                  "severity": "medium"
                },
                {
                  "mistake": "Not setting up proper monitoring and logging",
                  "solution": "Implement error tracking, performance monitoring, and user analytics",
                  "severity": "medium"
                }
              ],
              "exercises": [
                {
                  "title": "Deploy a Production-Ready Vue Application",
                  "description": "Create a complete Vue application with authentication, error handling, performance optimization, and deploy it using modern CI/CD practices",
                  "checkpoints": [
                    "Set up Vite with production optimizations",
                    "Implement authentication with Pinia",
                    "Add error boundaries and monitoring",
                    "Configure Docker deployment with Nginx",
                    "Set up CI/CD pipeline for automated deployment"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 50,
              "difficulty": "Advanced",
              "tags": [
                "Ecosystem",
                "Deployment",
                "Production",
                "Vite",
                "Performance",
                "vue"
              ],
              "lastUpdated": "2025-01-27T10:15:00.000Z",
              "version": "1.0.0"
            }
          ],
          "issues": []
        },
        "quiz": {
          "exists": true,
          "count": 18,
          "questions": [
            {
              "id": "vue-advanced-q1",
              "question": "What is the correct way to create a Vue application in Vue 3?",
              "topic": "Core Concepts",
              "difficulty": "Beginner",
              "choices": [
                "Vue.createApp({})",
                "new Vue({})",
                "Vue.app({})",
                "Vue.init({})"
              ],
              "correctIndex": 0,
              "explanation": "In Vue 3, applications are created using Vue.createApp({}). This is different from Vue 2 where new Vue({}) was used. The new API provides better modularity and allows creating multiple Vue applications on the same page.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Core Concepts",
                "beginner",
                "vue"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 1,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.489Z"
              }
            },
            {
              "id": "vue-advanced-q2",
              "question": "Which directive is used for two-way data binding in Vue?",
              "topic": "Core Concepts",
              "difficulty": "Intermediate",
              "choices": [
                "v-model",
                "v-bind",
                "v-on",
                "v-show"
              ],
              "correctIndex": 0,
              "explanation": "The v-model directive is used for two-way data binding between form inputs and application state. It automatically picks the correct way to update the element based on the input type.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Core Concepts",
                "intermediate",
                "vue"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 2,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.489Z"
              }
            },
            {
              "id": "vue-advanced-q3",
              "question": "What are props in Vue and how are they used? How do they differ from the data property?",
              "topic": "Components",
              "difficulty": "Intermediate",
              "choices": [
                "Open-ended question - no multiple choice",
                "This is a conceptual question",
                "Answer requires explanation",
                "Multiple approaches possible"
              ],
              "correctIndex": 0,
              "explanation": "Props are custom attributes you can register on a component to pass data from parent components to child components. They are used to pass data down the component tree. Props are read-only in the child component, while data properties are mutable within the component. Props are defined in the parent component's template, while data properties are defined within the component itself.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Components",
                "intermediate",
                "vue"
              ],
              "questionType": "open-ended",
              "estimatedTime": 180,
              "legacy": {
                "originalId": 3,
                "originalType": "open-ended",
                "migrated": "2025-10-01T06:41:13.489Z"
              }
            },
            {
              "id": "vue-advanced-q4",
              "question": "How do you define a global component in Vue 3?",
              "topic": "Components",
              "difficulty": "Beginner",
              "choices": [
                "app.component('my-component', MyComponent)",
                "Vue.component('my-component', MyComponent)",
                "MyComponent.component('my-component')",
                "component('my-component', MyComponent)"
              ],
              "correctIndex": 0,
              "explanation": "In Vue 3, global components are registered using app.component() where app is the application instance returned by Vue.createApp(). This is different from Vue 2 where Vue.component() was used. The new approach provides better encapsulation.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Components",
                "beginner",
                "vue"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 4,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.489Z"
              }
            },
            {
              "id": "vue-advanced-q5",
              "question": "What is the purpose of the setup() function in the Composition API?",
              "topic": "Composition API",
              "difficulty": "Beginner",
              "choices": [
                "It's the entry point for Composition API logic",
                "It replaces the data option entirely",
                "It's used only for async operations",
                "It's deprecated in Vue 3"
              ],
              "correctIndex": 0,
              "explanation": "The setup() function is the entry point for Composition API logic. It's executed before the component is created, once the props are resolved. It's where you define reactive state, computed properties, watchers, and lifecycle hooks when using the Composition API.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Composition API",
                "beginner",
                "vue"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 5,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.489Z"
              }
            },
            {
              "id": "vue-advanced-q6",
              "question": "What is the difference between ref and reactive in Vue 3?",
              "topic": "Reactivity",
              "difficulty": "Beginner",
              "choices": [
                "ref is for primitive values, reactive is for objects",
                "ref is for objects, reactive is for primitive values",
                "Both work the same way",
                "ref is deprecated in Vue 3"
              ],
              "correctIndex": 0,
              "explanation": "ref is used to create a reactive reference that can hold any value (primitive or object), and you access its value with .value. reactive is used to create a reactive object, but it only works with objects and arrays, not primitive values. For primitives, you must use ref.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Reactivity",
                "beginner",
                "vue"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 6,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.489Z"
              }
            },
            {
              "id": "vue-advanced-q7",
              "question": "Explain the Vue component lifecycle hooks and when you would use each one.",
              "topic": "Lifecycle",
              "difficulty": "Intermediate",
              "choices": [
                "Open-ended question - no multiple choice",
                "This is a conceptual question",
                "Answer requires explanation",
                "Multiple approaches possible"
              ],
              "correctIndex": 0,
              "explanation": "Vue component lifecycle hooks include: created (for initializing data and events), mounted (for DOM manipulation and API calls), updated (for operations after DOM updates), and unmounted (for cleanup). In Composition API, these are onMounted, onUpdated, onUnmounted, etc. Use created for data initialization, mounted for DOM-dependent operations, updated for post-render updates, and unmounted for cleanup.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Lifecycle",
                "intermediate",
                "vue"
              ],
              "questionType": "open-ended",
              "estimatedTime": 180,
              "legacy": {
                "originalId": 7,
                "originalType": "open-ended",
                "migrated": "2025-10-01T06:41:13.489Z"
              }
            },
            {
              "id": "vue-advanced-q8",
              "question": "What is the difference between v-if and v-show?",
              "topic": "Directives",
              "difficulty": "Beginner",
              "choices": [
                "v-if conditionally renders elements, v-show toggles CSS display property",
                "v-if is for lists, v-show is for single elements",
                "v-if is faster than v-show",
                "There is no difference"
              ],
              "correctIndex": 0,
              "explanation": "v-if conditionally renders elements by actually adding or removing them from the DOM based on the condition. v-show simply toggles the CSS display property to show or hide elements. v-if has higher toggle costs but v-show has higher initial render costs. Use v-if for rarely changed conditions and v-show for frequently toggled elements.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Directives",
                "beginner",
                "vue"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 8,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.489Z"
              }
            },
            {
              "id": "vue-advanced-q9",
              "question": "What is the main advantage of Vue 3's Composition API?",
              "topic": "Composition API",
              "difficulty": "Beginner",
              "choices": [
                "Better logic reuse and TypeScript support",
                "Faster rendering",
                "Smaller bundle size",
                "Automatic optimization"
              ],
              "correctIndex": 0,
              "explanation": "The Composition API provides better logic reuse through composables, improved TypeScript support, and cleaner organization of component logic.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Composition API",
                "beginner",
                "vue"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 9,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.489Z"
              }
            },
            {
              "id": "vue-advanced-q10",
              "question": "What is the difference between ref() and reactive() in Vue 3?",
              "topic": "Reactivity",
              "difficulty": "Beginner",
              "choices": [
                "ref() for primitives, reactive() for objects",
                "ref() is faster than reactive()",
                "reactive() is deprecated",
                "No functional difference"
              ],
              "correctIndex": 0,
              "explanation": "ref() is used for primitive values and returns a reactive reference, while reactive() is used for objects and makes them deeply reactive.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Reactivity",
                "beginner",
                "vue"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 10,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.489Z"
              }
            },
            {
              "id": "vue-advanced-q11",
              "question": "How can you optimize Vue application performance?",
              "topic": "Performance",
              "difficulty": "Advanced",
              "choices": [
                "Open-ended question - no multiple choice",
                "This is a conceptual question",
                "Answer requires explanation",
                "Multiple approaches possible"
              ],
              "correctIndex": 0,
              "explanation": "Optimize Vue apps through: lazy loading components, using v-show vs v-if appropriately, implementing virtual scrolling, optimizing computed properties, using keep-alive for cached components, and minimizing reactivity overhead.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Performance",
                "advanced",
                "vue"
              ],
              "questionType": "open-ended",
              "estimatedTime": 180,
              "legacy": {
                "originalId": 11,
                "originalType": "open-ended",
                "migrated": "2025-10-01T06:41:13.489Z"
              }
            },
            {
              "id": "vue-advanced-q12",
              "question": "What is Pinia and how does it relate to Vuex?",
              "topic": "State Management",
              "difficulty": "Beginner",
              "choices": [
                "Pinia is the recommended state management for Vue 3, replacing Vuex",
                "Pinia is a Vue component library",
                "Pinia is a testing framework",
                "Pinia is a UI framework"
              ],
              "correctIndex": 0,
              "explanation": "Pinia is the official state management solution for Vue 3, offering better TypeScript support, simpler API, and improved devtools compared to Vuex.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "State Management",
                "beginner",
                "vue"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 12,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.489Z"
              }
            },
            {
              "id": "vue-advanced-q13",
              "question": "Which tool is recommended for testing Vue components?",
              "topic": "Testing",
              "difficulty": "Intermediate",
              "choices": [
                "Vue Test Utils with Vitest",
                "Jest only",
                "Selenium",
                "Cypress only"
              ],
              "correctIndex": 0,
              "explanation": "Vue Test Utils provides utilities for testing Vue components, often paired with Vitest for fast unit testing in Vue 3 projects.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Testing",
                "intermediate",
                "vue"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 13,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.489Z"
              }
            },
            {
              "id": "vue-advanced-q14",
              "question": "What are Teleports in Vue 3 and when would you use them?",
              "topic": "Advanced",
              "difficulty": "Intermediate",
              "choices": [
                "Open-ended question - no multiple choice",
                "This is a conceptual question",
                "Answer requires explanation",
                "Multiple approaches possible"
              ],
              "correctIndex": 0,
              "explanation": "Teleports allow rendering component templates in different parts of the DOM tree, outside the component hierarchy. Use for modals, tooltips, or notifications that need to escape parent containers.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Advanced",
                "intermediate",
                "vue"
              ],
              "questionType": "open-ended",
              "estimatedTime": 180,
              "legacy": {
                "originalId": 14,
                "originalType": "open-ended",
                "migrated": "2025-10-01T06:41:13.489Z"
              }
            },
            {
              "id": "vue-advanced-q15",
              "question": "How do you create a custom directive in Vue 3?",
              "topic": "Directives",
              "difficulty": "Beginner",
              "choices": [
                "Using app.directive() method",
                "Using Vue.directive()",
                "Using @directive decorator",
                "Using defineDirective()"
              ],
              "correctIndex": 0,
              "explanation": "In Vue 3, custom directives are created using app.directive(name, definition) where definition is an object with lifecycle hooks.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Directives",
                "beginner",
                "vue"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 15,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.489Z"
              }
            },
            {
              "id": "vue-advanced-q16",
              "question": "What is the main benefit of using the Composition API over the Options API?",
              "topic": "Composition API",
              "difficulty": "Intermediate",
              "choices": [
                "Better logic reuse and TypeScript support",
                "Faster component rendering",
                "Smaller bundle size",
                "Better backward compatibility"
              ],
              "correctIndex": 0,
              "explanation": "The Composition API provides better logic reuse through composables, improved TypeScript support with better type inference, and allows for more flexible code organization compared to the Options API.",
              "industryContext": "The Composition API is particularly valuable in large-scale applications where code reuse and maintainability are critical.",
              "tags": [
                "Composition API",
                "Architecture",
                "TypeScript"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90
            },
            {
              "id": "vue-advanced-q17",
              "question": "How do you implement lazy loading for Vue components?",
              "topic": "Performance",
              "difficulty": "Intermediate",
              "choices": [
                "Using defineAsyncComponent() or dynamic imports in router",
                "Using v-lazy directive",
                "Using Vue.lazy() method",
                "Using the async attribute in component tags"
              ],
              "correctIndex": 0,
              "explanation": "Lazy loading in Vue can be implemented using defineAsyncComponent() for individual components or dynamic imports (() => import('./Component.vue')) in Vue Router for route-level code splitting.",
              "industryContext": "Lazy loading is essential for improving initial page load times and optimizing the user experience in large applications.",
              "tags": [
                "Performance",
                "Code Splitting",
                "Optimization"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90
            },
            {
              "id": "vue-advanced-q18",
              "question": "What is the purpose of the key attribute in Vue lists and why is it important?",
              "topic": "Rendering",
              "difficulty": "Intermediate",
              "choices": [
                "It helps Vue track changes and optimize re-rendering",
                "It's required for v-for syntax to work",
                "It prevents memory leaks",
                "It enables two-way data binding"
              ],
              "correctIndex": 0,
              "explanation": "The key attribute helps Vue's virtual DOM algorithm track individual list items when the list changes, enabling efficient updates and preventing rendering issues. Without proper keys, Vue might reuse elements incorrectly leading to state bugs.",
              "industryContext": "Proper key usage is crucial for maintaining component state and avoiding subtle bugs in dynamic lists, especially important in data-driven applications.",
              "tags": [
                "Rendering",
                "Virtual DOM",
                "Performance"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90
            }
          ],
          "issues": []
        },
        "meetsThresholds": true,
        "issues": []
      },
      "testing-fundamentals": {
        "slug": "testing-fundamentals",
        "title": "Software Testing Fundamentals",
        "tier": "quality",
        "track": "Testing",
        "difficulty": "Intermediate",
        "thresholds": {
          "requiredLessons": 14,
          "requiredQuestions": 18
        },
        "lessons": {
          "exists": true,
          "count": 14,
          "lessons": [
            {
              "id": "testing-fundamentals-lesson-1",
              "moduleSlug": "testing-fundamentals",
              "title": "Testing Pyramid and Test Strategies",
              "order": 1,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Testing Fundamentals.\n\nLearn about the testing pyramid and how to develop a comprehensive testing strategy that balances different types of tests for optimal coverage and performance.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "// Unit test example with Jest\nfunction calculateTotal(items, taxRate = 0.1) {\n  const subtotal = items.reduce((sum, item) => sum + item.price * item.quantity, 0);\n  return subtotal * (1 + taxRate);\n}\n\ndescribe('calculateTotal', () => {\n  test('calculates total correctly with default tax', () => {\n    const items = [\n      { price: 10, quantity: 2 },  // $20\n      { price: 15, quantity: 1 }   // $15\n    ];  // Subtotal: $35, Tax: $3.50, Total: $38.50\n    \n    expect(calculateTotal(items)).toBeCloseTo(38.5);\n  });\n\n  test('calculates total with custom tax rate', () => {\n    const items = [{ price: 100, quantity: 1 }];\n    expect(calculateTotal(items, 0.05)).toBeCloseTo(105);\n  });\n\n  test('handles empty items array', () => {\n    expect(calculateTotal([])).toBeCloseTo(0);\n  });\n});\n\n// Integration test example with Supertest\nconst request = require('supertest');\nconst app = require('../app');\n\ndescribe('API Integration Tests', () => {\n  describe('GET /api/users', () => {\n    test('responds with JSON array of users', async () => {\n      const response = await request(app)\n        .get('/api/users')\n        .expect(200)\n        .expect('Content-Type', /json/);\n        \n      expect(response.body).toBeInstanceOf(Array);\n      expect(response.body[0]).toHaveProperty('id');\n      expect(response.body[0]).toHaveProperty('name');\n    });\n  });\n  \n  describe('POST /api/users', () => {\n    test('creates a new user with valid data', async () => {\n      const newUser = {\n        name: 'John Doe',\n        email: 'john@example.com'\n      };\n      \n      const response = await request(app)\n        .post('/api/users')\n        .send(newUser)\n        .expect(201)\n        .expect('Content-Type', /json/);\n        \n      expect(response.body).toMatchObject({\n        id: expect.any(Number),\n        name: 'John Doe',\n        email: 'john@example.com'\n      });\n    });\n  });\n});",
                "explanation": "This example produces: Comprehensive unit tests covering normal cases, edge cases, and boundary conditions, along with integration tests for API endpoints\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Testing Pyramid and Test Strategies",
                  "description": "Apply the concepts from this lesson on Testing Fundamentals",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Advanced",
              "tags": [
                "Testing Fundamentals",
                "testing"
              ],
              "legacy": {
                "originalId": 1,
                "originalTopic": "Testing Fundamentals",
                "migrated": "2025-10-01T06:41:13.489Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.489Z",
              "version": "1.0.0"
            },
            {
              "id": "testing-fundamentals-lesson-2",
              "moduleSlug": "testing-fundamentals",
              "title": "Test Structure, Mocking, and Best Practices",
              "order": 2,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Unit Testing.\n\nLearn how to structure tests using the Arrange-Act-Assert pattern, use mocks effectively, and follow best practices for maintainable test code.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "// Arrange-Act-Assert pattern with proper test structure\nclass ShoppingCart {\n  constructor() {\n    this.items = [];\n  }\n  \n  addItem(item) {\n    this.items.push(item);\n  }\n  \n  calculateTotal() {\n    return this.items.reduce((total, item) => total + (item.price * item.quantity), 0);\n  }\n  \n  getItemCount() {\n    return this.items.reduce((count, item) => count + item.quantity, 0);\n  }\n  \n  clear() {\n    this.items = [];\n  }\n}\n\ndescribe('ShoppingCart', () => {\n  let cart;\n  \n  beforeEach(() => {\n    // Arrange - Set up fresh state for each test\n    cart = new ShoppingCart();\n  });\n  \n  afterEach(() => {\n    // Clean up after each test if needed\n    cart.clear();\n  });\n  \n  test('calculates total correctly with multiple items', () => {\n    // Arrange\n    cart.addItem({ name: 'Apple', price: 1.5, quantity: 3 });\n    cart.addItem({ name: 'Banana', price: 0.75, quantity: 2 });\n    \n    // Act\n    const total = cart.calculateTotal();\n    \n    // Assert\n    expect(total).toBeCloseTo(6.0); // (1.5 * 3) + (0.75 * 2) = 4.5 + 1.5 = 6.0\n  });\n  \n  test('returns correct item count', () => {\n    // Arrange\n    cart.addItem({ name: 'Book', price: 20, quantity: 1 });\n    cart.addItem({ name: 'Pen', price: 2, quantity: 5 });\n    \n    // Act\n    const count = cart.getItemCount();\n    \n    // Assert\n    expect(count).toBe(6); // 1 + 5 = 6\n  });\n  \n  test('starts with zero items', () => {\n    // Act & Assert\n    expect(cart.getItemCount()).toBe(0);\n    expect(cart.calculateTotal()).toBe(0);\n  });\n});\n\n// Using mocks to isolate units of code\nconst database = require('../database');\nconst emailService = require('../emailService');\nconst userService = require('../userService');\n\n// Mock external dependencies\njest.mock('../database');\njest.mock('../emailService');\n\ndescribe('User service', () => {\n  beforeEach(() => {\n    // Clear all mocks before each test\n    jest.clearAllMocks();\n  });\n  \n  test('sends welcome email after user creation', async () => {\n    // Arrange\n    const userData = { email: 'test@example.com', name: 'Test User' };\n    const mockUser = { id: 1, ...userData };\n    \n    // Mock database save operation\n    database.saveUser.mockResolvedValue(mockUser);\n    \n    // Act\n    const user = await userService.createUser(userData);\n    \n    // Assert\n    expect(database.saveUser).toHaveBeenCalledWith(userData);\n    expect(emailService.sendWelcomeEmail).toHaveBeenCalledWith(mockUser);\n    expect(user).toEqual(mockUser);\n  });\n  \n  test('handles database errors gracefully', async () => {\n    // Arrange\n    const userData = { email: 'test@example.com', name: 'Test User' };\n    const dbError = new Error('Database connection failed');\n    \n    database.saveUser.mockRejectedValue(dbError);\n    \n    // Act & Assert\n    await expect(userService.createUser(userData)).rejects.toThrow('Database connection failed');\n    expect(emailService.sendWelcomeEmail).not.toHaveBeenCalled();\n  });\n});",
                "explanation": "This example produces: Well-structured tests with clear separation of concerns, proper use of beforeEach/afterEach, and effective mocking strategies\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Test Structure, Mocking, and Best Practices",
                  "description": "Apply the concepts from this lesson on Unit Testing",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Unit Testing",
                "testing"
              ],
              "legacy": {
                "originalId": 2,
                "originalTopic": "Unit Testing",
                "migrated": "2025-10-01T06:41:13.489Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.489Z",
              "version": "1.0.0"
            },
            {
              "id": "testing-fundamentals-lesson-3",
              "moduleSlug": "testing-fundamentals",
              "title": "Advanced Mocking and Testing Asynchronous Code",
              "order": 3,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Unit Testing.\n\nLearn advanced mocking techniques and how to effectively test asynchronous code, promises, and complex interactions.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "// Testing asynchronous code with async/await\nconst apiClient = require('../apiClient');\n\njest.mock('../apiClient');\n\ndescribe('API Service', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n  \n  test('fetches user data successfully', async () => {\n    // Arrange\n    const userId = 123;\n    const mockUser = { id: 123, name: 'John Doe', email: 'john@example.com' };\n    apiClient.getUser.mockResolvedValue(mockUser);\n    \n    // Act\n    const user = await apiClient.getUser(userId);\n    \n    // Assert\n    expect(apiClient.getUser).toHaveBeenCalledWith(userId);\n    expect(user).toEqual(mockUser);\n  });\n  \n  test('handles API errors gracefully', async () => {\n    // Arrange\n    const userId = 123;\n    const apiError = new Error('User not found');\n    apiClient.getUser.mockRejectedValue(apiError);\n    \n    // Act & Assert\n    await expect(apiClient.getUser(userId)).rejects.toThrow('User not found');\n  });\n  \n  test('retries failed requests', async () => {\n    // Arrange\n    const userId = 123;\n    const networkError = new Error('Network error');\n    const mockUser = { id: 123, name: 'John Doe' };\n    \n    // First call fails, second succeeds\n    apiClient.getUser\n      .mockRejectedValueOnce(networkError)\n      .mockResolvedValueOnce(mockUser);\n    \n    // Act\n    const user = await apiClient.getUser(userId);\n    \n    // Assert\n    expect(apiClient.getUser).toHaveBeenCalledTimes(2);\n    expect(user).toEqual(mockUser);\n  });\n});\n\n// Mocking modules with complex behavior\nconst fs = require('fs');\nconst fileProcessor = require('../fileProcessor');\n\njest.mock('fs');\n\ndescribe('File Processor', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n  \n  test('processes file successfully', async () => {\n    // Arrange\n    const filePath = '/path/to/file.txt';\n    const fileContent = 'Hello, World!';\n    const processedContent = 'HELLO, WORLD!';\n    \n    // Mock fs.readFile to return specific content\n    fs.readFile.mockImplementation((path, encoding, callback) => {\n      callback(null, fileContent);\n    });\n    \n    // Act\n    const result = await fileProcessor.processFile(filePath);\n    \n    // Assert\n    expect(fs.readFile).toHaveBeenCalledWith(\n      filePath, \n      'utf8', \n      expect.any(Function)\n    );\n    expect(result).toBe(processedContent);\n  });\n  \n  test('handles file read errors', async () => {\n    // Arrange\n    const filePath = '/path/to/nonexistent.txt';\n    const fileError = new Error('ENOENT: no such file or directory');\n    \n    fs.readFile.mockImplementation((path, encoding, callback) => {\n      callback(fileError, null);\n    });\n    \n    // Act & Assert\n    await expect(fileProcessor.processFile(filePath)).rejects.toThrow('File processing failed');\n  });\n});\n\n// Testing time-dependent code\njest.useFakeTimers();\n\nfunction delayedGreeting(name, delay) {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve(`Hello, ${name}!`);\n    }, delay);\n  });\n}\n\ntest('resolves after specified delay', async () => {\n  // Arrange\n  const name = 'John';\n  const delay = 5000;\n  \n  // Act\n  const greetingPromise = delayedGreeting(name, delay);\n  \n  // Fast-forward until all timers are executed\n  jest.advanceTimersByTime(delay);\n  \n  // Assert\n  await expect(greetingPromise).resolves.toBe('Hello, John!');\n});",
                "explanation": "This example produces: Advanced testing techniques for asynchronous code, complex mocking scenarios, and time-dependent functionality\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Advanced Mocking and Testing Asynchronous Code",
                  "description": "Apply the concepts from this lesson on Unit Testing",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Advanced",
              "tags": [
                "Unit Testing",
                "testing"
              ],
              "legacy": {
                "originalId": 3,
                "originalTopic": "Unit Testing",
                "migrated": "2025-10-01T06:41:13.489Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.489Z",
              "version": "1.0.0"
            },
            {
              "id": "testing-fundamentals-lesson-4",
              "moduleSlug": "testing-fundamentals",
              "title": "API Testing and Database Integration Tests",
              "order": 4,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Integration Testing.\n\nLearn how to write comprehensive integration tests for APIs and database interactions, including setup and teardown strategies.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "// Testing REST API endpoints with different scenarios\nconst request = require('supertest');\nconst app = require('../app');\nconst db = require('../database');\n\n// Setup and teardown for integration tests\ndescribe('User API Integration Tests', () => {\n  beforeAll(async () => {\n    // Setup database connection\n    await db.connect();\n  });\n  \n  afterAll(async () => {\n    // Close database connection\n    await db.close();\n  });\n  \n  beforeEach(async () => {\n    // Clear test data before each test\n    await db.clearUsers();\n  });\n  \n  describe('POST /api/users', () => {\n    test('creates a new user with valid data', async () => {\n      const userData = {\n        name: 'John Doe',\n        email: 'john@example.com',\n        password: 'password123'\n      };\n      \n      const response = await request(app)\n        .post('/api/users')\n        .send(userData)\n        .expect(201)\n        .expect('Content-Type', /json/);\n        \n      expect(response.body).toMatchObject({\n        id: expect.any(Number),\n        name: userData.name,\n        email: userData.email\n      });\n      \n      // Password should not be returned\n      expect(response.body).not.toHaveProperty('password');\n      \n      // Verify user was actually saved to database\n      const savedUser = await db.findUserById(response.body.id);\n      expect(savedUser).toMatchObject({\n        name: userData.name,\n        email: userData.email\n      });\n    });\n    \n    test('returns 400 for invalid email', async () => {\n      const invalidData = {\n        name: 'John Doe',\n        email: 'invalid-email',\n        password: 'password123'\n      };\n      \n      const response = await request(app)\n        .post('/api/users')\n        .send(invalidData)\n        .expect(400)\n        .expect('Content-Type', /json/);\n        \n      expect(response.body).toHaveProperty('error');\n      \n      // Verify no user was created\n      const users = await db.findAllUsers();\n      expect(users).toHaveLength(0);\n    });\n    \n    test('returns 409 for duplicate email', async () => {\n      // First, create a user\n      await db.createUser({\n        name: 'Existing User',\n        email: 'duplicate@example.com',\n        password: 'password123'\n      });\n      \n      // Try to create another user with same email\n      const userData = {\n        name: 'New User',\n        email: 'duplicate@example.com',\n        password: 'password456'\n      };\n      \n      const response = await request(app)\n        .post('/api/users')\n        .send(userData)\n        .expect(409)\n        .expect('Content-Type', /json/);\n        \n      expect(response.body).toHaveProperty('error', 'Email already exists');\n    });\n  });\n  \n  describe('GET /api/users/:id', () => {\n    test('returns user by ID', async () => {\n      // First, create a user\n      const user = await db.createUser({\n        name: 'Test User',\n        email: 'test@example.com',\n        password: 'password123'\n      });\n      \n      const response = await request(app)\n        .get(`/api/users/${user.id}`)\n        .expect(200)\n        .expect('Content-Type', /json/);\n        \n      expect(response.body).toMatchObject({\n        id: user.id,\n        name: user.name,\n        email: user.email\n      });\n    });\n    \n    test('returns 404 for non-existent user', async () => {\n      await request(app)\n        .get('/api/users/99999')\n        .expect(404);\n    });\n  });\n});",
                "explanation": "This example produces: Comprehensive API integration tests covering success cases, validation errors, and edge cases with proper database setup and teardown\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: API Testing and Database Integration Tests",
                  "description": "Apply the concepts from this lesson on Integration Testing",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Integration Testing",
                "testing"
              ],
              "legacy": {
                "originalId": 4,
                "originalTopic": "Integration Testing",
                "migrated": "2025-10-01T06:41:13.489Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.489Z",
              "version": "1.0.0"
            },
            {
              "id": "testing-fundamentals-lesson-5",
              "moduleSlug": "testing-fundamentals",
              "title": "Cypress Advanced Patterns and Best Practices",
              "order": 5,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on End-to-End Testing.\n\nLearn advanced Cypress patterns, custom commands, and best practices for robust end-to-end testing of web applications.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "// Cypress E2E test with custom commands and advanced patterns\ndescribe('E-Commerce Application', () => {\n  beforeEach(() => {\n    // Custom command to reset database and seed test data\n    cy.task('seedDatabase');\n    cy.visit('/');\n  });\n  \n  afterEach(() => {\n    // Take screenshot on test failure\n    if (this.currentTest.state === 'failed') {\n      cy.screenshot(`failure-${this.currentTest.title}`);\n    }\n  });\n  \n  it('allows users to complete a purchase flow', () => {\n    // Custom command for login\n    cy.login('user@example.com', 'password123');\n    \n    // Navigate to products page\n    cy.get('[data-cy=nav-products]').click();\n    \n    // Search for a product\n    cy.get('[data-cy=search-input]').type('laptop');\n    cy.get('[data-cy=search-button]').click();\n    \n    // Add product to cart\n    cy.get('[data-cy=product-item]').first().within(() => {\n      cy.get('[data-cy=add-to-cart]').click();\n    });\n    \n    // Go to cart\n    cy.get('[data-cy=cart-link]').click();\n    \n    // Verify cart contents\n    cy.get('[data-cy=cart-items]').should('have.length', 1);\n    cy.get('[data-cy=cart-total]').should('contain', '$999.99');\n    \n    // Proceed to checkout\n    cy.get('[data-cy=checkout-button]').click();\n    \n    // Fill shipping information\n    cy.get('[data-cy=shipping-form]').within(() => {\n      cy.get('[data-cy=first-name]').type('John');\n      cy.get('[data-cy=last-name]').type('Doe');\n      cy.get('[data-cy=address]').type('123 Main St');\n      cy.get('[data-cy=city]').type('New York');\n      cy.get('[data-cy=zip-code]').type('10001');\n      cy.get('[data-cy=submit]').click();\n    });\n    \n    // Confirm order\n    cy.get('[data-cy=order-summary]').should('be.visible');\n    cy.get('[data-cy=confirm-order]').click();\n    \n    // Verify success message\n    cy.get('[data-cy=order-success]').should('contain', 'Order placed successfully');\n    cy.get('[data-cy=order-number]').should('contain', 'ORD-');\n  });\n  \n  it('shows error for invalid coupon code', () => {\n    cy.login('user@example.com', 'password123');\n    \n    // Add item to cart\n    cy.get('[data-cy=nav-products]').click();\n    cy.get('[data-cy=product-item]').first().within(() => {\n      cy.get('[data-cy=add-to-cart]').click();\n    });\n    \n    // Go to cart\n    cy.get('[data-cy=cart-link]').click();\n    \n    // Apply invalid coupon\n    cy.get('[data-cy=coupon-input]').type('INVALID');\n    cy.get('[data-cy=apply-coupon]').click();\n    \n    // Verify error message\n    cy.get('[data-cy=coupon-error]').should('be.visible')\n      .and('contain', 'Invalid coupon code');\n  });\n  \n  it('handles network errors gracefully', () => {\n    // Intercept API calls and simulate network failure\n    cy.intercept('POST', '/api/checkout', {\n      statusCode: 500,\n      body: { error: 'Internal server error' }\n    }).as('checkoutRequest');\n    \n    cy.login('user@example.com', 'password123');\n    \n    // Add item to cart and proceed to checkout\n    cy.get('[data-cy=nav-products]').click();\n    cy.get('[data-cy=product-item]').first().within(() => {\n      cy.get('[data-cy=add-to-cart]').click();\n    });\n    cy.get('[data-cy=cart-link]').click();\n    cy.get('[data-cy=checkout-button]').click();\n    \n    // Fill shipping information\n    cy.get('[data-cy=shipping-form]').within(() => {\n      cy.get('[data-cy=first-name]').type('John');\n      cy.get('[data-cy=last-name]').type('Doe');\n      cy.get('[data-cy=address]').type('123 Main St');\n      cy.get('[data-cy=city]').type('New York');\n      cy.get('[data-cy=zip-code]').type('10001');\n      cy.get('[data-cy=submit]').click();\n    });\n    \n    // Confirm order (will fail due to network error)\n    cy.get('[data-cy=confirm-order]').click();\n    \n    // Verify error handling\n    cy.get('[data-cy=error-message]').should('be.visible')\n      .and('contain', 'Unable to process your order');\n  });\n});\n\n// Custom Cypress commands (in cypress/support/commands.js)\nCypress.Commands.add('login', (email, password) => {\n  cy.visit('/login');\n  cy.get('[data-cy=email]').type(email);\n  cy.get('[data-cy=password]').type(password);\n  cy.get('[data-cy=submit]').click();\n  cy.get('[data-cy=dashboard]').should('be.visible');\n});\n\n// Custom tasks for database operations (in cypress/plugins/index.js)\nmodule.exports = (on, config) => {\n  on('task', {\n    seedDatabase() {\n      // Reset database and insert test data\n      return seedDatabase();\n    },\n    \n    resetDatabase() {\n      // Clear all data\n      return resetDatabase();\n    }\n  });\n};",
                "explanation": "This example produces: Advanced end-to-end tests with custom commands, proper error handling, network interception, and comprehensive user flow testing\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Cypress Advanced Patterns and Best Practices",
                  "description": "Apply the concepts from this lesson on End-to-End Testing",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Advanced",
              "tags": [
                "End-to-End Testing",
                "testing"
              ],
              "legacy": {
                "originalId": 5,
                "originalTopic": "End-to-End Testing",
                "migrated": "2025-10-01T06:41:13.489Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.489Z",
              "version": "1.0.0"
            },
            {
              "id": "testing-fundamentals-lesson-6",
              "moduleSlug": "testing-fundamentals",
              "title": "Load Testing and Performance Metrics",
              "order": 6,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Performance Testing.\n\nLearn how to conduct load testing and measure application performance under various conditions.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "// Performance testing with Jest\nconst { performance } = require('perf_hooks');\n\nfunction measurePerformance(fn, iterations = 1000) {\n  const times = [];\n  \n  for (let i = 0; i < iterations; i++) {\n    const start = performance.now();\n    fn();\n    const end = performance.now();\n    times.push(end - start);\n  }\n  \n  const avg = times.reduce((sum, time) => sum + time, 0) / times.length;\n  const min = Math.min(...times);\n  const max = Math.max(...times);\n  \n  return { avg, min, max };\n}\n\ndescribe('Performance Tests', () => {\n  test('array processing completes within acceptable time', () => {\n    const largeArray = Array.from({ length: 10000 }, (_, i) => i);\n    \n    const stats = measurePerformance(() => {\n      largeArray.filter(n => n % 2 === 0).map(n => n * 2);\n    }, 100);\n    \n    expect(stats.avg).toBeLessThan(5);\n    expect(stats.max).toBeLessThan(20);\n  });\n});",
                "explanation": "This example produces: Performance measurement tools for identifying bottlenecks and ensuring acceptable response times\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Load Testing and Performance Metrics",
                  "description": "Apply the concepts from this lesson on Performance Testing",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Advanced",
              "tags": [
                "Performance Testing",
                "testing"
              ],
              "legacy": {
                "originalId": 6,
                "originalTopic": "Performance Testing",
                "migrated": "2025-10-01T06:41:13.489Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.489Z",
              "version": "1.0.0"
            },
            {
              "id": "testing-fundamentals-lesson-7",
              "moduleSlug": "testing-fundamentals",
              "title": "Test Data Factories and Fixtures",
              "order": 7,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Test Data Management.\n\nLearn how to manage test data effectively using factories, fixtures, and data builders.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "// Test data factory pattern\nclass UserFactory {\n  static create(overrides = {}) {\n    return {\n      id: Math.floor(Math.random() * 10000),\n      name: 'John Doe',\n      email: `user${Date.now()}@example.com`,\n      age: 25,\n      isActive: true,\n      createdAt: new Date(),\n      ...overrides\n    };\n  }\n  \n  static createMany(count, overrides = {}) {\n    return Array.from({ length: count }, (_, index) => \n      this.create({ ...overrides, id: index + 1 })\n    );\n  }\n  \n  static createAdmin(overrides = {}) {\n    return this.create({\n      role: 'admin',\n      permissions: ['read', 'write', 'delete'],\n      ...overrides\n    });\n  }\n}\n\n// Builder pattern for complex objects\nclass OrderBuilder {\n  constructor() {\n    this.order = {\n      id: Math.floor(Math.random() * 10000),\n      status: 'pending',\n      items: [],\n      total: 0\n    };\n  }\n  \n  withItem(name, price, quantity = 1) {\n    const item = { name, price, quantity };\n    this.order.items.push(item);\n    this.order.total += price * quantity;\n    return this;\n  }\n  \n  build() {\n    return { ...this.order };\n  }\n}\n\n// Usage in tests\nconst order = new OrderBuilder()\n  .withItem('Laptop', 999.99)\n  .withItem('Mouse', 29.99, 2)\n  .build();",
                "explanation": "This example produces: Flexible test data creation with factories and builders for maintainable test suites\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Test Data Factories and Fixtures",
                  "description": "Apply the concepts from this lesson on Test Data Management",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Test Data Management",
                "testing"
              ],
              "legacy": {
                "originalId": 7,
                "originalTopic": "Test Data Management",
                "migrated": "2025-10-01T06:41:13.489Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.489Z",
              "version": "1.0.0"
            },
            {
              "id": "testing-fundamentals-lesson-8",
              "moduleSlug": "testing-fundamentals",
              "title": "Visual Regression Testing",
              "order": 8,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Visual Testing.\n\nLearn how to implement visual regression testing to catch UI changes.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "// Visual testing with Puppeteer\nconst puppeteer = require('puppeteer');\nconst pixelmatch = require('pixelmatch');\nconst { PNG } = require('pngjs');\nconst fs = require('fs');\n\nclass VisualTester {\n  async captureScreenshot(url, filename) {\n    const browser = await puppeteer.launch();\n    const page = await browser.newPage();\n    await page.setViewport({ width: 1200, height: 800 });\n    await page.goto(url);\n    await page.screenshot({ path: filename });\n    await browser.close();\n  }\n  \n  async compareScreenshots(baseline, current, diff) {\n    const img1 = PNG.sync.read(fs.readFileSync(baseline));\n    const img2 = PNG.sync.read(fs.readFileSync(current));\n    const { width, height } = img1;\n    const diffImg = new PNG({ width, height });\n    \n    const numDiffPixels = pixelmatch(\n      img1.data, img2.data, diffImg.data, width, height\n    );\n    \n    fs.writeFileSync(diff, PNG.sync.write(diffImg));\n    return (numDiffPixels / (width * height)) * 100;\n  }\n}\n\n// Test usage\ntest('homepage visual regression', async () => {\n  const tester = new VisualTester();\n  await tester.captureScreenshot('http://localhost:3000', 'current.png');\n  \n  if (fs.existsSync('baseline.png')) {\n    const diffPercent = await tester.compareScreenshots(\n      'baseline.png', 'current.png', 'diff.png'\n    );\n    expect(diffPercent).toBeLessThan(2);\n  }\n});",
                "explanation": "This example produces: Visual regression testing with screenshot comparison and diff generation\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Visual Regression Testing",
                  "description": "Apply the concepts from this lesson on Visual Testing",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Visual Testing",
                "testing"
              ],
              "legacy": {
                "originalId": 8,
                "originalTopic": "Visual Testing",
                "migrated": "2025-10-01T06:41:13.489Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.489Z",
              "version": "1.0.0"
            },
            {
              "id": "testing-fundamentals-lesson-9",
              "moduleSlug": "testing-fundamentals",
              "title": "Security Vulnerability Testing",
              "order": 9,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Security Testing.\n\nLearn how to test for common security vulnerabilities.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "// Security testing examples\nconst request = require('supertest');\nconst app = require('../app');\n\ndescribe('Security Tests', () => {\n  test('prevents SQL injection', async () => {\n    const maliciousPayload = {\n      email: \"'; DROP TABLE users; --\",\n      password: \"password\"\n    };\n    \n    const response = await request(app)\n      .post('/api/auth/login')\n      .send(maliciousPayload)\n      .expect(400);\n    \n    expect(response.body.error).toContain('Invalid');\n  });\n  \n  test('sanitizes XSS attempts', async () => {\n    const xssPayload = {\n      name: '<script>alert(\"XSS\")</script>',\n      bio: '<img src=x onerror=alert(\"XSS\")>'\n    };\n    \n    const response = await request(app)\n      .post('/api/users/profile')\n      .set('Authorization', 'Bearer valid-token')\n      .send(xssPayload)\n      .expect(200);\n    \n    expect(response.body.name).not.toContain('<script>');\n    expect(response.body.name).toBe('&lt;script&gt;alert(\"XSS\")&lt;/script&gt;');\n  });\n  \n  test('enforces rate limiting', async () => {\n    const attempts = [];\n    for (let i = 0; i < 6; i++) {\n      attempts.push(\n        request(app)\n          .post('/api/auth/login')\n          .send({ email: 'test@example.com', password: 'wrong' })\n      );\n    }\n    \n    const responses = await Promise.all(attempts);\n    expect(responses[5].status).toBe(429);\n  });\n});",
                "explanation": "This example produces: Security testing covering SQL injection, XSS protection, and rate limiting\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Security Vulnerability Testing",
                  "description": "Apply the concepts from this lesson on Security Testing",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Security Testing",
                "testing"
              ],
              "legacy": {
                "originalId": 9,
                "originalTopic": "Security Testing",
                "migrated": "2025-10-01T06:41:13.489Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.489Z",
              "version": "1.0.0"
            },
            {
              "id": "testing-fundamentals-lesson-10",
              "moduleSlug": "testing-fundamentals",
              "title": "Code Coverage Analysis",
              "order": 10,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Test Coverage.\n\nLearn how to measure and analyze test coverage effectively.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "// Jest coverage configuration\nmodule.exports = {\n  collectCoverage: true,\n  coverageDirectory: 'coverage',\n  coverageReporters: ['text', 'lcov', 'html'],\n  collectCoverageFrom: [\n    'src/**/*.{js,jsx}',\n    '!src/**/*.test.{js,jsx}'\n  ],\n  coverageThreshold: {\n    global: {\n      branches: 80,\n      functions: 80,\n      lines: 80,\n      statements: 80\n    }\n  }\n};\n\n// Example testing all branches\nfunction calculateDiscount(price, customerType, loyaltyYears) {\n  let discount = 0;\n  \n  if (customerType === 'premium') {\n    discount += 0.2;\n  } else if (customerType === 'gold') {\n    discount += 0.15;\n  }\n  \n  if (loyaltyYears >= 5) {\n    discount += 0.05;\n  }\n  \n  return price * (1 - Math.min(discount, 0.3));\n}\n\n// Comprehensive test coverage\ndescribe('calculateDiscount', () => {\n  test('premium customer discount', () => {\n    expect(calculateDiscount(100, 'premium', 0)).toBe(80);\n  });\n  \n  test('gold customer discount', () => {\n    expect(calculateDiscount(100, 'gold', 0)).toBe(85);\n  });\n  \n  test('loyalty bonus', () => {\n    expect(calculateDiscount(100, 'premium', 5)).toBe(75);\n  });\n  \n  test('discount cap', () => {\n    expect(calculateDiscount(100, 'premium', 10)).toBe(70);\n  });\n});",
                "explanation": "This example produces: Code coverage configuration with branch testing and threshold enforcement\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Code Coverage Analysis",
                  "description": "Apply the concepts from this lesson on Test Coverage",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Test Coverage",
                "testing"
              ],
              "legacy": {
                "originalId": 10,
                "originalTopic": "Test Coverage",
                "migrated": "2025-10-01T06:41:13.489Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.489Z",
              "version": "1.0.0"
            },
            {
              "id": "testing-fundamentals-lesson-11",
              "moduleSlug": "testing-fundamentals",
              "title": "API Contract Testing",
              "order": 11,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on Contract Testing.\n\nLearn how to implement contract testing for API compatibility.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "// Consumer contract test with Pact\nconst { Pact } = require('@pact-foundation/pact');\nconst { like, eachLike } = require('@pact-foundation/pact').Matchers;\n\nconst mockProvider = new Pact({\n  consumer: 'UserInterface',\n  provider: 'UserService',\n  port: 1234\n});\n\ndescribe('User Service Contract', () => {\n  beforeAll(() => mockProvider.setup());\n  afterEach(() => mockProvider.verify());\n  afterAll(() => mockProvider.finalize());\n  \n  test('gets users successfully', async () => {\n    await mockProvider\n      .given('users exist')\n      .uponReceiving('a request for users')\n      .withRequest({\n        method: 'GET',\n        path: '/api/users'\n      })\n      .willRespondWith({\n        status: 200,\n        body: eachLike({\n          id: like(1),\n          name: like('John Doe'),\n          email: like('john@example.com')\n        })\n      });\n    \n    const users = await getUsersFromAPI();\n    expect(users).toBeInstanceOf(Array);\n    expect(users[0]).toHaveProperty('id');\n  });\n  \n  test('creates user successfully', async () => {\n    await mockProvider\n      .given('user can be created')\n      .uponReceiving('a request to create user')\n      .withRequest({\n        method: 'POST',\n        path: '/api/users',\n        body: {\n          name: 'New User',\n          email: 'new@example.com'\n        }\n      })\n      .willRespondWith({\n        status: 201,\n        body: {\n          id: like(123),\n          name: 'New User',\n          email: 'new@example.com'\n        }\n      });\n    \n    const user = await createUser({ name: 'New User', email: 'new@example.com' });\n    expect(user.id).toBeDefined();\n  });\n});",
                "explanation": "This example produces: Contract testing ensuring API compatibility between consumer and provider services\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: API Contract Testing",
                  "description": "Apply the concepts from this lesson on Contract Testing",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "Contract Testing",
                "testing"
              ],
              "legacy": {
                "originalId": 11,
                "originalTopic": "Contract Testing",
                "migrated": "2025-10-01T06:41:13.489Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.489Z",
              "version": "1.0.0"
            },
            {
              "id": "testing-fundamentals-lesson-12",
              "moduleSlug": "testing-fundamentals",
              "title": "Continuous Integration Testing Strategies",
              "order": 12,
              "objectives": [
                "Implement practical solutions",
                "Build foundational understanding"
              ],
              "intro": "Welcome to this comprehensive lesson on CI/CD Testing.\n\nLearn how to implement effective testing strategies in CI/CD pipelines.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
              "code": {
                "example": "# GitHub Actions workflow for testing\nname: Test Pipeline\n\non:\n  push:\n    branches: [main, develop]\n  pull_request:\n    branches: [main]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    \n    services:\n      postgres:\n        image: postgres:13\n        env:\n          POSTGRES_PASSWORD: postgres\n        options: >-\n          --health-cmd pg_isready\n          --health-interval 10s\n          --health-timeout 5s\n          --health-retries 5\n    \n    steps:\n    - uses: actions/checkout@v3\n    \n    - name: Setup Node.js\n      uses: actions/setup-node@v3\n      with:\n        node-version: '18'\n        cache: 'npm'\n    \n    - name: Install dependencies\n      run: npm ci\n    \n    - name: Run linting\n      run: npm run lint\n    \n    - name: Run unit tests\n      run: npm run test:unit -- --coverage\n    \n    - name: Run integration tests\n      run: npm run test:integration\n      env:\n        DATABASE_URL: postgres://postgres:postgres@localhost:5432/test\n    \n    - name: Build application\n      run: npm run build\n    \n    - name: Run E2E tests\n      run: npm run test:e2e\n    \n    - name: Upload coverage to Codecov\n      uses: codecov/codecov-action@v3\n      with:\n        file: ./coverage/lcov.info\n    \n    - name: Run security audit\n      run: npm audit --audit-level high\n    \n    - name: Check bundle size\n      run: npm run bundlesize\n\n# Package.json test scripts\n{\n  \"scripts\": {\n    \"test\": \"jest\",\n    \"test:unit\": \"jest --testPathPattern=unit\",\n    \"test:integration\": \"jest --testPathPattern=integration\",\n    \"test:e2e\": \"cypress run\",\n    \"test:watch\": \"jest --watch\",\n    \"test:coverage\": \"jest --coverage\",\n    \"lint\": \"eslint src/\",\n    \"bundlesize\": \"bundlesize\"\n  }\n}\n\n// Test configuration for different environments\nconst config = {\n  development: {\n    testTimeout: 10000,\n    setupFilesAfterEnv: ['<rootDir>/src/setupTests.js']\n  },\n  ci: {\n    testTimeout: 30000,\n    maxWorkers: 2,\n    collectCoverage: true,\n    coverageReporters: ['lcov', 'text-summary']\n  },\n  production: {\n    testTimeout: 60000,\n    bail: 1,\n    verbose: false\n  }\n};\n\nmodule.exports = config[process.env.NODE_ENV] || config.development;",
                "explanation": "This example produces: Complete CI/CD testing pipeline with unit, integration, E2E tests, and quality gates\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following best practices",
                  "solution": "Review documentation and community guidelines",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling",
                  "solution": "Implement proper error boundaries and validation",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice: Continuous Integration Testing Strategies",
                  "description": "Apply the concepts from this lesson on CI/CD Testing",
                  "checkpoints": [
                    "Understand the core concept",
                    "Implement the example code",
                    "Experiment with variations"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 25,
              "difficulty": "Intermediate",
              "tags": [
                "CI/CD Testing",
                "testing"
              ],
              "legacy": {
                "originalId": 12,
                "originalTopic": "CI/CD Testing",
                "migrated": "2025-10-01T06:41:13.489Z"
              },
              "lastUpdated": "2025-10-01T06:41:13.489Z",
              "version": "1.0.0"
            },
            {
              "id": "testing-fundamentals-lesson-13",
              "moduleSlug": "testing-fundamentals",
              "title": "Test-Driven Development (TDD) Practice",
              "order": 13,
              "objectives": [
                "Master the TDD red-green-refactor cycle",
                "Write tests that drive design decisions",
                "Understand when and why to use TDD effectively"
              ],
              "intro": "Test-Driven Development (TDD) is a development methodology where you write tests before writing production code. This lesson explores the TDD cycle and its benefits.\n\nTDD follows a simple three-step cycle: Red (write a failing test), Green (write minimal code to pass), and Refactor (improve the code while keeping tests green). This approach leads to better design, higher test coverage, and more confidence in your code.\n\nYou'll learn when TDD is most effective, common pitfalls to avoid, and how to structure your development workflow around test-first thinking. TDD isn't just about testing - it's a design methodology that leads to cleaner, more maintainable code.\n\nBy practicing TDD, you'll develop a deeper understanding of your requirements and create more focused, purposeful code. The discipline of writing tests first forces you to think about interfaces and behavior before implementation details.\n\nThis lesson includes hands-on exercises where you'll implement features using strict TDD practices, experiencing firsthand how tests can drive good design decisions.",
              "code": {
                "example": "// TDD Example: Building a Calculator with strict Red-Green-Refactor\n\n// STEP 1: RED - Write failing test\ndescribe('Calculator', () => {\n  test('should add two numbers', () => {\n    const calculator = new Calculator();\n    const result = calculator.add(2, 3);\n    expect(result).toBe(5);\n  });\n});\n\n// This test fails because Calculator doesn't exist yet\n\n// STEP 2: GREEN - Minimal code to pass\nclass Calculator {\n  add(a, b) {\n    return 5; // Hard-coded to pass the test\n  }\n}\n\n// STEP 3: RED - Add more specific test\ntest('should add different numbers', () => {\n  const calculator = new Calculator();\n  expect(calculator.add(1, 4)).toBe(5);\n  expect(calculator.add(10, 15)).toBe(25);\n});\n\n// STEP 4: GREEN - Real implementation\nclass Calculator {\n  add(a, b) {\n    return a + b;\n  }\n}\n\n// STEP 5: REFACTOR - Improve the tests\ndescribe('Calculator', () => {\n  let calculator;\n  \n  beforeEach(() => {\n    calculator = new Calculator();\n  });\n  \n  describe('addition', () => {\n    test('adds positive numbers', () => {\n      expect(calculator.add(2, 3)).toBe(5);\n      expect(calculator.add(10, 15)).toBe(25);\n    });\n    \n    test('adds negative numbers', () => {\n      expect(calculator.add(-2, -3)).toBe(-5);\n      expect(calculator.add(-5, 3)).toBe(-2);\n    });\n    \n    test('adds zero', () => {\n      expect(calculator.add(0, 5)).toBe(5);\n      expect(calculator.add(5, 0)).toBe(5);\n    });\n    \n    test('adds decimal numbers', () => {\n      expect(calculator.add(1.5, 2.3)).toBeCloseTo(3.8);\n    });\n  });\n});\n\n// TDD for more complex functionality\ndescribe('User Registration (TDD)', () => {\n  // RED: Start with the simplest failing test\n  test('creates user with valid email and password', () => {\n    const userService = new UserService();\n    const user = userService.register('test@example.com', 'password123');\n    \n    expect(user).toHaveProperty('id');\n    expect(user.email).toBe('test@example.com');\n    expect(user).not.toHaveProperty('password'); // Never expose password\n  });\n  \n  // GREEN: Implement minimal UserService\n  // RED: Add validation tests\n  test('throws error for invalid email', () => {\n    const userService = new UserService();\n    \n    expect(() => {\n      userService.register('invalid-email', 'password123');\n    }).toThrow('Invalid email format');\n  });\n  \n  test('throws error for weak password', () => {\n    const userService = new UserService();\n    \n    expect(() => {\n      userService.register('test@example.com', '123');\n    }).toThrow('Password must be at least 8 characters');\n  });\n});\n\n// Final implementation driven by tests\nclass UserService {\n  constructor() {\n    this.users = [];\n    this.nextId = 1;\n  }\n  \n  register(email, password) {\n    this.validateEmail(email);\n    this.validatePassword(password);\n    \n    const user = {\n      id: this.nextId++,\n      email: email,\n      hashedPassword: this.hashPassword(password)\n    };\n    \n    this.users.push(user);\n    \n    // Return user without password\n    return {\n      id: user.id,\n      email: user.email\n    };\n  }\n  \n  validateEmail(email) {\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    if (!emailRegex.test(email)) {\n      throw new Error('Invalid email format');\n    }\n  }\n  \n  validatePassword(password) {\n    if (password.length < 8) {\n      throw new Error('Password must be at least 8 characters');\n    }\n  }\n  \n  hashPassword(password) {\n    // Simplified hashing (use bcrypt in real apps)\n    return 'hashed_' + password;\n  }\n}",
                "explanation": "This example demonstrates the full TDD cycle: writing failing tests first, implementing minimal code to pass, then refactoring. Notice how tests drive the design and reveal requirements that might be missed otherwise.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Writing too much production code before getting tests to pass",
                  "solution": "Stick to minimal implementation - only write enough code to make the current test pass",
                  "severity": "high"
                },
                {
                  "mistake": "Skipping the refactor step",
                  "solution": "Always refactor after getting tests to pass - this is where code quality improves",
                  "severity": "medium"
                },
                {
                  "mistake": "Writing tests that are too complex initially",
                  "solution": "Start with the simplest possible test and add complexity gradually",
                  "severity": "medium"
                }
              ],
              "exercises": [
                {
                  "title": "TDD Banking System",
                  "description": "Build a simple banking system using strict TDD practices",
                  "checkpoints": [
                    "Create Account class with deposit functionality",
                    "Add withdrawal with overdraft protection",
                    "Implement transfer between accounts",
                    "Add transaction history tracking"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 35,
              "difficulty": "Intermediate",
              "tags": [
                "TDD",
                "Unit Testing",
                "Design"
              ],
              "lastUpdated": "2025-10-01T13:30:00.000Z",
              "version": "1.0.0"
            },
            {
              "id": "testing-fundamentals-lesson-14",
              "moduleSlug": "testing-fundamentals",
              "title": "Testing Best Practices and Code Coverage",
              "order": 14,
              "objectives": [
                "Understand different types of code coverage metrics",
                "Learn when high coverage is valuable and when it's misleading",
                "Master best practices for maintainable test suites"
              ],
              "intro": "Code coverage is a useful metric for understanding how much of your code is exercised by tests, but it's important to understand what it measures and what it doesn't.\n\nThis lesson explores different types of coverage (line, branch, function, statement) and how to interpret coverage reports effectively. You'll learn why 100% coverage isn't always the goal and how to focus on meaningful testing.\n\nWe'll cover best practices for organizing test suites, naming conventions, test data management, and strategies for keeping tests fast and reliable. Good tests are documentation for your code and should make future changes easier, not harder.\n\nYou'll also learn about test smells - patterns that indicate your tests might be too fragile, too coupled to implementation details, or not providing sufficient value. Recognizing these patterns helps you write better tests.\n\nBy the end of this lesson, you'll understand how to balance test quantity with test quality, create tests that provide real confidence in your code, and build test suites that support rather than hinder development velocity.",
              "code": {
                "example": "// Understanding code coverage types\n\n// Example function to test\nfunction processUser(user) {\n  // Line coverage: Are these lines executed?\n  if (!user) {\n    throw new Error('User is required');\n  }\n  \n  if (!user.email) {\n    throw new Error('Email is required');\n  }\n  \n  // Branch coverage: Are both true/false branches tested?\n  if (user.age >= 18) {\n    user.status = 'adult';\n  } else {\n    user.status = 'minor';\n  }\n  \n  // Function coverage: Is this function called?\n  const result = validateAndFormat(user);\n  \n  return result;\n}\n\nfunction validateAndFormat(user) {\n  user.email = user.email.toLowerCase();\n  return user;\n}\n\n// Tests demonstrating different coverage types\ndescribe('processUser - Coverage Examples', () => {\n  test('processes valid adult user', () => {\n    const user = { email: 'TEST@EXAMPLE.COM', age: 25 };\n    const result = processUser(user);\n    \n    expect(result.status).toBe('adult');\n    expect(result.email).toBe('test@example.com');\n  });\n  \n  // This test alone gives:\n  // - Line coverage: ~80% (doesn't hit minor branch)\n  // - Branch coverage: ~50% (only adult branch)\n  // - Function coverage: 100% (both functions called)\n  \n  test('processes valid minor user', () => {\n    const user = { email: 'CHILD@EXAMPLE.COM', age: 16 };\n    const result = processUser(user);\n    \n    expect(result.status).toBe('minor');\n  });\n  \n  // Now we have 100% branch coverage\n  \n  test('throws error for null user', () => {\n    expect(() => processUser(null)).toThrow('User is required');\n  });\n  \n  test('throws error for user without email', () => {\n    expect(() => processUser({ age: 25 })).toThrow('Email is required');\n  });\n  \n  // Now we have 100% line coverage\n});\n\n// Best practices for test organization\ndescribe('User Management Service', () => {\n  let userService;\n  let mockDatabase;\n  \n  beforeEach(() => {\n    // Fresh setup for each test\n    mockDatabase = {\n      save: jest.fn(),\n      findById: jest.fn(),\n      findByEmail: jest.fn()\n    };\n    userService = new UserService(mockDatabase);\n  });\n  \n  describe('user creation', () => {\n    test('creates user with valid data', async () => {\n      // Arrange\n      const userData = createValidUserData();\n      mockDatabase.save.mockResolvedValue({ id: 1, ...userData });\n      \n      // Act\n      const user = await userService.createUser(userData);\n      \n      // Assert\n      expect(user).toMatchObject({\n        id: expect.any(Number),\n        email: userData.email\n      });\n    });\n    \n    // Group related tests together\n    describe('validation errors', () => {\n      test('rejects invalid email format', async () => {\n        const userData = createValidUserData({ email: 'invalid-email' });\n        \n        await expect(userService.createUser(userData))\n          .rejects.toThrow('Invalid email format');\n      });\n      \n      test('rejects duplicate email', async () => {\n        const userData = createValidUserData();\n        mockDatabase.findByEmail.mockResolvedValue({ id: 1 });\n        \n        await expect(userService.createUser(userData))\n          .rejects.toThrow('Email already exists');\n      });\n    });\n  });\n  \n  describe('user retrieval', () => {\n    test('finds user by ID', async () => {\n      const userId = 1;\n      const mockUser = { id: userId, email: 'test@example.com' };\n      mockDatabase.findById.mockResolvedValue(mockUser);\n      \n      const user = await userService.findUser(userId);\n      \n      expect(user).toEqual(mockUser);\n      expect(mockDatabase.findById).toHaveBeenCalledWith(userId);\n    });\n  });\n});\n\n// Helper functions for test data\nfunction createValidUserData(overrides = {}) {\n  return {\n    email: 'test@example.com',\n    name: 'Test User',\n    age: 25,\n    ...overrides\n  };\n}\n\n// Example of coverage report interpretation\n/*\nCoverage Report:\n\n File              % Stmts   % Branch   % Funcs    % Lines   \n\n userService.js     95.83      87.5       100        95.83   \n validator.js       100        100        100        100     \n database.js        75         66.67      80         75      \n\n\nAnalysis:\n- userService.js: Good coverage but missing some edge cases (87.5% branch)\n- validator.js: Perfect coverage (but check if tests are meaningful)\n- database.js: Low coverage suggests untested error paths\n*/",
                "explanation": "This example shows how different types of coverage work, best practices for test organization, and how to interpret coverage reports to identify gaps in testing.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Focusing only on coverage percentage without considering test quality",
                  "solution": "Aim for meaningful tests that verify behavior, not just code execution",
                  "severity": "high"
                },
                {
                  "mistake": "Writing tests that are too tightly coupled to implementation details",
                  "solution": "Test public interfaces and behaviors, not internal implementation",
                  "severity": "high"
                },
                {
                  "mistake": "Ignoring slow or flaky tests",
                  "solution": "Fix or remove tests that don't provide reliable feedback",
                  "severity": "medium"
                }
              ],
              "exercises": [
                {
                  "title": "Test Suite Analysis",
                  "description": "Analyze and improve an existing test suite's coverage and quality",
                  "checkpoints": [
                    "Generate coverage report for existing code",
                    "Identify untested branches and edge cases",
                    "Add meaningful tests to improve coverage",
                    "Refactor tests for better maintainability"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Intermediate",
              "tags": [
                "Code Coverage",
                "Best Practices",
                "Test Quality"
              ],
              "lastUpdated": "2025-10-01T13:30:00.000Z",
              "version": "1.0.0"
            }
          ],
          "issues": []
        },
        "quiz": {
          "exists": true,
          "count": 18,
          "questions": [
            {
              "id": "testing-fundamentals-q1",
              "question": "What is the purpose of the testing pyramid?",
              "topic": "Testing Fundamentals",
              "difficulty": "Beginner",
              "choices": [
                "To guide the distribution of different types of tests in a project",
                "To measure the performance of test execution",
                "To organize test files in a directory structure",
                "To prioritize bug fixes in software development"
              ],
              "correctIndex": 0,
              "explanation": "The testing pyramid is a conceptual model that guides teams on how to distribute different types of tests. It suggests having many unit tests (fast and cheap), fewer integration tests, and even fewer end-to-end tests (slow and expensive). This distribution optimizes for fast feedback and cost-effectiveness.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Testing Fundamentals",
                "beginner",
                "testing"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 1,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.489Z"
              }
            },
            {
              "id": "testing-fundamentals-q2",
              "question": "Which type of test typically runs the fastest?",
              "topic": "Testing Fundamentals",
              "difficulty": "Intermediate",
              "choices": [
                "Unit tests",
                "Integration tests",
                "End-to-end tests",
                "Manual tests"
              ],
              "correctIndex": 0,
              "explanation": "Unit tests typically run the fastest because they test small units of code in isolation without external dependencies like databases or network calls. They're executed in memory and can run in milliseconds, making them ideal for continuous integration pipelines.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Testing Fundamentals",
                "intermediate",
                "testing"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 2,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.489Z"
              }
            },
            {
              "id": "testing-fundamentals-q3",
              "question": "What is the difference between a mock and a stub in testing? When would you use each?",
              "topic": "Unit Testing",
              "difficulty": "Beginner",
              "choices": [
                "Open-ended question - no multiple choice",
                "This is a conceptual question",
                "Answer requires explanation",
                "Multiple approaches possible"
              ],
              "correctIndex": 0,
              "explanation": "A stub provides canned answers to calls made during the test, usually not responding at all to anything outside what's programmed in for the test. A mock is a stub with added behavior verification - it knows what methods should be called and with what arguments, and can verify this during the test. Use stubs when you need to control indirect inputs, and mocks when you need to verify interactions between objects.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Unit Testing",
                "beginner",
                "testing"
              ],
              "questionType": "open-ended",
              "estimatedTime": 180,
              "legacy": {
                "originalId": 3,
                "originalType": "open-ended",
                "migrated": "2025-10-01T06:41:13.489Z"
              }
            },
            {
              "id": "testing-fundamentals-q4",
              "question": "What is the main focus of integration testing?",
              "topic": "Integration Testing",
              "difficulty": "Beginner",
              "choices": [
                "Testing interactions between different modules or services",
                "Testing individual functions in isolation",
                "Testing the user interface",
                "Testing database performance"
              ],
              "correctIndex": 0,
              "explanation": "Integration testing focuses on verifying the interactions between different modules, services, or components to ensure they work together correctly. This includes testing database connections, API integrations, and communication between different layers of an application.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Integration Testing",
                "beginner",
                "testing"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 4,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.489Z"
              }
            },
            {
              "id": "testing-fundamentals-q5",
              "question": "What is a key advantage of end-to-end testing?",
              "topic": "End-to-End Testing",
              "difficulty": "Beginner",
              "choices": [
                "It tests the entire system from the user's perspective",
                "It runs faster than unit tests",
                "It's easier to maintain than other test types",
                "It provides detailed code coverage reports"
              ],
              "correctIndex": 0,
              "explanation": "End-to-end testing validates the entire system workflow from the user's perspective, ensuring that all integrated components work together as expected in a production-like environment. This helps catch issues that might not be apparent in unit or integration tests.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "End-to-End Testing",
                "beginner",
                "testing"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 5,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.489Z"
              }
            },
            {
              "id": "testing-fundamentals-q6",
              "question": "What is the purpose of the Arrange-Act-Assert pattern in testing?",
              "topic": "Test Patterns",
              "difficulty": "Beginner",
              "choices": [
                "To structure tests in a clear, readable format",
                "To make tests run faster",
                "To reduce the number of test cases needed",
                "To eliminate the need for test documentation"
              ],
              "correctIndex": 0,
              "explanation": "The Arrange-Act-Assert (AAA) pattern structures tests into three clear sections: Arrange (set up preconditions and inputs), Act (execute the code under test), and Assert (verify the outcomes). This pattern makes tests more readable, maintainable, and easier to debug.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Test Patterns",
                "beginner",
                "testing"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 6,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.489Z"
              }
            },
            {
              "id": "testing-fundamentals-q7",
              "question": "What is test isolation and why is it important? How do you achieve it?",
              "topic": "Mocking",
              "difficulty": "Beginner",
              "choices": [
                "Open-ended question - no multiple choice",
                "This is a conceptual question",
                "Answer requires explanation",
                "Multiple approaches possible"
              ],
              "correctIndex": 0,
              "explanation": "Test isolation means each test can run independently without being affected by other tests. It's important because it ensures tests are reliable, repeatable, and can be run in any order. You achieve it by using fresh test data for each test, mocking external dependencies, avoiding shared state between tests, and using setup/teardown methods to prepare and clean up the test environment.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Mocking",
                "beginner",
                "testing"
              ],
              "questionType": "open-ended",
              "estimatedTime": 180,
              "legacy": {
                "originalId": 7,
                "originalType": "open-ended",
                "migrated": "2025-10-01T06:41:13.489Z"
              }
            },
            {
              "id": "testing-fundamentals-q8",
              "question": "What does code coverage measure and what are its limitations?",
              "topic": "Code Coverage",
              "difficulty": "Intermediate",
              "choices": [
                "The percentage of code executed by tests, but doesn't measure test quality",
                "The number of bugs found in the code",
                "The speed of test execution",
                "The complexity of the code"
              ],
              "correctIndex": 0,
              "explanation": "Code coverage measures the percentage of code executed by tests, including lines, branches, and functions. However, it doesn't measure test quality or correctness - 100% coverage doesn't guarantee bug-free code. Tests could execute all code paths but still have incorrect assertions. It's a useful metric for identifying untested code but shouldn't be the sole measure of test effectiveness.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Code Coverage",
                "intermediate",
                "testing"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 8,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.489Z"
              }
            },
            {
              "id": "testing-fundamentals-q9",
              "question": "What is the testing pyramid?",
              "topic": "Test Types",
              "difficulty": "Beginner",
              "choices": [
                "More unit tests, fewer integration tests, fewest E2E tests",
                "Equal amounts of all test types",
                "More E2E tests than unit tests",
                "Only integration tests"
              ],
              "correctIndex": 0,
              "explanation": "The testing pyramid suggests having many fast, cheap unit tests at the base, fewer integration tests in the middle, and fewest expensive E2E tests at the top.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Test Types",
                "beginner",
                "testing"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 9,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.489Z"
              }
            },
            {
              "id": "testing-fundamentals-q10",
              "question": "What is the difference between mocks, stubs, and spies?",
              "topic": "Mocking",
              "difficulty": "Beginner",
              "choices": [
                "Mocks verify behavior, stubs provide responses, spies record calls",
                "All are the same thing",
                "Mocks are fastest",
                "Stubs are most reliable"
              ],
              "correctIndex": 0,
              "explanation": "Mocks verify that specific methods were called with expected parameters. Stubs provide predetermined responses. Spies record information about function calls for later verification.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Mocking",
                "beginner",
                "testing"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 10,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.489Z"
              }
            },
            {
              "id": "testing-fundamentals-q11",
              "question": "What are the different types of code coverage and what do they measure?",
              "topic": "Coverage",
              "difficulty": "Intermediate",
              "choices": [
                "Open-ended question - no multiple choice",
                "This is a conceptual question",
                "Answer requires explanation",
                "Multiple approaches possible"
              ],
              "correctIndex": 0,
              "explanation": "Line coverage: percentage of code lines executed. Branch coverage: percentage of code branches taken. Function coverage: percentage of functions called. Statement coverage: percentage of statements executed. Condition coverage: percentage of boolean conditions evaluated to both true and false.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Coverage",
                "intermediate",
                "testing"
              ],
              "questionType": "open-ended",
              "estimatedTime": 180,
              "legacy": {
                "originalId": 11,
                "originalType": "open-ended",
                "migrated": "2025-10-01T06:41:13.489Z"
              }
            },
            {
              "id": "testing-fundamentals-q12",
              "question": "What is load testing?",
              "topic": "Performance Testing",
              "difficulty": "Beginner",
              "choices": [
                "Testing system behavior under expected load conditions",
                "Testing code loading speed",
                "Testing database loads",
                "Testing file loading"
              ],
              "correctIndex": 0,
              "explanation": "Load testing evaluates system performance under expected user load to identify bottlenecks and ensure the application can handle normal traffic volumes.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Performance Testing",
                "beginner",
                "testing"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 12,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.489Z"
              }
            },
            {
              "id": "testing-fundamentals-q13",
              "question": "What is the TDD cycle?",
              "topic": "TDD",
              "difficulty": "Beginner",
              "choices": [
                "Red, Green, Refactor",
                "Write, Test, Deploy",
                "Plan, Code, Test",
                "Design, Implement, Verify"
              ],
              "correctIndex": 0,
              "explanation": "TDD follows Red (write failing test), Green (make test pass with minimal code), Refactor (improve code while keeping tests passing) cycle.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "TDD",
                "beginner",
                "testing"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 13,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.489Z"
              }
            },
            {
              "id": "testing-fundamentals-q14",
              "question": "What should you test when testing REST APIs?",
              "topic": "API Testing",
              "difficulty": "Intermediate",
              "choices": [
                "Open-ended question - no multiple choice",
                "This is a conceptual question",
                "Answer requires explanation",
                "Multiple approaches possible"
              ],
              "correctIndex": 0,
              "explanation": "Test: HTTP status codes, response data structure and content, request/response headers, authentication/authorization, input validation, error handling, performance under load, and edge cases like invalid data or missing parameters.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "API Testing",
                "intermediate",
                "testing"
              ],
              "questionType": "open-ended",
              "estimatedTime": 180,
              "legacy": {
                "originalId": 14,
                "originalType": "open-ended",
                "migrated": "2025-10-01T06:41:13.489Z"
              }
            },
            {
              "id": "testing-fundamentals-q15",
              "question": "What makes a good unit test?",
              "topic": "Best Practices",
              "difficulty": "Intermediate",
              "choices": [
                "Fast, isolated, repeatable, and focused on single behavior",
                "Complex and comprehensive",
                "Tests multiple functions at once",
                "Requires manual setup"
              ],
              "correctIndex": 0,
              "explanation": "Good unit tests are FIRST: Fast, Independent/Isolated, Repeatable, Self-validating, and Timely. They should test one specific behavior and be easy to understand and maintain.",
              "industryContext": "These skills are valuable in professional development environments.",
              "tags": [
                "Best Practices",
                "intermediate",
                "testing"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90,
              "legacy": {
                "originalId": 15,
                "originalType": "multiple-choice",
                "migrated": "2025-10-01T06:41:13.489Z"
              }
            },
            {
              "id": "testing-fundamentals-q16",
              "question": "In Test-Driven Development (TDD), what is the correct order of the red-green-refactor cycle?",
              "topic": "TDD",
              "difficulty": "Beginner",
              "choices": [
                "Write failing test, write minimal code to pass, refactor code while keeping tests green",
                "Write code, write test, refactor test",
                "Refactor existing code, write test, make test pass",
                "Write comprehensive tests, implement all features, optimize performance"
              ],
              "correctIndex": 0,
              "explanation": "TDD follows the red-green-refactor cycle: First write a failing test (red), then write the minimal code needed to make it pass (green), finally refactor the code to improve quality while keeping all tests passing. This cycle ensures you always have tests driving your design.",
              "industryContext": "TDD is widely used in agile development environments and helps ensure high test coverage while driving better design decisions.",
              "tags": [
                "TDD",
                "Testing Strategy",
                "beginner"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90
            },
            {
              "id": "testing-fundamentals-q17",
              "question": "What does 100% code coverage guarantee about your software?",
              "topic": "Code Coverage",
              "difficulty": "Intermediate",
              "choices": [
                "That every line of code has been executed, but not that the code is correct",
                "That the software is completely bug-free",
                "That all possible user scenarios have been tested",
                "That the code will perform well under load"
              ],
              "correctIndex": 0,
              "explanation": "100% code coverage only means every line has been executed during testing, not that the code is correct or bug-free. It doesn't guarantee that all edge cases are handled, that assertions are meaningful, or that the code behaves correctly in all scenarios. Coverage is a useful metric but should be combined with other quality measures.",
              "industryContext": "Understanding the limitations of code coverage helps teams focus on writing meaningful tests rather than just achieving high coverage numbers.",
              "tags": [
                "Code Coverage",
                "Testing Quality",
                "intermediate"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 120
            },
            {
              "id": "testing-fundamentals-q18",
              "question": "Which testing approach is most effective for catching integration issues between microservices?",
              "topic": "Integration Testing",
              "difficulty": "Advanced",
              "choices": [
                "Contract testing with tools like Pact or consumer-driven contracts",
                "Unit testing each service in isolation",
                "Manual testing of the entire system",
                "Load testing individual services"
              ],
              "correctIndex": 0,
              "explanation": "Contract testing ensures that services can communicate correctly by testing the contracts (APIs) between them. Tools like Pact allow consumer services to define expectations for provider services, catching integration issues early without requiring complex test environments. This is more effective than unit tests (which test in isolation) or manual testing (which is slow and error-prone).",
              "industryContext": "Contract testing is essential in microservices architectures where services are developed by different teams and deployed independently.",
              "tags": [
                "Integration Testing",
                "Microservices",
                "advanced"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 120
            }
          ],
          "issues": []
        },
        "meetsThresholds": true,
        "issues": []
      },
      "e2e-testing": {
        "slug": "e2e-testing",
        "title": "End-to-End Testing",
        "tier": "quality",
        "track": "Testing",
        "difficulty": "Advanced",
        "thresholds": {
          "requiredLessons": 12,
          "requiredQuestions": 15
        },
        "lessons": {
          "exists": true,
          "count": 12,
          "lessons": [
            {
              "id": "e2e-testing-lesson-1",
              "moduleSlug": "e2e-testing",
              "title": "Introduction to End-to-End Testing",
              "order": 1,
              "objectives": [
                "Understand the purpose and benefits of end-to-end testing",
                "Learn the difference between E2E, integration, and unit testing",
                "Set up Cypress for automated browser testing"
              ],
              "intro": "End-to-end testing validates complete user workflows by testing applications from the user's perspective, ensuring all components work together correctly in real-world scenarios.\n\nIn this lesson, you'll learn why E2E testing is crucial for catching integration issues that unit tests miss. E2E tests simulate real user interactions, testing the entire application stack from frontend to backend and database.\n\nCypress and Playwright are leading tools for modern E2E testing, providing powerful APIs for browser automation, debugging capabilities, and excellent developer experience. These tools make writing reliable, maintainable tests much easier.\n\nYou'll understand the testing pyramid concept, where E2E tests form the top layer providing high-confidence validation of critical user journeys. While E2E tests are slower and more complex than unit tests, they catch issues that other testing levels miss.\n\nBy the end of this lesson, you'll have Cypress set up and understand when to use E2E testing versus other testing strategies. You'll know how to identify the most important user flows to test and create a solid foundation for building comprehensive test suites.",
              "code": {
                "example": "// cypress/e2e/user-login.cy.js\n// Basic Cypress E2E test for user login flow\n\ndescribe('User Authentication', () => {\n  beforeEach(() => {\n    // Visit the application before each test\n    cy.visit('/login');\n  });\n\n  it('should successfully log in with valid credentials', () => {\n    // Enter username\n    cy.get('[data-testid=\"username-input\"]')\n      .type('john.doe@example.com');\n    \n    // Enter password\n    cy.get('[data-testid=\"password-input\"]')\n      .type('securePassword123');\n    \n    // Submit the form\n    cy.get('[data-testid=\"login-button\"]')\n      .click();\n    \n    // Verify successful login\n    cy.url().should('include', '/dashboard');\n    cy.get('[data-testid=\"user-menu\"]')\n      .should('contain', 'Welcome, John');\n    \n    // Check that auth token is stored\n    cy.window()\n      .its('localStorage')\n      .invoke('getItem', 'authToken')\n      .should('exist');\n  });\n\n  it('should show error message for invalid credentials', () => {\n    cy.get('[data-testid=\"username-input\"]')\n      .type('invalid@example.com');\n    \n    cy.get('[data-testid=\"password-input\"]')\n      .type('wrongpassword');\n    \n    cy.get('[data-testid=\"login-button\"]')\n      .click();\n    \n    // Should remain on login page\n    cy.url().should('include', '/login');\n    \n    // Error message should appear\n    cy.get('[data-testid=\"error-message\"]')\n      .should('be.visible')\n      .and('contain', 'Invalid credentials');\n  });\n\n  it('should handle empty form submission', () => {\n    cy.get('[data-testid=\"login-button\"]')\n      .click();\n    \n    // Validation errors should appear\n    cy.get('[data-testid=\"username-error\"]')\n      .should('contain', 'Username is required');\n    \n    cy.get('[data-testid=\"password-error\"]')\n      .should('contain', 'Password is required');\n  });\n});\n\n// cypress.config.js - Basic Cypress configuration\nmodule.exports = {\n  e2e: {\n    baseUrl: 'http://localhost:3000',\n    viewportWidth: 1280,\n    viewportHeight: 720,\n    defaultCommandTimeout: 10000,\n    video: false,\n    screenshotOnRunFailure: true,\n    setupNodeEvents(on, config) {\n      // implement node event listeners here\n    },\n  },\n};",
                "explanation": "This example shows a complete Cypress E2E test for user authentication, including setup, positive and negative test cases, and proper element selection using data-testid attributes for reliable testing.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Testing implementation details instead of user behavior",
                  "solution": "Focus on testing what users actually do, not internal component methods or state",
                  "severity": "high"
                },
                {
                  "mistake": "Creating overly complex E2E tests that are brittle and hard to maintain",
                  "solution": "Keep tests simple, focused on critical paths, and use page object models for reusability",
                  "severity": "medium"
                },
                {
                  "mistake": "Not using proper selectors and relying on CSS classes or text content",
                  "solution": "Use data-testid attributes or role-based selectors for stable, accessible test targeting",
                  "severity": "medium"
                }
              ],
              "exercises": [
                {
                  "title": "Build Your First E2E Test Suite",
                  "description": "Create a comprehensive E2E test suite for a simple todo application covering key user workflows.",
                  "checkpoints": [
                    "Set up Cypress and configure it for your application",
                    "Write tests for adding, editing, and deleting todos",
                    "Test filtering functionality (all, active, completed)",
                    "Implement proper assertions and error handling"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Advanced",
              "tags": [
                "Cypress",
                "Playwright",
                "E2E Testing"
              ],
              "lastUpdated": "2025-10-01T06:42:16.317Z",
              "version": "1.0.0"
            },
            {
              "id": "e2e-testing-lesson-2",
              "moduleSlug": "e2e-testing",
              "title": "Playwright for Cross-Browser Testing",
              "order": 2,
              "objectives": [
                "Set up Playwright for multi-browser E2E testing",
                "Understand Playwright's advantages over other testing tools",
                "Implement advanced testing patterns with Playwright"
              ],
              "intro": "Playwright is a powerful end-to-end testing framework that enables reliable testing across Chromium, Firefox, and WebKit browsers with a single API. It provides superior performance and debugging capabilities compared to traditional tools.\n\nIn this lesson, you'll learn why Playwright has become the preferred choice for modern E2E testing. Its auto-wait functionality eliminates flaky tests, while built-in browser automation provides more reliable and faster test execution.\n\nPlaywright's unique features include network interception, mobile device emulation, and native support for modern web features like service workers and web components. These capabilities make it ideal for testing complex, modern web applications.\n\nYou'll discover Playwright's powerful debugging tools including trace viewer, inspector, and codegen for automatically generating test code. These features significantly speed up test development and troubleshooting processes.\n\nBy mastering Playwright, you'll be able to create robust, cross-browser test suites that run consistently across different environments, catch browser-specific bugs, and provide confidence in your application's compatibility across the web ecosystem.",
              "code": {
                "example": "// tests/e2e/shopping-cart.spec.js\n// Playwright E2E test for e-commerce shopping cart\n\nconst { test, expect } = require('@playwright/test');\n\ntest.describe('Shopping Cart Functionality', () => {\n  test.beforeEach(async ({ page }) => {\n    // Navigate to the products page\n    await page.goto('/products');\n    \n    // Wait for products to load\n    await page.waitForSelector('[data-testid=\"product-grid\"]');\n  });\n\n  test('should add product to cart and proceed to checkout', async ({ page }) => {\n    // Add first product to cart\n    await page.click('[data-testid=\"product-1\"] [data-testid=\"add-to-cart\"]');\n    \n    // Verify cart badge updates\n    await expect(page.locator('[data-testid=\"cart-badge\"]')).toContainText('1');\n    \n    // Open cart\n    await page.click('[data-testid=\"cart-icon\"]');\n    \n    // Verify product in cart\n    await expect(page.locator('[data-testid=\"cart-item\"]')).toBeVisible();\n    await expect(page.locator('[data-testid=\"cart-total\"]')).toContainText('$29.99');\n    \n    // Proceed to checkout\n    await page.click('[data-testid=\"checkout-button\"]');\n    \n    // Verify on checkout page\n    await expect(page).toHaveURL(/.*checkout/);\n    await expect(page.locator('h1')).toContainText('Checkout');\n  });\n\n  test('should handle empty cart scenario', async ({ page }) => {\n    // Go directly to cart\n    await page.click('[data-testid=\"cart-icon\"]');\n    \n    // Verify empty cart message\n    await expect(page.locator('[data-testid=\"empty-cart-message\"]'))\n      .toContainText('Your cart is empty');\n    \n    // Checkout button should be disabled\n    await expect(page.locator('[data-testid=\"checkout-button\"]'))\n      .toBeDisabled();\n  });\n\n  test('should work across different browsers', async ({ browserName, page }) => {\n    console.log(`Running on ${browserName}`);\n    \n    // Test core functionality\n    await page.click('[data-testid=\"product-1\"] [data-testid=\"add-to-cart\"]');\n    await expect(page.locator('[data-testid=\"cart-badge\"]')).toContainText('1');\n    \n    // Browser-specific behavior could be tested here\n    if (browserName === 'webkit') {\n      // Safari-specific tests\n    }\n  });\n\n  test('should handle network failures gracefully', async ({ page }) => {\n    // Intercept and block network request\n    await page.route('**/api/cart', route => {\n      route.abort();\n    });\n    \n    // Try to add to cart\n    await page.click('[data-testid=\"product-1\"] [data-testid=\"add-to-cart\"]');\n    \n    // Verify error handling\n    await expect(page.locator('[data-testid=\"error-toast\"]'))\n      .toContainText('Failed to add item to cart');\n  });\n});\n\n// playwright.config.js\nmodule.exports = {\n  testDir: './tests/e2e',\n  timeout: 30000,\n  fullyParallel: true,\n  forbidOnly: !!process.env.CI,\n  retries: process.env.CI ? 2 : 0,\n  workers: process.env.CI ? 1 : undefined,\n  reporter: 'html',\n  use: {\n    baseURL: 'http://localhost:3000',\n    trace: 'on-first-retry',\n    video: 'retain-on-failure',\n    screenshot: 'only-on-failure',\n  },\n  projects: [\n    {\n      name: 'chromium',\n      use: { ...devices['Desktop Chrome'] },\n    },\n    {\n      name: 'firefox',\n      use: { ...devices['Desktop Firefox'] },\n    },\n    {\n      name: 'webkit',\n      use: { ...devices['Desktop Safari'] },\n    },\n  ],\n};",
                "explanation": "This example demonstrates Playwright's capabilities including cross-browser testing, network interception, auto-waiting, and robust selectors. Notice the configuration for running tests across multiple browsers.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not configuring proper timeouts for different browsers",
                  "solution": "Set appropriate timeouts and retries in playwright.config.js for browser differences",
                  "severity": "medium"
                },
                {
                  "mistake": "Ignoring browser-specific behavior and edge cases",
                  "solution": "Test critical functionality across all target browsers and handle browser-specific issues",
                  "severity": "high"
                },
                {
                  "mistake": "Not using Playwright's auto-waiting features effectively",
                  "solution": "Rely on Playwright's built-in waiting instead of arbitrary delays or manual waits",
                  "severity": "medium"
                }
              ],
              "exercises": [
                {
                  "title": "Cross-Browser E-commerce Testing",
                  "description": "Build a comprehensive Playwright test suite for an e-commerce application that runs across multiple browsers.",
                  "checkpoints": [
                    "Set up Playwright with Chromium, Firefox, and WebKit browsers",
                    "Create tests for product search, cart functionality, and checkout process",
                    "Implement network interception to test offline scenarios",
                    "Add visual regression testing with screenshot comparisons"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Advanced",
              "tags": [
                "Cypress",
                "Playwright",
                "E2E Testing"
              ],
              "lastUpdated": "2025-10-01T06:42:16.317Z",
              "version": "1.0.0"
            },
            {
              "id": "e2e-testing-lesson-3",
              "moduleSlug": "e2e-testing",
              "title": "Automated Testing",
              "order": 3,
              "objectives": [
                "Apply advanced Cypress techniques",
                "Optimize performance and efficiency",
                "Integrate with external systems"
              ],
              "intro": "Welcome to Automated Testing in the End-to-End Testing module. \n\nThis lesson is part of the quality tier, designed for advanced level learners. Throughout this lesson, you'll explore essential concepts and practical applications that form the foundation of modern testing development.\n\nCypress, Playwright, and automated testing strategies This lesson builds upon previous concepts while introducing new techniques that will enhance your understanding and practical skills.\n\nBy the end of this lesson, you'll have hands-on experience with Cypress and Playwright, along with best practices for implementing these technologies in real-world scenarios. The knowledge gained here will prepare you for more advanced topics in subsequent lessons.\n\nKey areas we'll cover include practical implementation techniques, common challenges developers face, and proven solutions that industry professionals use daily. This lesson balances theoretical understanding with practical application, ensuring you can immediately apply what you learn.",
              "code": {
                "example": "// Example Cypress test\n// TODO: Add specific test example for End-to-End Testing\n\ndescribe('End-to-End Testing', () => {\n    it('should demonstrate core concepts', () => {\n        // Test implementation\n        expect(true).toBe(true);\n    });\n});",
                "explanation": "This example demonstrates the key concepts covered in this lesson.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following Cypress best practices",
                  "solution": "Review official documentation and established patterns for Cypress",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling in implementation",
                  "solution": "Always implement proper error handling and validation",
                  "severity": "high"
                },
                {
                  "mistake": "Ignoring performance implications",
                  "solution": "Consider performance impact of your implementation choices",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice Automated Testing",
                  "description": "Apply the concepts learned in this lesson through hands-on practice.",
                  "checkpoints": [
                    "Complete the basic implementation",
                    "Test your solution",
                    "Identify areas for improvement"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Advanced",
              "tags": [
                "Cypress",
                "Playwright",
                "E2E Testing"
              ],
              "lastUpdated": "2025-10-01T06:42:16.317Z",
              "version": "1.0.0"
            },
            {
              "id": "e2e-testing-lesson-4",
              "moduleSlug": "e2e-testing",
              "title": "Performance Testing",
              "order": 4,
              "objectives": [
                "Apply advanced Cypress techniques",
                "Optimize performance and efficiency",
                "Integrate with external systems"
              ],
              "intro": "Welcome to Performance Testing in the End-to-End Testing module. \n\nThis lesson is part of the quality tier, designed for advanced level learners. Throughout this lesson, you'll explore essential concepts and practical applications that form the foundation of modern testing development.\n\nCypress, Playwright, and automated testing strategies This lesson builds upon previous concepts while introducing new techniques that will enhance your understanding and practical skills.\n\nBy the end of this lesson, you'll have hands-on experience with Cypress and Playwright, along with best practices for implementing these technologies in real-world scenarios. The knowledge gained here will prepare you for more advanced topics in subsequent lessons.\n\nKey areas we'll cover include practical implementation techniques, common challenges developers face, and proven solutions that industry professionals use daily. This lesson balances theoretical understanding with practical application, ensuring you can immediately apply what you learn.",
              "code": {
                "example": "// Example Cypress test\n// TODO: Add specific test example for End-to-End Testing\n\ndescribe('End-to-End Testing', () => {\n    it('should demonstrate core concepts', () => {\n        // Test implementation\n        expect(true).toBe(true);\n    });\n});",
                "explanation": "This example demonstrates the key concepts covered in this lesson.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following Cypress best practices",
                  "solution": "Review official documentation and established patterns for Cypress",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling in implementation",
                  "solution": "Always implement proper error handling and validation",
                  "severity": "high"
                },
                {
                  "mistake": "Ignoring performance implications",
                  "solution": "Consider performance impact of your implementation choices",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice Performance Testing",
                  "description": "Apply the concepts learned in this lesson through hands-on practice.",
                  "checkpoints": [
                    "Complete the basic implementation",
                    "Test your solution",
                    "Identify areas for improvement"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Advanced",
              "tags": [
                "Cypress",
                "Playwright",
                "E2E Testing"
              ],
              "lastUpdated": "2025-10-01T06:42:16.317Z",
              "version": "1.0.0"
            },
            {
              "id": "e2e-testing-lesson-5",
              "moduleSlug": "e2e-testing",
              "title": "Security Testing",
              "order": 5,
              "objectives": [
                "Apply advanced Cypress techniques",
                "Optimize performance and efficiency",
                "Integrate with external systems"
              ],
              "intro": "Welcome to Security Testing in the End-to-End Testing module. \n\nThis lesson is part of the quality tier, designed for advanced level learners. Throughout this lesson, you'll explore essential concepts and practical applications that form the foundation of modern testing development.\n\nCypress, Playwright, and automated testing strategies This lesson builds upon previous concepts while introducing new techniques that will enhance your understanding and practical skills.\n\nBy the end of this lesson, you'll have hands-on experience with Cypress and Playwright, along with best practices for implementing these technologies in real-world scenarios. The knowledge gained here will prepare you for more advanced topics in subsequent lessons.\n\nKey areas we'll cover include practical implementation techniques, common challenges developers face, and proven solutions that industry professionals use daily. This lesson balances theoretical understanding with practical application, ensuring you can immediately apply what you learn.",
              "code": {
                "example": "// Example Cypress test\n// TODO: Add specific test example for End-to-End Testing\n\ndescribe('End-to-End Testing', () => {\n    it('should demonstrate core concepts', () => {\n        // Test implementation\n        expect(true).toBe(true);\n    });\n});",
                "explanation": "This example demonstrates the key concepts covered in this lesson.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following Cypress best practices",
                  "solution": "Review official documentation and established patterns for Cypress",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling in implementation",
                  "solution": "Always implement proper error handling and validation",
                  "severity": "high"
                },
                {
                  "mistake": "Ignoring performance implications",
                  "solution": "Consider performance impact of your implementation choices",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice Security Testing",
                  "description": "Apply the concepts learned in this lesson through hands-on practice.",
                  "checkpoints": [
                    "Complete the basic implementation",
                    "Test your solution",
                    "Identify areas for improvement"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Advanced",
              "tags": [
                "Cypress",
                "Playwright",
                "E2E Testing"
              ],
              "lastUpdated": "2025-10-01T06:42:16.317Z",
              "version": "1.0.0"
            },
            {
              "id": "e2e-testing-lesson-6",
              "moduleSlug": "e2e-testing",
              "title": "Code Quality",
              "order": 6,
              "objectives": [
                "Apply advanced Cypress techniques",
                "Optimize performance and efficiency",
                "Integrate with external systems"
              ],
              "intro": "Welcome to Code Quality in the End-to-End Testing module. \n\nThis lesson is part of the quality tier, designed for advanced level learners. Throughout this lesson, you'll explore essential concepts and practical applications that form the foundation of modern testing development.\n\nCypress, Playwright, and automated testing strategies This lesson builds upon previous concepts while introducing new techniques that will enhance your understanding and practical skills.\n\nBy the end of this lesson, you'll have hands-on experience with Cypress and Playwright, along with best practices for implementing these technologies in real-world scenarios. The knowledge gained here will prepare you for more advanced topics in subsequent lessons.\n\nKey areas we'll cover include practical implementation techniques, common challenges developers face, and proven solutions that industry professionals use daily. This lesson balances theoretical understanding with practical application, ensuring you can immediately apply what you learn.",
              "code": {
                "example": "// Example Cypress test\n// TODO: Add specific test example for End-to-End Testing\n\ndescribe('End-to-End Testing', () => {\n    it('should demonstrate core concepts', () => {\n        // Test implementation\n        expect(true).toBe(true);\n    });\n});",
                "explanation": "This example demonstrates the key concepts covered in this lesson.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following Cypress best practices",
                  "solution": "Review official documentation and established patterns for Cypress",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling in implementation",
                  "solution": "Always implement proper error handling and validation",
                  "severity": "high"
                },
                {
                  "mistake": "Ignoring performance implications",
                  "solution": "Consider performance impact of your implementation choices",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice Code Quality",
                  "description": "Apply the concepts learned in this lesson through hands-on practice.",
                  "checkpoints": [
                    "Complete the basic implementation",
                    "Test your solution",
                    "Identify areas for improvement"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Advanced",
              "tags": [
                "Cypress",
                "Playwright",
                "E2E Testing"
              ],
              "lastUpdated": "2025-10-01T06:42:16.317Z",
              "version": "1.0.0"
            },
            {
              "id": "e2e-testing-lesson-7",
              "moduleSlug": "e2e-testing",
              "title": "Review Processes",
              "order": 7,
              "objectives": [
                "Apply advanced Cypress techniques",
                "Optimize performance and efficiency",
                "Integrate with external systems"
              ],
              "intro": "Welcome to Review Processes in the End-to-End Testing module. \n\nThis lesson is part of the quality tier, designed for advanced level learners. Throughout this lesson, you'll explore essential concepts and practical applications that form the foundation of modern testing development.\n\nCypress, Playwright, and automated testing strategies This lesson builds upon previous concepts while introducing new techniques that will enhance your understanding and practical skills.\n\nBy the end of this lesson, you'll have hands-on experience with Cypress and Playwright, along with best practices for implementing these technologies in real-world scenarios. The knowledge gained here will prepare you for more advanced topics in subsequent lessons.\n\nKey areas we'll cover include practical implementation techniques, common challenges developers face, and proven solutions that industry professionals use daily. This lesson balances theoretical understanding with practical application, ensuring you can immediately apply what you learn.",
              "code": {
                "example": "// Example Cypress test\n// TODO: Add specific test example for End-to-End Testing\n\ndescribe('End-to-End Testing', () => {\n    it('should demonstrate core concepts', () => {\n        // Test implementation\n        expect(true).toBe(true);\n    });\n});",
                "explanation": "This example demonstrates the key concepts covered in this lesson.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following Cypress best practices",
                  "solution": "Review official documentation and established patterns for Cypress",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling in implementation",
                  "solution": "Always implement proper error handling and validation",
                  "severity": "high"
                },
                {
                  "mistake": "Ignoring performance implications",
                  "solution": "Consider performance impact of your implementation choices",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice Review Processes",
                  "description": "Apply the concepts learned in this lesson through hands-on practice.",
                  "checkpoints": [
                    "Complete the basic implementation",
                    "Test your solution",
                    "Identify areas for improvement"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Advanced",
              "tags": [
                "Cypress",
                "Playwright",
                "E2E Testing"
              ],
              "lastUpdated": "2025-10-01T06:42:16.317Z",
              "version": "1.0.0"
            },
            {
              "id": "e2e-testing-lesson-8",
              "moduleSlug": "e2e-testing",
              "title": "Continuous Integration",
              "order": 8,
              "objectives": [
                "Apply advanced Cypress techniques",
                "Optimize performance and efficiency",
                "Integrate with external systems"
              ],
              "intro": "Welcome to Continuous Integration in the End-to-End Testing module. \n\nThis lesson is part of the quality tier, designed for advanced level learners. Throughout this lesson, you'll explore essential concepts and practical applications that form the foundation of modern testing development.\n\nCypress, Playwright, and automated testing strategies This lesson builds upon previous concepts while introducing new techniques that will enhance your understanding and practical skills.\n\nBy the end of this lesson, you'll have hands-on experience with Cypress and Playwright, along with best practices for implementing these technologies in real-world scenarios. The knowledge gained here will prepare you for more advanced topics in subsequent lessons.\n\nKey areas we'll cover include practical implementation techniques, common challenges developers face, and proven solutions that industry professionals use daily. This lesson balances theoretical understanding with practical application, ensuring you can immediately apply what you learn.",
              "code": {
                "example": "// Example Cypress test\n// TODO: Add specific test example for End-to-End Testing\n\ndescribe('End-to-End Testing', () => {\n    it('should demonstrate core concepts', () => {\n        // Test implementation\n        expect(true).toBe(true);\n    });\n});",
                "explanation": "This example demonstrates the key concepts covered in this lesson.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following Cypress best practices",
                  "solution": "Review official documentation and established patterns for Cypress",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling in implementation",
                  "solution": "Always implement proper error handling and validation",
                  "severity": "high"
                },
                {
                  "mistake": "Ignoring performance implications",
                  "solution": "Consider performance impact of your implementation choices",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice Continuous Integration",
                  "description": "Apply the concepts learned in this lesson through hands-on practice.",
                  "checkpoints": [
                    "Complete the basic implementation",
                    "Test your solution",
                    "Identify areas for improvement"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Advanced",
              "tags": [
                "Cypress",
                "Playwright",
                "E2E Testing"
              ],
              "lastUpdated": "2025-10-01T06:42:16.317Z",
              "version": "1.0.0"
            },
            {
              "id": "e2e-testing-lesson-9",
              "moduleSlug": "e2e-testing",
              "title": "Monitoring Setup",
              "order": 9,
              "objectives": [
                "Apply advanced Cypress techniques",
                "Optimize performance and efficiency",
                "Integrate with external systems"
              ],
              "intro": "Welcome to Monitoring Setup in the End-to-End Testing module. \n\nThis lesson is part of the quality tier, designed for advanced level learners. Throughout this lesson, you'll explore essential concepts and practical applications that form the foundation of modern testing development.\n\nCypress, Playwright, and automated testing strategies This lesson builds upon previous concepts while introducing new techniques that will enhance your understanding and practical skills.\n\nBy the end of this lesson, you'll have hands-on experience with Cypress and Playwright, along with best practices for implementing these technologies in real-world scenarios. The knowledge gained here will prepare you for more advanced topics in subsequent lessons.\n\nKey areas we'll cover include practical implementation techniques, common challenges developers face, and proven solutions that industry professionals use daily. This lesson balances theoretical understanding with practical application, ensuring you can immediately apply what you learn.",
              "code": {
                "example": "// Example Cypress test\n// TODO: Add specific test example for End-to-End Testing\n\ndescribe('End-to-End Testing', () => {\n    it('should demonstrate core concepts', () => {\n        // Test implementation\n        expect(true).toBe(true);\n    });\n});",
                "explanation": "This example demonstrates the key concepts covered in this lesson.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following Cypress best practices",
                  "solution": "Review official documentation and established patterns for Cypress",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling in implementation",
                  "solution": "Always implement proper error handling and validation",
                  "severity": "high"
                },
                {
                  "mistake": "Ignoring performance implications",
                  "solution": "Consider performance impact of your implementation choices",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice Monitoring Setup",
                  "description": "Apply the concepts learned in this lesson through hands-on practice.",
                  "checkpoints": [
                    "Complete the basic implementation",
                    "Test your solution",
                    "Identify areas for improvement"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Advanced",
              "tags": [
                "Cypress",
                "Playwright",
                "E2E Testing"
              ],
              "lastUpdated": "2025-10-01T06:42:16.317Z",
              "version": "1.0.0"
            },
            {
              "id": "e2e-testing-lesson-10",
              "moduleSlug": "e2e-testing",
              "title": "Debugging Techniques",
              "order": 10,
              "objectives": [
                "Apply advanced Cypress techniques",
                "Optimize performance and efficiency",
                "Integrate with external systems"
              ],
              "intro": "Welcome to Debugging Techniques in the End-to-End Testing module. \n\nThis lesson is part of the quality tier, designed for advanced level learners. Throughout this lesson, you'll explore essential concepts and practical applications that form the foundation of modern testing development.\n\nCypress, Playwright, and automated testing strategies This lesson builds upon previous concepts while introducing new techniques that will enhance your understanding and practical skills.\n\nBy the end of this lesson, you'll have hands-on experience with Cypress and Playwright, along with best practices for implementing these technologies in real-world scenarios. The knowledge gained here will prepare you for more advanced topics in subsequent lessons.\n\nKey areas we'll cover include practical implementation techniques, common challenges developers face, and proven solutions that industry professionals use daily. This lesson balances theoretical understanding with practical application, ensuring you can immediately apply what you learn.",
              "code": {
                "example": "// Example Cypress test\n// TODO: Add specific test example for End-to-End Testing\n\ndescribe('End-to-End Testing', () => {\n    it('should demonstrate core concepts', () => {\n        // Test implementation\n        expect(true).toBe(true);\n    });\n});",
                "explanation": "This example demonstrates the key concepts covered in this lesson.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following Cypress best practices",
                  "solution": "Review official documentation and established patterns for Cypress",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling in implementation",
                  "solution": "Always implement proper error handling and validation",
                  "severity": "high"
                },
                {
                  "mistake": "Ignoring performance implications",
                  "solution": "Consider performance impact of your implementation choices",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice Debugging Techniques",
                  "description": "Apply the concepts learned in this lesson through hands-on practice.",
                  "checkpoints": [
                    "Complete the basic implementation",
                    "Test your solution",
                    "Identify areas for improvement"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Advanced",
              "tags": [
                "Cypress",
                "Playwright",
                "E2E Testing"
              ],
              "lastUpdated": "2025-10-01T06:42:16.317Z",
              "version": "1.0.0"
            },
            {
              "id": "e2e-testing-lesson-11",
              "moduleSlug": "e2e-testing",
              "title": "Optimization Methods",
              "order": 11,
              "objectives": [
                "Apply advanced Cypress techniques",
                "Optimize performance and efficiency",
                "Integrate with external systems"
              ],
              "intro": "Welcome to Optimization Methods in the End-to-End Testing module. \n\nThis lesson is part of the quality tier, designed for advanced level learners. Throughout this lesson, you'll explore essential concepts and practical applications that form the foundation of modern testing development.\n\nCypress, Playwright, and automated testing strategies This lesson builds upon previous concepts while introducing new techniques that will enhance your understanding and practical skills.\n\nBy the end of this lesson, you'll have hands-on experience with Cypress and Playwright, along with best practices for implementing these technologies in real-world scenarios. The knowledge gained here will prepare you for more advanced topics in subsequent lessons.\n\nKey areas we'll cover include practical implementation techniques, common challenges developers face, and proven solutions that industry professionals use daily. This lesson balances theoretical understanding with practical application, ensuring you can immediately apply what you learn.",
              "code": {
                "example": "// Example Cypress test\n// TODO: Add specific test example for End-to-End Testing\n\ndescribe('End-to-End Testing', () => {\n    it('should demonstrate core concepts', () => {\n        // Test implementation\n        expect(true).toBe(true);\n    });\n});",
                "explanation": "This example demonstrates the key concepts covered in this lesson.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following Cypress best practices",
                  "solution": "Review official documentation and established patterns for Cypress",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling in implementation",
                  "solution": "Always implement proper error handling and validation",
                  "severity": "high"
                },
                {
                  "mistake": "Ignoring performance implications",
                  "solution": "Consider performance impact of your implementation choices",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice Optimization Methods",
                  "description": "Apply the concepts learned in this lesson through hands-on practice.",
                  "checkpoints": [
                    "Complete the basic implementation",
                    "Test your solution",
                    "Identify areas for improvement"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Advanced",
              "tags": [
                "Cypress",
                "Playwright",
                "E2E Testing"
              ],
              "lastUpdated": "2025-10-01T06:42:16.317Z",
              "version": "1.0.0"
            },
            {
              "id": "e2e-testing-lesson-12",
              "moduleSlug": "e2e-testing",
              "title": "Quality Standards",
              "order": 12,
              "objectives": [
                "Apply advanced Cypress techniques",
                "Optimize performance and efficiency",
                "Integrate with external systems"
              ],
              "intro": "Welcome to Quality Standards in the End-to-End Testing module. \n\nThis lesson is part of the quality tier, designed for advanced level learners. Throughout this lesson, you'll explore essential concepts and practical applications that form the foundation of modern testing development.\n\nCypress, Playwright, and automated testing strategies This lesson builds upon previous concepts while introducing new techniques that will enhance your understanding and practical skills.\n\nBy the end of this lesson, you'll have hands-on experience with Cypress and Playwright, along with best practices for implementing these technologies in real-world scenarios. The knowledge gained here will prepare you for more advanced topics in subsequent lessons.\n\nKey areas we'll cover include practical implementation techniques, common challenges developers face, and proven solutions that industry professionals use daily. This lesson balances theoretical understanding with practical application, ensuring you can immediately apply what you learn.",
              "code": {
                "example": "// Example Cypress test\n// TODO: Add specific test example for End-to-End Testing\n\ndescribe('End-to-End Testing', () => {\n    it('should demonstrate core concepts', () => {\n        // Test implementation\n        expect(true).toBe(true);\n    });\n});",
                "explanation": "This example demonstrates the key concepts covered in this lesson.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following Cypress best practices",
                  "solution": "Review official documentation and established patterns for Cypress",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling in implementation",
                  "solution": "Always implement proper error handling and validation",
                  "severity": "high"
                },
                {
                  "mistake": "Ignoring performance implications",
                  "solution": "Consider performance impact of your implementation choices",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice Quality Standards",
                  "description": "Apply the concepts learned in this lesson through hands-on practice.",
                  "checkpoints": [
                    "Complete the basic implementation",
                    "Test your solution",
                    "Identify areas for improvement"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Advanced",
              "tags": [
                "Cypress",
                "Playwright",
                "E2E Testing"
              ],
              "lastUpdated": "2025-10-01T06:42:16.317Z",
              "version": "1.0.0"
            }
          ],
          "issues": []
        },
        "quiz": {
          "exists": true,
          "count": 15,
          "questions": [
            {
              "id": "e2e-testing-q1",
              "question": "What is the primary advantage of end-to-end testing over unit testing?",
              "topic": "E2E Testing",
              "difficulty": "Beginner",
              "choices": [
                "Tests complete user workflows from UI to database",
                "Runs faster than unit tests",
                "Easier to write and maintain",
                "Provides better code coverage metrics"
              ],
              "correctIndex": 0,
              "explanation": "E2E testing validates complete user workflows by testing the entire application stack from frontend to backend, catching integration issues that unit tests miss. While E2E tests are slower and more complex, they provide high confidence that features work correctly for users.",
              "industryContext": "E2E tests are crucial for validating critical user journeys in production applications, ensuring all components work together correctly in real-world scenarios.",
              "tags": [
                "quality",
                "beginner"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90
            },
            {
              "id": "e2e-testing-q2",
              "question": "Which Cypress command is used to visit a page and wait for it to load?",
              "topic": "Cypress",
              "difficulty": "Beginner",
              "choices": [
                "cy.visit('/page')",
                "cy.goto('/page')",
                "cy.navigate('/page')",
                "cy.open('/page')"
              ],
              "correctIndex": 0,
              "explanation": "'cy.visit()' is the Cypress command to navigate to a URL. It automatically waits for the page to load and handles many common loading scenarios, making it the standard way to start E2E tests.",
              "industryContext": "Cypress's automatic waiting features eliminate many flaky test issues common in other testing tools, making tests more reliable and maintainable.",
              "tags": [
                "quality",
                "beginner"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90
            },
            {
              "id": "e2e-testing-q3",
              "question": "What is the recommended selector strategy for reliable E2E tests?",
              "topic": "E2E Testing",
              "difficulty": "Intermediate",
              "choices": [
                "Use data-testid attributes specifically for testing",
                "Use CSS class names from styling",
                "Use text content that might change",
                "Use complex CSS selectors with multiple levels"
              ],
              "correctIndex": 0,
              "explanation": "data-testid attributes are the most reliable selectors because they're specifically designed for testing and won't change when styling or content updates. This makes tests more stable and maintainable over time.",
              "industryContext": "Stable selectors are crucial for reducing test maintenance overhead in fast-moving development environments where UI changes frequently.",
              "tags": [
                "quality",
                "intermediate"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90
            },
            {
              "id": "e2e-testing-q4",
              "question": "Which browsers does Playwright support out of the box?",
              "topic": "Playwright",
              "difficulty": "Beginner",
              "choices": [
                "Chromium, Firefox, and WebKit (Safari)",
                "Only Chrome and Firefox",
                "Only Chromium-based browsers",
                "All browsers including Internet Explorer"
              ],
              "correctIndex": 0,
              "explanation": "Playwright supports Chromium, Firefox, and WebKit (Safari) browsers with a single API, enabling comprehensive cross-browser testing to ensure applications work consistently across different browsers.",
              "industryContext": "Cross-browser testing is essential for web applications as users access sites from various browsers, each with different rendering engines and JavaScript implementations.",
              "tags": [
                "quality",
                "beginner"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90
            },
            {
              "id": "e2e-testing-q5",
              "question": "What should you do when an E2E test fails intermittently?",
              "topic": "E2E Testing",
              "difficulty": "Intermediate",
              "choices": [
                "Investigate timing issues and improve wait conditions",
                "Just increase the number of retries",
                "Ignore it if it passes most of the time",
                "Rewrite it as a unit test instead"
              ],
              "correctIndex": 0,
              "explanation": "Intermittent failures often indicate timing issues, race conditions, or inadequate wait conditions. Investigating and fixing the root cause makes tests more reliable than simply adding retries, which mask underlying problems.",
              "industryContext": "Flaky tests reduce confidence in test suites and can hide real bugs. Investing time to make tests reliable pays off in reduced maintenance and increased trust in the test results.",
              "tags": [
                "quality",
                "intermediate"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90
            },
            {
              "id": "e2e-testing-q6",
              "question": "What is the primary purpose of Cypress?",
              "topic": "Cypress",
              "difficulty": "Beginner",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of Cypress concepts. The correct answer demonstrates proper implementation of End-to-End Testing principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding Cypress is crucial for building scalable and maintainable applications.",
              "tags": [
                "quality",
                "beginner"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90
            },
            {
              "id": "e2e-testing-q7",
              "question": "What are the performance considerations when using Cypress?",
              "topic": "Playwright",
              "difficulty": "Intermediate",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of Cypress concepts. The correct answer demonstrates proper implementation of End-to-End Testing principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding Cypress is crucial for building scalable and maintainable applications.",
              "tags": [
                "quality",
                "intermediate"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90
            },
            {
              "id": "e2e-testing-q8",
              "question": "When should you use Cypress in development?",
              "topic": "E2E Testing",
              "difficulty": "Beginner",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of Cypress concepts. The correct answer demonstrates proper implementation of End-to-End Testing principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding Cypress is crucial for building scalable and maintainable applications.",
              "tags": [
                "quality",
                "beginner"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90
            },
            {
              "id": "e2e-testing-q9",
              "question": "What is the primary purpose of Cypress?",
              "topic": "Cypress",
              "difficulty": "Beginner",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of Cypress concepts. The correct answer demonstrates proper implementation of End-to-End Testing principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding Cypress is crucial for building scalable and maintainable applications.",
              "tags": [
                "quality",
                "beginner"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90
            },
            {
              "id": "e2e-testing-q10",
              "question": "Which of the following is a key feature of End-to-End Testing?",
              "topic": "Playwright",
              "difficulty": "Beginner",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of Cypress concepts. The correct answer demonstrates proper implementation of End-to-End Testing principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding Cypress is crucial for building scalable and maintainable applications.",
              "tags": [
                "quality",
                "beginner"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90
            },
            {
              "id": "e2e-testing-q11",
              "question": "Which pattern is most effective for Cypress architecture?",
              "topic": "E2E Testing",
              "difficulty": "Intermediate",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of Cypress concepts. The correct answer demonstrates proper implementation of End-to-End Testing principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding Cypress is crucial for building scalable and maintainable applications.",
              "tags": [
                "quality",
                "intermediate"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90
            },
            {
              "id": "e2e-testing-q12",
              "question": "How do you implement Cypress in a production environment?",
              "topic": "Cypress",
              "difficulty": "Intermediate",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of Cypress concepts. The correct answer demonstrates proper implementation of End-to-End Testing principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding Cypress is crucial for building scalable and maintainable applications.",
              "tags": [
                "quality",
                "intermediate"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90
            },
            {
              "id": "e2e-testing-q13",
              "question": "What are the trade-offs between different Cypress approaches?",
              "topic": "Playwright",
              "difficulty": "Advanced",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of Cypress concepts. The correct answer demonstrates proper implementation of End-to-End Testing principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding Cypress is crucial for building scalable and maintainable applications.",
              "tags": [
                "quality",
                "advanced"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90
            },
            {
              "id": "e2e-testing-q14",
              "question": "Which pattern is most effective for Cypress architecture?",
              "topic": "E2E Testing",
              "difficulty": "Intermediate",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of Cypress concepts. The correct answer demonstrates proper implementation of End-to-End Testing principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding Cypress is crucial for building scalable and maintainable applications.",
              "tags": [
                "quality",
                "intermediate"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90
            },
            {
              "id": "e2e-testing-q15",
              "question": "How do you implement Cypress in a production environment?",
              "topic": "Cypress",
              "difficulty": "Intermediate",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of Cypress concepts. The correct answer demonstrates proper implementation of End-to-End Testing principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding Cypress is crucial for building scalable and maintainable applications.",
              "tags": [
                "quality",
                "intermediate"
              ],
              "questionType": "multiple-choice",
              "estimatedTime": 90
            }
          ],
          "issues": []
        },
        "meetsThresholds": true,
        "issues": []
      },
      "performance-optimization": {
        "slug": "performance-optimization",
        "title": "Performance Optimization",
        "tier": "quality",
        "track": "Performance",
        "difficulty": "Advanced",
        "thresholds": {
          "requiredLessons": 13,
          "requiredQuestions": 16
        },
        "lessons": {
          "exists": true,
          "count": 13,
          "lessons": [
            {
              "id": "performance-optimization-lesson-1",
              "moduleSlug": "performance-optimization",
              "title": "Performance Fundamentals and Profiling",
              "order": 1,
              "objectives": [
                "Understand performance metrics and why they matter",
                "Learn to use browser DevTools for performance profiling",
                "Identify common performance bottlenecks in web applications"
              ],
              "intro": "Performance optimization is crucial for creating successful web applications that provide excellent user experiences. Even small improvements in load times can significantly impact user engagement and business metrics.\n\nIn this lesson, you'll learn about Core Web Vitals - Google's metrics for measuring user experience including Largest Contentful Paint (LCP), First Input Delay (FID), and Cumulative Layout Shift (CLS). These metrics directly affect search rankings and user satisfaction.\n\nBrowser DevTools provide powerful profiling capabilities that help identify performance bottlenecks. You'll master the Performance tab, Network tab, and Lighthouse audits to diagnose issues ranging from slow JavaScript execution to inefficient asset loading.\n\nCommon performance issues include blocking JavaScript, large bundle sizes, inefficient CSS, and poor image optimization. Understanding these patterns helps you proactively design performant applications rather than fixing issues after deployment.\n\nBy the end of this lesson, you'll confidently use profiling tools to measure performance, identify bottlenecks, and understand the relationship between code quality and user experience. This foundation is essential for building fast, responsive web applications.",
              "code": {
                "example": "// Performance monitoring and profiling techniques\n\n// 1. Measuring Core Web Vitals\nfunction measurePerformance() {\n  // Largest Contentful Paint (LCP)\n  new PerformanceObserver((entryList) => {\n    for (const entry of entryList.getEntries()) {\n      console.log('LCP:', entry.startTime);\n    }\n  }).observe({ entryTypes: ['largest-contentful-paint'] });\n\n  // First Input Delay (FID)\n  new PerformanceObserver((entryList) => {\n    for (const entry of entryList.getEntries()) {\n      console.log('FID:', entry.processingStart - entry.startTime);\n    }\n  }).observe({ entryTypes: ['first-input'] });\n\n  // Cumulative Layout Shift (CLS)\n  new PerformanceObserver((entryList) => {\n    for (const entry of entryList.getEntries()) {\n      console.log('Layout shift:', entry.value);\n    }\n  }).observe({ entryTypes: ['layout-shift'] });\n}\n\n// 2. Performance timing API\nfunction analyzePageLoad() {\n  const timing = performance.timing;\n  const navigation = performance.navigation;\n\n  const loadTime = timing.loadEventEnd - timing.navigationStart;\n  const domReady = timing.domContentLoadedEventEnd - timing.navigationStart;\n  const firstByte = timing.responseStart - timing.navigationStart;\n\n  console.log({\n    loadTime: loadTime + 'ms',\n    domReady: domReady + 'ms',\n    timeToFirstByte: firstByte + 'ms',\n    navigationType: navigation.type\n  });\n}\n\n// 3. Resource timing analysis\nfunction analyzeResources() {\n  const resources = performance.getEntriesByType('resource');\n  \n  resources.forEach(resource => {\n    const loadTime = resource.responseEnd - resource.startTime;\n    const resourceSize = resource.transferSize;\n    \n    if (loadTime > 1000) { // Slow resources\n      console.warn(`Slow resource: ${resource.name}`, {\n        loadTime: loadTime + 'ms',\n        size: (resourceSize / 1024).toFixed(2) + 'KB',\n        type: resource.initiatorType\n      });\n    }\n  });\n}\n\n// 4. Memory usage monitoring\nfunction monitorMemory() {\n  if ('memory' in performance) {\n    const memory = performance.memory;\n    console.log({\n      usedHeap: (memory.usedJSHeapSize / 1048576).toFixed(2) + 'MB',\n      totalHeap: (memory.totalJSHeapSize / 1048576).toFixed(2) + 'MB',\n      heapLimit: (memory.jsHeapSizeLimit / 1048576).toFixed(2) + 'MB'\n    });\n  }\n}\n\n// 5. Long task detection\nif ('PerformanceObserver' in window) {\n  const observer = new PerformanceObserver((list) => {\n    for (const entry of list.getEntries()) {\n      console.warn('Long task detected:', {\n        duration: entry.duration + 'ms',\n        startTime: entry.startTime,\n        name: entry.name\n      });\n    }\n  });\n  observer.observe({ entryTypes: ['longtask'] });\n}\n\n// Initialize monitoring\nmeasurePerformance();\nwindow.addEventListener('load', () => {\n  setTimeout(() => {\n    analyzePageLoad();\n    analyzeResources();\n    monitorMemory();\n  }, 1000);\n});",
                "explanation": "This example demonstrates comprehensive performance monitoring including Core Web Vitals measurement, page load analysis, resource timing, memory monitoring, and long task detection using modern browser APIs.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Optimizing based on assumptions rather than measurements",
                  "solution": "Always measure performance before and after optimizations using proper profiling tools",
                  "severity": "high"
                },
                {
                  "mistake": "Focusing only on initial page load and ignoring runtime performance",
                  "solution": "Monitor ongoing performance including user interactions, animations, and memory usage",
                  "severity": "medium"
                },
                {
                  "mistake": "Testing performance only on high-end devices and fast networks",
                  "solution": "Test on various devices and network conditions, especially slower connections and mobile devices",
                  "severity": "high"
                }
              ],
              "exercises": [
                {
                  "title": "Performance Audit and Optimization",
                  "description": "Conduct a comprehensive performance audit of a web application and implement optimizations.",
                  "checkpoints": [
                    "Use Lighthouse to audit Core Web Vitals and performance metrics",
                    "Profile JavaScript execution and identify long tasks",
                    "Analyze network waterfall and optimize resource loading",
                    "Implement performance monitoring code to track real user metrics"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Advanced",
              "tags": [
                "Performance",
                "Profiling",
                "Optimization"
              ],
              "lastUpdated": "2025-10-01T06:42:16.317Z",
              "version": "1.0.0"
            },
            {
              "id": "performance-optimization-lesson-2",
              "moduleSlug": "performance-optimization",
              "title": "Quality Assurance",
              "order": 2,
              "objectives": [
                "Implement basic Performance patterns",
                "Create simple applications using core concepts",
                "Debug common issues effectively"
              ],
              "intro": "Welcome to Quality Assurance in the Performance Optimization module. \n\nThis lesson is part of the quality tier, designed for advanced level learners. Throughout this lesson, you'll explore essential concepts and practical applications that form the foundation of modern performance development.\n\nProfiling, monitoring, and optimization techniques This lesson builds upon previous concepts while introducing new techniques that will enhance your understanding and practical skills.\n\nBy the end of this lesson, you'll have hands-on experience with Performance and Profiling, along with best practices for implementing these technologies in real-world scenarios. The knowledge gained here will prepare you for more advanced topics in subsequent lessons.\n\nKey areas we'll cover include practical implementation techniques, common challenges developers face, and proven solutions that industry professionals use daily. This lesson balances theoretical understanding with practical application, ensuring you can immediately apply what you learn.",
              "code": {
                "example": "// Example Performance implementation\n// TODO: Add specific code example for Performance Optimization\n\nfunction example() {\n    // Placeholder implementation\n    console.log('Performance Optimization example');\n}\n\nexport default example;",
                "explanation": "This example demonstrates the key concepts covered in this lesson.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following Performance best practices",
                  "solution": "Review official documentation and established patterns for Performance",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling in implementation",
                  "solution": "Always implement proper error handling and validation",
                  "severity": "high"
                },
                {
                  "mistake": "Ignoring performance implications",
                  "solution": "Consider performance impact of your implementation choices",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice Quality Assurance",
                  "description": "Apply the concepts learned in this lesson through hands-on practice.",
                  "checkpoints": [
                    "Complete the basic implementation",
                    "Test your solution",
                    "Identify areas for improvement"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Advanced",
              "tags": [
                "Performance",
                "Profiling",
                "Optimization"
              ],
              "lastUpdated": "2025-10-01T06:42:16.317Z",
              "version": "1.0.0"
            },
            {
              "id": "performance-optimization-lesson-3",
              "moduleSlug": "performance-optimization",
              "title": "Automated Testing",
              "order": 3,
              "objectives": [
                "Apply advanced Performance techniques",
                "Optimize performance and efficiency",
                "Integrate with external systems"
              ],
              "intro": "Welcome to Automated Testing in the Performance Optimization module. \n\nThis lesson is part of the quality tier, designed for advanced level learners. Throughout this lesson, you'll explore essential concepts and practical applications that form the foundation of modern performance development.\n\nProfiling, monitoring, and optimization techniques This lesson builds upon previous concepts while introducing new techniques that will enhance your understanding and practical skills.\n\nBy the end of this lesson, you'll have hands-on experience with Performance and Profiling, along with best practices for implementing these technologies in real-world scenarios. The knowledge gained here will prepare you for more advanced topics in subsequent lessons.\n\nKey areas we'll cover include practical implementation techniques, common challenges developers face, and proven solutions that industry professionals use daily. This lesson balances theoretical understanding with practical application, ensuring you can immediately apply what you learn.",
              "code": {
                "example": "// Automated Performance Testing with Lighthouse CI\n\n// package.json\n{\n  \"devDependencies\": {\n    \"@lhci/cli\": \"^0.12.0\",\n    \"puppeteer\": \"^21.0.0\"\n  },\n  \"scripts\": {\n    \"perf:test\": \"lhci autorun\",\n    \"perf:analyze\": \"node scripts/performance-test.js\"\n  }\n}\n\n// .lighthouserc.js\nmodule.exports = {\n  ci: {\n    collect: {\n      url: ['http://localhost:3000'],\n      numberOfRuns: 3\n    },\n    assert: {\n      assertions: {\n        'categories:performance': ['error', { minScore: 0.8 }],\n        'categories:accessibility': ['error', { minScore: 0.9 }],\n        'first-contentful-paint': ['error', { maxNumericValue: 2000 }],\n        'largest-contentful-paint': ['error', { maxNumericValue: 2500 }]\n      }\n    }\n  }\n};\n\n// scripts/performance-test.js\nconst { performance } = require('perf_hooks');\nconst puppeteer = require('puppeteer');\n\nasync function measurePagePerformance(url) {\n  const browser = await puppeteer.launch();\n  const page = await browser.newPage();\n  \n  // Enable performance monitoring\n  await page.setCacheEnabled(false);\n  \n  const startTime = performance.now();\n  await page.goto(url, { waitUntil: 'networkidle0' });\n  const loadTime = performance.now() - startTime;\n  \n  // Measure Core Web Vitals\n  const metrics = await page.evaluate(() => {\n    return new Promise((resolve) => {\n      new PerformanceObserver((list) => {\n        const entries = list.getEntries();\n        resolve(entries.map(entry => ({\n          name: entry.name,\n          value: entry.value,\n          rating: entry.value < 2500 ? 'good' : 'poor'\n        })));\n      }).observe({ entryTypes: ['largest-contentful-paint'] });\n    });\n  });\n  \n  await browser.close();\n  \n  return {\n    loadTime: Math.round(loadTime),\n    metrics,\n    url\n  };\n}\n\n// Usage\nmeasurePagePerformance('http://localhost:3000')\n  .then(results => {\n    console.log('Performance Results:', results);\n    if (results.loadTime > 3000) {\n      console.error(' Page load time exceeds threshold');\n      process.exit(1);\n    }\n    console.log(' Performance test passed');\n  });",
                "explanation": "This example demonstrates automated performance testing using Lighthouse CI and Puppeteer. The setup includes configuration for continuous integration testing with performance thresholds, automated Core Web Vitals measurement, and practical scripts for monitoring page load times and rendering metrics in development workflows.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following Performance best practices",
                  "solution": "Review official documentation and established patterns for Performance",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling in implementation",
                  "solution": "Always implement proper error handling and validation",
                  "severity": "high"
                },
                {
                  "mistake": "Ignoring performance implications",
                  "solution": "Consider performance impact of your implementation choices",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice Automated Testing",
                  "description": "Apply the concepts learned in this lesson through hands-on practice.",
                  "checkpoints": [
                    "Complete the basic implementation",
                    "Test your solution",
                    "Identify areas for improvement"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Advanced",
              "tags": [
                "Performance",
                "Profiling",
                "Optimization"
              ],
              "lastUpdated": "2025-10-01T06:42:16.317Z",
              "version": "1.0.0"
            },
            {
              "id": "performance-optimization-lesson-4",
              "moduleSlug": "performance-optimization",
              "title": "Performance Testing",
              "order": 4,
              "objectives": [
                "Apply advanced Performance techniques",
                "Optimize performance and efficiency",
                "Integrate with external systems"
              ],
              "intro": "Welcome to Performance Testing in the Performance Optimization module. \n\nThis lesson is part of the quality tier, designed for advanced level learners. Throughout this lesson, you'll explore essential concepts and practical applications that form the foundation of modern performance development.\n\nProfiling, monitoring, and optimization techniques This lesson builds upon previous concepts while introducing new techniques that will enhance your understanding and practical skills.\n\nBy the end of this lesson, you'll have hands-on experience with Performance and Profiling, along with best practices for implementing these technologies in real-world scenarios. The knowledge gained here will prepare you for more advanced topics in subsequent lessons.\n\nKey areas we'll cover include practical implementation techniques, common challenges developers face, and proven solutions that industry professionals use daily. This lesson balances theoretical understanding with practical application, ensuring you can immediately apply what you learn.",
              "code": {
                "example": "// Performance Testing with Web Performance API\n\n// Basic performance measurement\nconst perfObserver = new PerformanceObserver((list) => {\n  const entries = list.getEntries();\n  entries.forEach((entry) => {\n    console.log(`${entry.name}: ${entry.duration}ms`);\n  });\n});\n\nperfObserver.observe({ entryTypes: ['measure', 'navigation'] });\n\n// Function performance testing\nfunction measureFunction(fn, ...args) {\n  const start = performance.now();\n  const result = fn(...args);\n  const end = performance.now();\n  \n  console.log(`Function executed in ${end - start}ms`);\n  return result;\n}\n\n// Memory usage monitoring\nfunction measureMemoryUsage() {\n  if ('memory' in performance) {\n    const memory = performance.memory;\n    return {\n      usedJSHeapSize: memory.usedJSHeapSize,\n      totalJSHeapSize: memory.totalJSHeapSize,\n      jsHeapSizeLimit: memory.jsHeapSizeLimit\n    };\n  }\n  return null;\n}\n\n// Load testing simulation\nasync function loadTest(url, concurrentUsers = 10, duration = 30000) {\n  const results = [];\n  const startTime = Date.now();\n  \n  const promises = Array.from({ length: concurrentUsers }, async (_, i) => {\n    const userResults = [];\n    \n    while (Date.now() - startTime < duration) {\n      const requestStart = performance.now();\n      \n      try {\n        const response = await fetch(url);\n        const requestEnd = performance.now();\n        \n        userResults.push({\n          user: i,\n          responseTime: requestEnd - requestStart,\n          status: response.status,\n          timestamp: Date.now()\n        });\n      } catch (error) {\n        userResults.push({\n          user: i,\n          error: error.message,\n          timestamp: Date.now()\n        });\n      }\n      \n      // Random delay between requests\n      await new Promise(resolve => setTimeout(resolve, Math.random() * 1000));\n    }\n    \n    return userResults;\n  });\n  \n  const allResults = await Promise.all(promises);\n  return allResults.flat();\n}\n\n// Performance budget validation\nfunction validatePerformanceBudget(metrics, budget) {\n  const violations = [];\n  \n  Object.keys(budget).forEach(metric => {\n    if (metrics[metric] > budget[metric]) {\n      violations.push({\n        metric,\n        actual: metrics[metric],\n        budget: budget[metric],\n        exceeded: metrics[metric] - budget[metric]\n      });\n    }\n  });\n  \n  return {\n    passed: violations.length === 0,\n    violations\n  };\n}\n\n// Usage example\nconst budget = {\n  'first-contentful-paint': 1500,\n  'largest-contentful-paint': 2500,\n  'cumulative-layout-shift': 0.1\n};\n\n// Measure current page performance\nsetTimeout(() => {\n  const navigation = performance.getEntriesByType('navigation')[0];\n  const metrics = {\n    'first-contentful-paint': navigation.domContentLoadedEventEnd - navigation.navigationStart,\n    'largest-contentful-paint': 2000, // Example value\n    'cumulative-layout-shift': 0.05 // Example value\n  };\n  \n  const result = validatePerformanceBudget(metrics, budget);\n  console.log('Performance Budget Check:', result);\n}, 1000);",
                "explanation": "This example demonstrates comprehensive performance testing techniques including function timing, memory monitoring, load testing simulation, and performance budget validation. The code shows practical approaches for measuring Web Performance API metrics, conducting concurrent user simulations, and validating against performance thresholds in real applications.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following Performance best practices",
                  "solution": "Review official documentation and established patterns for Performance",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling in implementation",
                  "solution": "Always implement proper error handling and validation",
                  "severity": "high"
                },
                {
                  "mistake": "Ignoring performance implications",
                  "solution": "Consider performance impact of your implementation choices",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice Performance Testing",
                  "description": "Apply the concepts learned in this lesson through hands-on practice.",
                  "checkpoints": [
                    "Complete the basic implementation",
                    "Test your solution",
                    "Identify areas for improvement"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Advanced",
              "tags": [
                "Performance",
                "Profiling",
                "Optimization"
              ],
              "lastUpdated": "2025-10-01T06:42:16.317Z",
              "version": "1.0.0"
            },
            {
              "id": "performance-optimization-lesson-5",
              "moduleSlug": "performance-optimization",
              "title": "Security Testing",
              "order": 5,
              "objectives": [
                "Apply advanced Performance techniques",
                "Optimize performance and efficiency",
                "Integrate with external systems"
              ],
              "intro": "Welcome to Security Testing in the Performance Optimization module. \n\nThis lesson is part of the quality tier, designed for advanced level learners. Throughout this lesson, you'll explore essential concepts and practical applications that form the foundation of modern performance development.\n\nProfiling, monitoring, and optimization techniques This lesson builds upon previous concepts while introducing new techniques that will enhance your understanding and practical skills.\n\nBy the end of this lesson, you'll have hands-on experience with Performance and Profiling, along with best practices for implementing these technologies in real-world scenarios. The knowledge gained here will prepare you for more advanced topics in subsequent lessons.\n\nKey areas we'll cover include practical implementation techniques, common challenges developers face, and proven solutions that industry professionals use daily. This lesson balances theoretical understanding with practical application, ensuring you can immediately apply what you learn.",
              "code": {
                "example": "// Example Performance implementation\n// TODO: Add specific code example for Performance Optimization\n\nfunction example() {\n    // Placeholder implementation\n    console.log('Performance Optimization example');\n}\n\nexport default example;",
                "explanation": "This example demonstrates the key concepts covered in this lesson.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following Performance best practices",
                  "solution": "Review official documentation and established patterns for Performance",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling in implementation",
                  "solution": "Always implement proper error handling and validation",
                  "severity": "high"
                },
                {
                  "mistake": "Ignoring performance implications",
                  "solution": "Consider performance impact of your implementation choices",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice Security Testing",
                  "description": "Apply the concepts learned in this lesson through hands-on practice.",
                  "checkpoints": [
                    "Complete the basic implementation",
                    "Test your solution",
                    "Identify areas for improvement"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Advanced",
              "tags": [
                "Performance",
                "Profiling",
                "Optimization"
              ],
              "lastUpdated": "2025-10-01T06:42:16.317Z",
              "version": "1.0.0"
            },
            {
              "id": "performance-optimization-lesson-6",
              "moduleSlug": "performance-optimization",
              "title": "Code Quality",
              "order": 6,
              "objectives": [
                "Apply advanced Performance techniques",
                "Optimize performance and efficiency",
                "Integrate with external systems"
              ],
              "intro": "Welcome to Code Quality in the Performance Optimization module. \n\nThis lesson is part of the quality tier, designed for advanced level learners. Throughout this lesson, you'll explore essential concepts and practical applications that form the foundation of modern performance development.\n\nProfiling, monitoring, and optimization techniques This lesson builds upon previous concepts while introducing new techniques that will enhance your understanding and practical skills.\n\nBy the end of this lesson, you'll have hands-on experience with Performance and Profiling, along with best practices for implementing these technologies in real-world scenarios. The knowledge gained here will prepare you for more advanced topics in subsequent lessons.\n\nKey areas we'll cover include practical implementation techniques, common challenges developers face, and proven solutions that industry professionals use daily. This lesson balances theoretical understanding with practical application, ensuring you can immediately apply what you learn.",
              "code": {
                "example": "// Example Performance implementation\n// TODO: Add specific code example for Performance Optimization\n\nfunction example() {\n    // Placeholder implementation\n    console.log('Performance Optimization example');\n}\n\nexport default example;",
                "explanation": "This example demonstrates the key concepts covered in this lesson.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following Performance best practices",
                  "solution": "Review official documentation and established patterns for Performance",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling in implementation",
                  "solution": "Always implement proper error handling and validation",
                  "severity": "high"
                },
                {
                  "mistake": "Ignoring performance implications",
                  "solution": "Consider performance impact of your implementation choices",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice Code Quality",
                  "description": "Apply the concepts learned in this lesson through hands-on practice.",
                  "checkpoints": [
                    "Complete the basic implementation",
                    "Test your solution",
                    "Identify areas for improvement"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Advanced",
              "tags": [
                "Performance",
                "Profiling",
                "Optimization"
              ],
              "lastUpdated": "2025-10-01T06:42:16.317Z",
              "version": "1.0.0"
            },
            {
              "id": "performance-optimization-lesson-7",
              "moduleSlug": "performance-optimization",
              "title": "Review Processes",
              "order": 7,
              "objectives": [
                "Apply advanced Performance techniques",
                "Optimize performance and efficiency",
                "Integrate with external systems"
              ],
              "intro": "Welcome to Review Processes in the Performance Optimization module. \n\nThis lesson is part of the quality tier, designed for advanced level learners. Throughout this lesson, you'll explore essential concepts and practical applications that form the foundation of modern performance development.\n\nProfiling, monitoring, and optimization techniques This lesson builds upon previous concepts while introducing new techniques that will enhance your understanding and practical skills.\n\nBy the end of this lesson, you'll have hands-on experience with Performance and Profiling, along with best practices for implementing these technologies in real-world scenarios. The knowledge gained here will prepare you for more advanced topics in subsequent lessons.\n\nKey areas we'll cover include practical implementation techniques, common challenges developers face, and proven solutions that industry professionals use daily. This lesson balances theoretical understanding with practical application, ensuring you can immediately apply what you learn.",
              "code": {
                "example": "// Example Performance implementation\n// TODO: Add specific code example for Performance Optimization\n\nfunction example() {\n    // Placeholder implementation\n    console.log('Performance Optimization example');\n}\n\nexport default example;",
                "explanation": "This example demonstrates the key concepts covered in this lesson.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following Performance best practices",
                  "solution": "Review official documentation and established patterns for Performance",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling in implementation",
                  "solution": "Always implement proper error handling and validation",
                  "severity": "high"
                },
                {
                  "mistake": "Ignoring performance implications",
                  "solution": "Consider performance impact of your implementation choices",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice Review Processes",
                  "description": "Apply the concepts learned in this lesson through hands-on practice.",
                  "checkpoints": [
                    "Complete the basic implementation",
                    "Test your solution",
                    "Identify areas for improvement"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Advanced",
              "tags": [
                "Performance",
                "Profiling",
                "Optimization"
              ],
              "lastUpdated": "2025-10-01T06:42:16.317Z",
              "version": "1.0.0"
            },
            {
              "id": "performance-optimization-lesson-8",
              "moduleSlug": "performance-optimization",
              "title": "Continuous Integration",
              "order": 8,
              "objectives": [
                "Apply advanced Performance techniques",
                "Optimize performance and efficiency",
                "Integrate with external systems"
              ],
              "intro": "Welcome to Continuous Integration in the Performance Optimization module. \n\nThis lesson is part of the quality tier, designed for advanced level learners. Throughout this lesson, you'll explore essential concepts and practical applications that form the foundation of modern performance development.\n\nProfiling, monitoring, and optimization techniques This lesson builds upon previous concepts while introducing new techniques that will enhance your understanding and practical skills.\n\nBy the end of this lesson, you'll have hands-on experience with Performance and Profiling, along with best practices for implementing these technologies in real-world scenarios. The knowledge gained here will prepare you for more advanced topics in subsequent lessons.\n\nKey areas we'll cover include practical implementation techniques, common challenges developers face, and proven solutions that industry professionals use daily. This lesson balances theoretical understanding with practical application, ensuring you can immediately apply what you learn.",
              "code": {
                "example": "// Example Performance implementation\n// TODO: Add specific code example for Performance Optimization\n\nfunction example() {\n    // Placeholder implementation\n    console.log('Performance Optimization example');\n}\n\nexport default example;",
                "explanation": "This example demonstrates the key concepts covered in this lesson.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following Performance best practices",
                  "solution": "Review official documentation and established patterns for Performance",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling in implementation",
                  "solution": "Always implement proper error handling and validation",
                  "severity": "high"
                },
                {
                  "mistake": "Ignoring performance implications",
                  "solution": "Consider performance impact of your implementation choices",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice Continuous Integration",
                  "description": "Apply the concepts learned in this lesson through hands-on practice.",
                  "checkpoints": [
                    "Complete the basic implementation",
                    "Test your solution",
                    "Identify areas for improvement"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Advanced",
              "tags": [
                "Performance",
                "Profiling",
                "Optimization"
              ],
              "lastUpdated": "2025-10-01T06:42:16.317Z",
              "version": "1.0.0"
            },
            {
              "id": "performance-optimization-lesson-9",
              "moduleSlug": "performance-optimization",
              "title": "Monitoring Setup",
              "order": 9,
              "objectives": [
                "Apply advanced Performance techniques",
                "Optimize performance and efficiency",
                "Integrate with external systems"
              ],
              "intro": "Welcome to Monitoring Setup in the Performance Optimization module. \n\nThis lesson is part of the quality tier, designed for advanced level learners. Throughout this lesson, you'll explore essential concepts and practical applications that form the foundation of modern performance development.\n\nProfiling, monitoring, and optimization techniques This lesson builds upon previous concepts while introducing new techniques that will enhance your understanding and practical skills.\n\nBy the end of this lesson, you'll have hands-on experience with Performance and Profiling, along with best practices for implementing these technologies in real-world scenarios. The knowledge gained here will prepare you for more advanced topics in subsequent lessons.\n\nKey areas we'll cover include practical implementation techniques, common challenges developers face, and proven solutions that industry professionals use daily. This lesson balances theoretical understanding with practical application, ensuring you can immediately apply what you learn.",
              "code": {
                "example": "// Example Performance implementation\n// TODO: Add specific code example for Performance Optimization\n\nfunction example() {\n    // Placeholder implementation\n    console.log('Performance Optimization example');\n}\n\nexport default example;",
                "explanation": "This example demonstrates the key concepts covered in this lesson.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following Performance best practices",
                  "solution": "Review official documentation and established patterns for Performance",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling in implementation",
                  "solution": "Always implement proper error handling and validation",
                  "severity": "high"
                },
                {
                  "mistake": "Ignoring performance implications",
                  "solution": "Consider performance impact of your implementation choices",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice Monitoring Setup",
                  "description": "Apply the concepts learned in this lesson through hands-on practice.",
                  "checkpoints": [
                    "Complete the basic implementation",
                    "Test your solution",
                    "Identify areas for improvement"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Advanced",
              "tags": [
                "Performance",
                "Profiling",
                "Optimization"
              ],
              "lastUpdated": "2025-10-01T06:42:16.317Z",
              "version": "1.0.0"
            },
            {
              "id": "performance-optimization-lesson-10",
              "moduleSlug": "performance-optimization",
              "title": "Debugging Techniques",
              "order": 10,
              "objectives": [
                "Apply advanced Performance techniques",
                "Optimize performance and efficiency",
                "Integrate with external systems"
              ],
              "intro": "Welcome to Debugging Techniques in the Performance Optimization module. \n\nThis lesson is part of the quality tier, designed for advanced level learners. Throughout this lesson, you'll explore essential concepts and practical applications that form the foundation of modern performance development.\n\nProfiling, monitoring, and optimization techniques This lesson builds upon previous concepts while introducing new techniques that will enhance your understanding and practical skills.\n\nBy the end of this lesson, you'll have hands-on experience with Performance and Profiling, along with best practices for implementing these technologies in real-world scenarios. The knowledge gained here will prepare you for more advanced topics in subsequent lessons.\n\nKey areas we'll cover include practical implementation techniques, common challenges developers face, and proven solutions that industry professionals use daily. This lesson balances theoretical understanding with practical application, ensuring you can immediately apply what you learn.",
              "code": {
                "example": "// Example Performance implementation\n// TODO: Add specific code example for Performance Optimization\n\nfunction example() {\n    // Placeholder implementation\n    console.log('Performance Optimization example');\n}\n\nexport default example;",
                "explanation": "This example demonstrates the key concepts covered in this lesson.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following Performance best practices",
                  "solution": "Review official documentation and established patterns for Performance",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling in implementation",
                  "solution": "Always implement proper error handling and validation",
                  "severity": "high"
                },
                {
                  "mistake": "Ignoring performance implications",
                  "solution": "Consider performance impact of your implementation choices",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice Debugging Techniques",
                  "description": "Apply the concepts learned in this lesson through hands-on practice.",
                  "checkpoints": [
                    "Complete the basic implementation",
                    "Test your solution",
                    "Identify areas for improvement"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Advanced",
              "tags": [
                "Performance",
                "Profiling",
                "Optimization"
              ],
              "lastUpdated": "2025-10-01T06:42:16.317Z",
              "version": "1.0.0"
            },
            {
              "id": "performance-optimization-lesson-11",
              "moduleSlug": "performance-optimization",
              "title": "Optimization Methods",
              "order": 11,
              "objectives": [
                "Apply advanced Performance techniques",
                "Optimize performance and efficiency",
                "Integrate with external systems"
              ],
              "intro": "Welcome to Optimization Methods in the Performance Optimization module. \n\nThis lesson is part of the quality tier, designed for advanced level learners. Throughout this lesson, you'll explore essential concepts and practical applications that form the foundation of modern performance development.\n\nProfiling, monitoring, and optimization techniques This lesson builds upon previous concepts while introducing new techniques that will enhance your understanding and practical skills.\n\nBy the end of this lesson, you'll have hands-on experience with Performance and Profiling, along with best practices for implementing these technologies in real-world scenarios. The knowledge gained here will prepare you for more advanced topics in subsequent lessons.\n\nKey areas we'll cover include practical implementation techniques, common challenges developers face, and proven solutions that industry professionals use daily. This lesson balances theoretical understanding with practical application, ensuring you can immediately apply what you learn.",
              "code": {
                "example": "// Example Performance implementation\n// TODO: Add specific code example for Performance Optimization\n\nfunction example() {\n    // Placeholder implementation\n    console.log('Performance Optimization example');\n}\n\nexport default example;",
                "explanation": "This example demonstrates the key concepts covered in this lesson.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following Performance best practices",
                  "solution": "Review official documentation and established patterns for Performance",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling in implementation",
                  "solution": "Always implement proper error handling and validation",
                  "severity": "high"
                },
                {
                  "mistake": "Ignoring performance implications",
                  "solution": "Consider performance impact of your implementation choices",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice Optimization Methods",
                  "description": "Apply the concepts learned in this lesson through hands-on practice.",
                  "checkpoints": [
                    "Complete the basic implementation",
                    "Test your solution",
                    "Identify areas for improvement"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Advanced",
              "tags": [
                "Performance",
                "Profiling",
                "Optimization"
              ],
              "lastUpdated": "2025-10-01T06:42:16.317Z",
              "version": "1.0.0"
            },
            {
              "id": "performance-optimization-lesson-12",
              "moduleSlug": "performance-optimization",
              "title": "Quality Standards",
              "order": 12,
              "objectives": [
                "Apply advanced Performance techniques",
                "Optimize performance and efficiency",
                "Integrate with external systems"
              ],
              "intro": "Welcome to Quality Standards in the Performance Optimization module. \n\nThis lesson is part of the quality tier, designed for advanced level learners. Throughout this lesson, you'll explore essential concepts and practical applications that form the foundation of modern performance development.\n\nProfiling, monitoring, and optimization techniques This lesson builds upon previous concepts while introducing new techniques that will enhance your understanding and practical skills.\n\nBy the end of this lesson, you'll have hands-on experience with Performance and Profiling, along with best practices for implementing these technologies in real-world scenarios. The knowledge gained here will prepare you for more advanced topics in subsequent lessons.\n\nKey areas we'll cover include practical implementation techniques, common challenges developers face, and proven solutions that industry professionals use daily. This lesson balances theoretical understanding with practical application, ensuring you can immediately apply what you learn.",
              "code": {
                "example": "// Example Performance implementation\n// TODO: Add specific code example for Performance Optimization\n\nfunction example() {\n    // Placeholder implementation\n    console.log('Performance Optimization example');\n}\n\nexport default example;",
                "explanation": "This example demonstrates the key concepts covered in this lesson.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following Performance best practices",
                  "solution": "Review official documentation and established patterns for Performance",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling in implementation",
                  "solution": "Always implement proper error handling and validation",
                  "severity": "high"
                },
                {
                  "mistake": "Ignoring performance implications",
                  "solution": "Consider performance impact of your implementation choices",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice Quality Standards",
                  "description": "Apply the concepts learned in this lesson through hands-on practice.",
                  "checkpoints": [
                    "Complete the basic implementation",
                    "Test your solution",
                    "Identify areas for improvement"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Advanced",
              "tags": [
                "Performance",
                "Profiling",
                "Optimization"
              ],
              "lastUpdated": "2025-10-01T06:42:16.317Z",
              "version": "1.0.0"
            },
            {
              "id": "performance-optimization-lesson-13",
              "moduleSlug": "performance-optimization",
              "title": "Lesson 13",
              "order": 13,
              "objectives": [
                "Apply advanced Performance techniques",
                "Optimize performance and efficiency",
                "Integrate with external systems"
              ],
              "intro": "Welcome to Lesson 13 in the Performance Optimization module. \n\nThis lesson is part of the quality tier, designed for advanced level learners. Throughout this lesson, you'll explore essential concepts and practical applications that form the foundation of modern performance development.\n\nProfiling, monitoring, and optimization techniques This lesson builds upon previous concepts while introducing new techniques that will enhance your understanding and practical skills.\n\nBy the end of this lesson, you'll have hands-on experience with Performance and Profiling, along with best practices for implementing these technologies in real-world scenarios. The knowledge gained here will prepare you for more advanced topics in subsequent lessons.\n\nKey areas we'll cover include practical implementation techniques, common challenges developers face, and proven solutions that industry professionals use daily. This lesson balances theoretical understanding with practical application, ensuring you can immediately apply what you learn.",
              "code": {
                "example": "// Example Performance implementation\n// TODO: Add specific code example for Performance Optimization\n\nfunction example() {\n    // Placeholder implementation\n    console.log('Performance Optimization example');\n}\n\nexport default example;",
                "explanation": "This example demonstrates the key concepts covered in this lesson.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following Performance best practices",
                  "solution": "Review official documentation and established patterns for Performance",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling in implementation",
                  "solution": "Always implement proper error handling and validation",
                  "severity": "high"
                },
                {
                  "mistake": "Ignoring performance implications",
                  "solution": "Consider performance impact of your implementation choices",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice Lesson 13",
                  "description": "Apply the concepts learned in this lesson through hands-on practice.",
                  "checkpoints": [
                    "Complete the basic implementation",
                    "Test your solution",
                    "Identify areas for improvement"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Advanced",
              "tags": [
                "Performance",
                "Profiling",
                "Optimization"
              ],
              "lastUpdated": "2025-10-01T06:42:16.317Z",
              "version": "1.0.0"
            }
          ],
          "issues": []
        },
        "quiz": {
          "exists": true,
          "count": 16,
          "questions": [
            {
              "id": "performance-optimization-q1",
              "question": "What are the trade-offs between different Performance approaches?",
              "topic": "Profiling",
              "difficulty": "Advanced",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of Performance concepts. The correct answer demonstrates proper implementation of Performance Optimization principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding Performance is crucial for building scalable and maintainable applications.",
              "tags": [
                "quality",
                "advanced"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "performance-optimization-q2",
              "question": "When should you use Performance in development?",
              "topic": "Optimization",
              "difficulty": "Beginner",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of Performance concepts. The correct answer demonstrates proper implementation of Performance Optimization principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding Performance is crucial for building scalable and maintainable applications.",
              "tags": [
                "quality",
                "beginner"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "performance-optimization-q3",
              "question": "How do you implement Performance in a production environment?",
              "topic": "Performance",
              "difficulty": "Intermediate",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of Performance concepts. The correct answer demonstrates proper implementation of Performance Optimization principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding Performance is crucial for building scalable and maintainable applications.",
              "tags": [
                "quality",
                "intermediate"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "performance-optimization-q4",
              "question": "What are the trade-offs between different Performance approaches?",
              "topic": "Profiling",
              "difficulty": "Advanced",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of Performance concepts. The correct answer demonstrates proper implementation of Performance Optimization principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding Performance is crucial for building scalable and maintainable applications.",
              "tags": [
                "quality",
                "advanced"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "performance-optimization-q5",
              "question": "Which pattern is most effective for Performance architecture?",
              "topic": "Optimization",
              "difficulty": "Intermediate",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of Performance concepts. The correct answer demonstrates proper implementation of Performance Optimization principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding Performance is crucial for building scalable and maintainable applications.",
              "tags": [
                "quality",
                "intermediate"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "performance-optimization-q6",
              "question": "What is the primary purpose of Performance?",
              "topic": "Performance",
              "difficulty": "Beginner",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of Performance concepts. The correct answer demonstrates proper implementation of Performance Optimization principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding Performance is crucial for building scalable and maintainable applications.",
              "tags": [
                "quality",
                "beginner"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "performance-optimization-q7",
              "question": "What are the performance considerations when using Performance?",
              "topic": "Profiling",
              "difficulty": "Intermediate",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of Performance concepts. The correct answer demonstrates proper implementation of Performance Optimization principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding Performance is crucial for building scalable and maintainable applications.",
              "tags": [
                "quality",
                "intermediate"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "performance-optimization-q8",
              "question": "When should you use Performance in development?",
              "topic": "Optimization",
              "difficulty": "Beginner",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of Performance concepts. The correct answer demonstrates proper implementation of Performance Optimization principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding Performance is crucial for building scalable and maintainable applications.",
              "tags": [
                "quality",
                "beginner"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "performance-optimization-q9",
              "question": "What is the primary purpose of Performance?",
              "topic": "Performance",
              "difficulty": "Beginner",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of Performance concepts. The correct answer demonstrates proper implementation of Performance Optimization principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding Performance is crucial for building scalable and maintainable applications.",
              "tags": [
                "quality",
                "beginner"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "performance-optimization-q10",
              "question": "What are the performance considerations when using Performance?",
              "topic": "Profiling",
              "difficulty": "Intermediate",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of Performance concepts. The correct answer demonstrates proper implementation of Performance Optimization principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding Performance is crucial for building scalable and maintainable applications.",
              "tags": [
                "quality",
                "intermediate"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "performance-optimization-q11",
              "question": "When should you use Performance in development?",
              "topic": "Optimization",
              "difficulty": "Beginner",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of Performance concepts. The correct answer demonstrates proper implementation of Performance Optimization principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding Performance is crucial for building scalable and maintainable applications.",
              "tags": [
                "quality",
                "beginner"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "performance-optimization-q12",
              "question": "What is the primary purpose of Performance?",
              "topic": "Performance",
              "difficulty": "Beginner",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of Performance concepts. The correct answer demonstrates proper implementation of Performance Optimization principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding Performance is crucial for building scalable and maintainable applications.",
              "tags": [
                "quality",
                "beginner"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "performance-optimization-q13",
              "question": "What are the performance considerations when using Performance?",
              "topic": "Profiling",
              "difficulty": "Intermediate",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of Performance concepts. The correct answer demonstrates proper implementation of Performance Optimization principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding Performance is crucial for building scalable and maintainable applications.",
              "tags": [
                "quality",
                "intermediate"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "performance-optimization-q14",
              "question": "How do you troubleshoot complex Performance issues?",
              "topic": "Optimization",
              "difficulty": "Advanced",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of Performance concepts. The correct answer demonstrates proper implementation of Performance Optimization principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding Performance is crucial for building scalable and maintainable applications.",
              "tags": [
                "quality",
                "advanced"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "performance-optimization-q15",
              "question": "What is the primary purpose of Performance?",
              "topic": "Performance",
              "difficulty": "Beginner",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of Performance concepts. The correct answer demonstrates proper implementation of Performance Optimization principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding Performance is crucial for building scalable and maintainable applications.",
              "tags": [
                "quality",
                "beginner"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "performance-optimization-q16",
              "question": "What are the performance considerations when using Performance?",
              "topic": "Profiling",
              "difficulty": "Intermediate",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of Performance concepts. The correct answer demonstrates proper implementation of Performance Optimization principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding Performance is crucial for building scalable and maintainable applications.",
              "tags": [
                "quality",
                "intermediate"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            }
          ],
          "issues": []
        },
        "meetsThresholds": true,
        "issues": []
      },
      "security-fundamentals": {
        "slug": "security-fundamentals",
        "title": "Security Best Practices",
        "tier": "quality",
        "track": "Security",
        "difficulty": "Advanced",
        "thresholds": {
          "requiredLessons": 15,
          "requiredQuestions": 20
        },
        "lessons": {
          "exists": true,
          "count": 15,
          "lessons": [
            {
              "id": "security-fundamentals-lesson-1",
              "moduleSlug": "security-fundamentals",
              "title": "Web Security Fundamentals",
              "order": 1,
              "objectives": [
                "Understand common web security vulnerabilities and threats",
                "Learn authentication and authorization best practices",
                "Implement secure coding practices to prevent attacks"
              ],
              "intro": "Web security is critical for protecting applications and user data from malicious attacks. Understanding security fundamentals helps developers build robust applications that resist common vulnerabilities and protect sensitive information.\n\nIn this lesson, you'll learn about the OWASP Top 10 security risks including injection attacks, broken authentication, sensitive data exposure, and security misconfigurations. These represent the most critical security issues facing web applications today.\n\nAuthentication and authorization form the backbone of application security. You'll understand the difference between these concepts and learn to implement secure login systems, session management, and access controls that protect user accounts and data.\n\nSecure coding practices prevent vulnerabilities at the source. You'll discover input validation techniques, output encoding, secure storage methods, and proper error handling that make applications resilient against attacks.\n\nBy mastering these security fundamentals, you'll be equipped to identify potential vulnerabilities early, implement robust security measures, and follow industry best practices that protect both applications and users from cyber threats.",
              "code": {
                "example": "// Web Security Best Practices Implementation\n\n// 1. Input Validation and Sanitization\nfunction validateAndSanitizeInput(input, type) {\n  // Remove potentially harmful characters\n  const sanitized = input.replace(/<script[^>]*>.*?</script>/gi, '');\n  \n  switch (type) {\n    case 'email':\n      const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n      if (!emailRegex.test(sanitized)) {\n        throw new Error('Invalid email format');\n      }\n      break;\n    \n    case 'username':\n      const usernameRegex = /^[a-zA-Z0-9_]{3,20}$/;\n      if (!usernameRegex.test(sanitized)) {\n        throw new Error('Username must be 3-20 characters, alphanumeric and underscore only');\n      }\n      break;\n      \n    case 'password':\n      if (sanitized.length < 8) {\n        throw new Error('Password must be at least 8 characters');\n      }\n      break;\n  }\n  \n  return sanitized;\n}\n\n// 2. Secure Authentication Implementation\nconst bcrypt = require('bcrypt');\nconst jwt = require('jsonwebtoken');\n\nclass AuthService {\n  static async hashPassword(password) {\n    const saltRounds = 12; // Increased for better security\n    return await bcrypt.hash(password, saltRounds);\n  }\n  \n  static async verifyPassword(password, hashedPassword) {\n    return await bcrypt.compare(password, hashedPassword);\n  }\n  \n  static generateToken(user) {\n    const payload = {\n      userId: user.id,\n      email: user.email,\n      role: user.role\n    };\n    \n    return jwt.sign(payload, process.env.JWT_SECRET, {\n      expiresIn: '15m', // Short-lived tokens\n      issuer: 'your-app-name',\n      audience: 'your-app-users'\n    });\n  }\n  \n  static verifyToken(token) {\n    try {\n      return jwt.verify(token, process.env.JWT_SECRET, {\n        issuer: 'your-app-name',\n        audience: 'your-app-users'\n      });\n    } catch (error) {\n      throw new Error('Invalid or expired token');\n    }\n  }\n}\n\n// 3. Authorization Middleware\nfunction authorize(requiredRole) {\n  return (req, res, next) => {\n    try {\n      const token = req.headers.authorization?.split(' ')[1];\n      \n      if (!token) {\n        return res.status(401).json({ error: 'Access token required' });\n      }\n      \n      const decoded = AuthService.verifyToken(token);\n      \n      if (requiredRole && decoded.role !== requiredRole) {\n        return res.status(403).json({ error: 'Insufficient permissions' });\n      }\n      \n      req.user = decoded;\n      next();\n    } catch (error) {\n      return res.status(401).json({ error: 'Invalid token' });\n    }\n  };\n}\n\n// 4. SQL Injection Prevention\nconst mysql = require('mysql2/promise');\n\nclass UserRepository {\n  static async findByEmail(email) {\n    // Use parameterized queries to prevent SQL injection\n    const query = 'SELECT * FROM users WHERE email = ? AND active = 1';\n    const [rows] = await db.execute(query, [email]);\n    return rows[0];\n  }\n  \n  static async createUser(userData) {\n    const query = `\n      INSERT INTO users (email, password_hash, name, role, created_at) \n      VALUES (?, ?, ?, ?, NOW())\n    `;\n    \n    const [result] = await db.execute(query, [\n      userData.email,\n      userData.passwordHash,\n      userData.name,\n      userData.role || 'user'\n    ]);\n    \n    return result.insertId;\n  }\n}\n\n// 5. Security Headers Middleware\nfunction securityHeaders(req, res, next) {\n  // Prevent XSS attacks\n  res.setHeader('X-XSS-Protection', '1; mode=block');\n  \n  // Prevent MIME type sniffing\n  res.setHeader('X-Content-Type-Options', 'nosniff');\n  \n  // Prevent clickjacking\n  res.setHeader('X-Frame-Options', 'DENY');\n  \n  // HTTPS enforcement\n  res.setHeader('Strict-Transport-Security', 'max-age=31536000; includeSubDomains');\n  \n  // Content Security Policy\n  res.setHeader('Content-Security-Policy', \n    \"default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline';\");\n  \n  next();\n}\n\n// Usage Examples\napp.use(securityHeaders);\napp.post('/api/login', async (req, res) => {\n  try {\n    const email = validateAndSanitizeInput(req.body.email, 'email');\n    const password = validateAndSanitizeInput(req.body.password, 'password');\n    \n    const user = await UserRepository.findByEmail(email);\n    \n    if (!user || !await AuthService.verifyPassword(password, user.password_hash)) {\n      return res.status(401).json({ error: 'Invalid credentials' });\n    }\n    \n    const token = AuthService.generateToken(user);\n    res.json({ token, user: { id: user.id, email: user.email, role: user.role } });\n  } catch (error) {\n    res.status(400).json({ error: error.message });\n  }\n});\n\napp.get('/api/admin/users', authorize('admin'), (req, res) => {\n  // Only admin users can access this endpoint\n  res.json({ message: 'Admin access granted' });\n});",
                "explanation": "This comprehensive example demonstrates essential web security practices including input validation, secure authentication with bcrypt and JWT, authorization middleware, SQL injection prevention, and security headers implementation.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following Security best practices",
                  "solution": "Review official documentation and established patterns for Security",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling in implementation",
                  "solution": "Always implement proper error handling and validation",
                  "severity": "high"
                },
                {
                  "mistake": "Ignoring performance implications",
                  "solution": "Consider performance impact of your implementation choices",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice Testing Fundamentals",
                  "description": "Apply the concepts learned in this lesson through hands-on practice.",
                  "checkpoints": [
                    "Complete the basic implementation",
                    "Test your solution",
                    "Identify areas for improvement"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Advanced",
              "tags": [
                "Security",
                "Authentication",
                "Authorization"
              ],
              "lastUpdated": "2025-10-01T06:42:16.318Z",
              "version": "1.0.0"
            },
            {
              "id": "security-fundamentals-lesson-2",
              "moduleSlug": "security-fundamentals",
              "title": "Quality Assurance",
              "order": 2,
              "objectives": [
                "Implement basic Security patterns",
                "Create simple applications using core concepts",
                "Debug common issues effectively"
              ],
              "intro": "Welcome to Quality Assurance in the Security Best Practices module. \n\nThis lesson is part of the quality tier, designed for advanced level learners. Throughout this lesson, you'll explore essential concepts and practical applications that form the foundation of modern security development.\n\nAuthentication, authorization, and security patterns This lesson builds upon previous concepts while introducing new techniques that will enhance your understanding and practical skills.\n\nBy the end of this lesson, you'll have hands-on experience with Security and Authentication, along with best practices for implementing these technologies in real-world scenarios. The knowledge gained here will prepare you for more advanced topics in subsequent lessons.\n\nKey areas we'll cover include practical implementation techniques, common challenges developers face, and proven solutions that industry professionals use daily. This lesson balances theoretical understanding with practical application, ensuring you can immediately apply what you learn.",
              "code": {
                "example": "// Example Security implementation\n// TODO: Add specific code example for Security Best Practices\n\npublic class Example\n{\n    public void DemonstrateCoreSecurityConcepts()\n    {\n        // Placeholder implementation\n        Console.WriteLine(\"Security Best Practices example\");\n    }\n}",
                "explanation": "This example demonstrates the key concepts covered in this lesson.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following Security best practices",
                  "solution": "Review official documentation and established patterns for Security",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling in implementation",
                  "solution": "Always implement proper error handling and validation",
                  "severity": "high"
                },
                {
                  "mistake": "Ignoring performance implications",
                  "solution": "Consider performance impact of your implementation choices",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice Quality Assurance",
                  "description": "Apply the concepts learned in this lesson through hands-on practice.",
                  "checkpoints": [
                    "Complete the basic implementation",
                    "Test your solution",
                    "Identify areas for improvement"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Advanced",
              "tags": [
                "Security",
                "Authentication",
                "Authorization"
              ],
              "lastUpdated": "2025-10-01T06:42:16.318Z",
              "version": "1.0.0"
            },
            {
              "id": "security-fundamentals-lesson-3",
              "moduleSlug": "security-fundamentals",
              "title": "Automated Testing",
              "order": 3,
              "objectives": [
                "Apply advanced Security techniques",
                "Optimize performance and efficiency",
                "Integrate with external systems"
              ],
              "intro": "Welcome to Automated Testing in the Security Best Practices module. \n\nThis lesson is part of the quality tier, designed for advanced level learners. Throughout this lesson, you'll explore essential concepts and practical applications that form the foundation of modern security development.\n\nAuthentication, authorization, and security patterns This lesson builds upon previous concepts while introducing new techniques that will enhance your understanding and practical skills.\n\nBy the end of this lesson, you'll have hands-on experience with Security and Authentication, along with best practices for implementing these technologies in real-world scenarios. The knowledge gained here will prepare you for more advanced topics in subsequent lessons.\n\nKey areas we'll cover include practical implementation techniques, common challenges developers face, and proven solutions that industry professionals use daily. This lesson balances theoretical understanding with practical application, ensuring you can immediately apply what you learn.",
              "code": {
                "example": "// Example Security implementation\n// TODO: Add specific code example for Security Best Practices\n\npublic class Example\n{\n    public void DemonstrateCoreSecurityConcepts()\n    {\n        // Placeholder implementation\n        Console.WriteLine(\"Security Best Practices example\");\n    }\n}",
                "explanation": "This example demonstrates the key concepts covered in this lesson.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following Security best practices",
                  "solution": "Review official documentation and established patterns for Security",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling in implementation",
                  "solution": "Always implement proper error handling and validation",
                  "severity": "high"
                },
                {
                  "mistake": "Ignoring performance implications",
                  "solution": "Consider performance impact of your implementation choices",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice Automated Testing",
                  "description": "Apply the concepts learned in this lesson through hands-on practice.",
                  "checkpoints": [
                    "Complete the basic implementation",
                    "Test your solution",
                    "Identify areas for improvement"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Advanced",
              "tags": [
                "Security",
                "Authentication",
                "Authorization"
              ],
              "lastUpdated": "2025-10-01T06:42:16.318Z",
              "version": "1.0.0"
            },
            {
              "id": "security-fundamentals-lesson-4",
              "moduleSlug": "security-fundamentals",
              "title": "Performance Testing",
              "order": 4,
              "objectives": [
                "Apply advanced Security techniques",
                "Optimize performance and efficiency",
                "Integrate with external systems"
              ],
              "intro": "Welcome to Performance Testing in the Security Best Practices module. \n\nThis lesson is part of the quality tier, designed for advanced level learners. Throughout this lesson, you'll explore essential concepts and practical applications that form the foundation of modern security development.\n\nAuthentication, authorization, and security patterns This lesson builds upon previous concepts while introducing new techniques that will enhance your understanding and practical skills.\n\nBy the end of this lesson, you'll have hands-on experience with Security and Authentication, along with best practices for implementing these technologies in real-world scenarios. The knowledge gained here will prepare you for more advanced topics in subsequent lessons.\n\nKey areas we'll cover include practical implementation techniques, common challenges developers face, and proven solutions that industry professionals use daily. This lesson balances theoretical understanding with practical application, ensuring you can immediately apply what you learn.",
              "code": {
                "example": "// Example Security implementation\n// TODO: Add specific code example for Security Best Practices\n\npublic class Example\n{\n    public void DemonstrateCoreSecurityConcepts()\n    {\n        // Placeholder implementation\n        Console.WriteLine(\"Security Best Practices example\");\n    }\n}",
                "explanation": "This example demonstrates the key concepts covered in this lesson.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following Security best practices",
                  "solution": "Review official documentation and established patterns for Security",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling in implementation",
                  "solution": "Always implement proper error handling and validation",
                  "severity": "high"
                },
                {
                  "mistake": "Ignoring performance implications",
                  "solution": "Consider performance impact of your implementation choices",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice Performance Testing",
                  "description": "Apply the concepts learned in this lesson through hands-on practice.",
                  "checkpoints": [
                    "Complete the basic implementation",
                    "Test your solution",
                    "Identify areas for improvement"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Advanced",
              "tags": [
                "Security",
                "Authentication",
                "Authorization"
              ],
              "lastUpdated": "2025-10-01T06:42:16.318Z",
              "version": "1.0.0"
            },
            {
              "id": "security-fundamentals-lesson-5",
              "moduleSlug": "security-fundamentals",
              "title": "Security Testing",
              "order": 5,
              "objectives": [
                "Apply advanced Security techniques",
                "Optimize performance and efficiency",
                "Integrate with external systems"
              ],
              "intro": "Welcome to Security Testing in the Security Best Practices module. \n\nThis lesson is part of the quality tier, designed for advanced level learners. Throughout this lesson, you'll explore essential concepts and practical applications that form the foundation of modern security development.\n\nAuthentication, authorization, and security patterns This lesson builds upon previous concepts while introducing new techniques that will enhance your understanding and practical skills.\n\nBy the end of this lesson, you'll have hands-on experience with Security and Authentication, along with best practices for implementing these technologies in real-world scenarios. The knowledge gained here will prepare you for more advanced topics in subsequent lessons.\n\nKey areas we'll cover include practical implementation techniques, common challenges developers face, and proven solutions that industry professionals use daily. This lesson balances theoretical understanding with practical application, ensuring you can immediately apply what you learn.",
              "code": {
                "example": "// Example Security implementation\n// TODO: Add specific code example for Security Best Practices\n\npublic class Example\n{\n    public void DemonstrateCoreSecurityConcepts()\n    {\n        // Placeholder implementation\n        Console.WriteLine(\"Security Best Practices example\");\n    }\n}",
                "explanation": "This example demonstrates the key concepts covered in this lesson.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following Security best practices",
                  "solution": "Review official documentation and established patterns for Security",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling in implementation",
                  "solution": "Always implement proper error handling and validation",
                  "severity": "high"
                },
                {
                  "mistake": "Ignoring performance implications",
                  "solution": "Consider performance impact of your implementation choices",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice Security Testing",
                  "description": "Apply the concepts learned in this lesson through hands-on practice.",
                  "checkpoints": [
                    "Complete the basic implementation",
                    "Test your solution",
                    "Identify areas for improvement"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Advanced",
              "tags": [
                "Security",
                "Authentication",
                "Authorization"
              ],
              "lastUpdated": "2025-10-01T06:42:16.318Z",
              "version": "1.0.0"
            },
            {
              "id": "security-fundamentals-lesson-6",
              "moduleSlug": "security-fundamentals",
              "title": "Code Quality",
              "order": 6,
              "objectives": [
                "Apply advanced Security techniques",
                "Optimize performance and efficiency",
                "Integrate with external systems"
              ],
              "intro": "Welcome to Code Quality in the Security Best Practices module. \n\nThis lesson is part of the quality tier, designed for advanced level learners. Throughout this lesson, you'll explore essential concepts and practical applications that form the foundation of modern security development.\n\nAuthentication, authorization, and security patterns This lesson builds upon previous concepts while introducing new techniques that will enhance your understanding and practical skills.\n\nBy the end of this lesson, you'll have hands-on experience with Security and Authentication, along with best practices for implementing these technologies in real-world scenarios. The knowledge gained here will prepare you for more advanced topics in subsequent lessons.\n\nKey areas we'll cover include practical implementation techniques, common challenges developers face, and proven solutions that industry professionals use daily. This lesson balances theoretical understanding with practical application, ensuring you can immediately apply what you learn.",
              "code": {
                "example": "// Example Security implementation\n// TODO: Add specific code example for Security Best Practices\n\npublic class Example\n{\n    public void DemonstrateCoreSecurityConcepts()\n    {\n        // Placeholder implementation\n        Console.WriteLine(\"Security Best Practices example\");\n    }\n}",
                "explanation": "This example demonstrates the key concepts covered in this lesson.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following Security best practices",
                  "solution": "Review official documentation and established patterns for Security",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling in implementation",
                  "solution": "Always implement proper error handling and validation",
                  "severity": "high"
                },
                {
                  "mistake": "Ignoring performance implications",
                  "solution": "Consider performance impact of your implementation choices",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice Code Quality",
                  "description": "Apply the concepts learned in this lesson through hands-on practice.",
                  "checkpoints": [
                    "Complete the basic implementation",
                    "Test your solution",
                    "Identify areas for improvement"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Advanced",
              "tags": [
                "Security",
                "Authentication",
                "Authorization"
              ],
              "lastUpdated": "2025-10-01T06:42:16.318Z",
              "version": "1.0.0"
            },
            {
              "id": "security-fundamentals-lesson-7",
              "moduleSlug": "security-fundamentals",
              "title": "Review Processes",
              "order": 7,
              "objectives": [
                "Apply advanced Security techniques",
                "Optimize performance and efficiency",
                "Integrate with external systems"
              ],
              "intro": "Welcome to Review Processes in the Security Best Practices module. \n\nThis lesson is part of the quality tier, designed for advanced level learners. Throughout this lesson, you'll explore essential concepts and practical applications that form the foundation of modern security development.\n\nAuthentication, authorization, and security patterns This lesson builds upon previous concepts while introducing new techniques that will enhance your understanding and practical skills.\n\nBy the end of this lesson, you'll have hands-on experience with Security and Authentication, along with best practices for implementing these technologies in real-world scenarios. The knowledge gained here will prepare you for more advanced topics in subsequent lessons.\n\nKey areas we'll cover include practical implementation techniques, common challenges developers face, and proven solutions that industry professionals use daily. This lesson balances theoretical understanding with practical application, ensuring you can immediately apply what you learn.",
              "code": {
                "example": "// Example Security implementation\n// TODO: Add specific code example for Security Best Practices\n\npublic class Example\n{\n    public void DemonstrateCoreSecurityConcepts()\n    {\n        // Placeholder implementation\n        Console.WriteLine(\"Security Best Practices example\");\n    }\n}",
                "explanation": "This example demonstrates the key concepts covered in this lesson.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following Security best practices",
                  "solution": "Review official documentation and established patterns for Security",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling in implementation",
                  "solution": "Always implement proper error handling and validation",
                  "severity": "high"
                },
                {
                  "mistake": "Ignoring performance implications",
                  "solution": "Consider performance impact of your implementation choices",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice Review Processes",
                  "description": "Apply the concepts learned in this lesson through hands-on practice.",
                  "checkpoints": [
                    "Complete the basic implementation",
                    "Test your solution",
                    "Identify areas for improvement"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Advanced",
              "tags": [
                "Security",
                "Authentication",
                "Authorization"
              ],
              "lastUpdated": "2025-10-01T06:42:16.318Z",
              "version": "1.0.0"
            },
            {
              "id": "security-fundamentals-lesson-8",
              "moduleSlug": "security-fundamentals",
              "title": "Continuous Integration",
              "order": 8,
              "objectives": [
                "Apply advanced Security techniques",
                "Optimize performance and efficiency",
                "Integrate with external systems"
              ],
              "intro": "Welcome to Continuous Integration in the Security Best Practices module. \n\nThis lesson is part of the quality tier, designed for advanced level learners. Throughout this lesson, you'll explore essential concepts and practical applications that form the foundation of modern security development.\n\nAuthentication, authorization, and security patterns This lesson builds upon previous concepts while introducing new techniques that will enhance your understanding and practical skills.\n\nBy the end of this lesson, you'll have hands-on experience with Security and Authentication, along with best practices for implementing these technologies in real-world scenarios. The knowledge gained here will prepare you for more advanced topics in subsequent lessons.\n\nKey areas we'll cover include practical implementation techniques, common challenges developers face, and proven solutions that industry professionals use daily. This lesson balances theoretical understanding with practical application, ensuring you can immediately apply what you learn.",
              "code": {
                "example": "// Example Security implementation\n// TODO: Add specific code example for Security Best Practices\n\npublic class Example\n{\n    public void DemonstrateCoreSecurityConcepts()\n    {\n        // Placeholder implementation\n        Console.WriteLine(\"Security Best Practices example\");\n    }\n}",
                "explanation": "This example demonstrates the key concepts covered in this lesson.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following Security best practices",
                  "solution": "Review official documentation and established patterns for Security",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling in implementation",
                  "solution": "Always implement proper error handling and validation",
                  "severity": "high"
                },
                {
                  "mistake": "Ignoring performance implications",
                  "solution": "Consider performance impact of your implementation choices",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice Continuous Integration",
                  "description": "Apply the concepts learned in this lesson through hands-on practice.",
                  "checkpoints": [
                    "Complete the basic implementation",
                    "Test your solution",
                    "Identify areas for improvement"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Advanced",
              "tags": [
                "Security",
                "Authentication",
                "Authorization"
              ],
              "lastUpdated": "2025-10-01T06:42:16.318Z",
              "version": "1.0.0"
            },
            {
              "id": "security-fundamentals-lesson-9",
              "moduleSlug": "security-fundamentals",
              "title": "Monitoring Setup",
              "order": 9,
              "objectives": [
                "Apply advanced Security techniques",
                "Optimize performance and efficiency",
                "Integrate with external systems"
              ],
              "intro": "Welcome to Monitoring Setup in the Security Best Practices module. \n\nThis lesson is part of the quality tier, designed for advanced level learners. Throughout this lesson, you'll explore essential concepts and practical applications that form the foundation of modern security development.\n\nAuthentication, authorization, and security patterns This lesson builds upon previous concepts while introducing new techniques that will enhance your understanding and practical skills.\n\nBy the end of this lesson, you'll have hands-on experience with Security and Authentication, along with best practices for implementing these technologies in real-world scenarios. The knowledge gained here will prepare you for more advanced topics in subsequent lessons.\n\nKey areas we'll cover include practical implementation techniques, common challenges developers face, and proven solutions that industry professionals use daily. This lesson balances theoretical understanding with practical application, ensuring you can immediately apply what you learn.",
              "code": {
                "example": "// Example Security implementation\n// TODO: Add specific code example for Security Best Practices\n\npublic class Example\n{\n    public void DemonstrateCoreSecurityConcepts()\n    {\n        // Placeholder implementation\n        Console.WriteLine(\"Security Best Practices example\");\n    }\n}",
                "explanation": "This example demonstrates the key concepts covered in this lesson.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following Security best practices",
                  "solution": "Review official documentation and established patterns for Security",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling in implementation",
                  "solution": "Always implement proper error handling and validation",
                  "severity": "high"
                },
                {
                  "mistake": "Ignoring performance implications",
                  "solution": "Consider performance impact of your implementation choices",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice Monitoring Setup",
                  "description": "Apply the concepts learned in this lesson through hands-on practice.",
                  "checkpoints": [
                    "Complete the basic implementation",
                    "Test your solution",
                    "Identify areas for improvement"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Advanced",
              "tags": [
                "Security",
                "Authentication",
                "Authorization"
              ],
              "lastUpdated": "2025-10-01T06:42:16.318Z",
              "version": "1.0.0"
            },
            {
              "id": "security-fundamentals-lesson-10",
              "moduleSlug": "security-fundamentals",
              "title": "Debugging Techniques",
              "order": 10,
              "objectives": [
                "Apply advanced Security techniques",
                "Optimize performance and efficiency",
                "Integrate with external systems"
              ],
              "intro": "Welcome to Debugging Techniques in the Security Best Practices module. \n\nThis lesson is part of the quality tier, designed for advanced level learners. Throughout this lesson, you'll explore essential concepts and practical applications that form the foundation of modern security development.\n\nAuthentication, authorization, and security patterns This lesson builds upon previous concepts while introducing new techniques that will enhance your understanding and practical skills.\n\nBy the end of this lesson, you'll have hands-on experience with Security and Authentication, along with best practices for implementing these technologies in real-world scenarios. The knowledge gained here will prepare you for more advanced topics in subsequent lessons.\n\nKey areas we'll cover include practical implementation techniques, common challenges developers face, and proven solutions that industry professionals use daily. This lesson balances theoretical understanding with practical application, ensuring you can immediately apply what you learn.",
              "code": {
                "example": "// Example Security implementation\n// TODO: Add specific code example for Security Best Practices\n\npublic class Example\n{\n    public void DemonstrateCoreSecurityConcepts()\n    {\n        // Placeholder implementation\n        Console.WriteLine(\"Security Best Practices example\");\n    }\n}",
                "explanation": "This example demonstrates the key concepts covered in this lesson.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following Security best practices",
                  "solution": "Review official documentation and established patterns for Security",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling in implementation",
                  "solution": "Always implement proper error handling and validation",
                  "severity": "high"
                },
                {
                  "mistake": "Ignoring performance implications",
                  "solution": "Consider performance impact of your implementation choices",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice Debugging Techniques",
                  "description": "Apply the concepts learned in this lesson through hands-on practice.",
                  "checkpoints": [
                    "Complete the basic implementation",
                    "Test your solution",
                    "Identify areas for improvement"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Advanced",
              "tags": [
                "Security",
                "Authentication",
                "Authorization"
              ],
              "lastUpdated": "2025-10-01T06:42:16.318Z",
              "version": "1.0.0"
            },
            {
              "id": "security-fundamentals-lesson-11",
              "moduleSlug": "security-fundamentals",
              "title": "Optimization Methods",
              "order": 11,
              "objectives": [
                "Apply advanced Security techniques",
                "Optimize performance and efficiency",
                "Integrate with external systems"
              ],
              "intro": "Welcome to Optimization Methods in the Security Best Practices module. \n\nThis lesson is part of the quality tier, designed for advanced level learners. Throughout this lesson, you'll explore essential concepts and practical applications that form the foundation of modern security development.\n\nAuthentication, authorization, and security patterns This lesson builds upon previous concepts while introducing new techniques that will enhance your understanding and practical skills.\n\nBy the end of this lesson, you'll have hands-on experience with Security and Authentication, along with best practices for implementing these technologies in real-world scenarios. The knowledge gained here will prepare you for more advanced topics in subsequent lessons.\n\nKey areas we'll cover include practical implementation techniques, common challenges developers face, and proven solutions that industry professionals use daily. This lesson balances theoretical understanding with practical application, ensuring you can immediately apply what you learn.",
              "code": {
                "example": "// Example Security implementation\n// TODO: Add specific code example for Security Best Practices\n\npublic class Example\n{\n    public void DemonstrateCoreSecurityConcepts()\n    {\n        // Placeholder implementation\n        Console.WriteLine(\"Security Best Practices example\");\n    }\n}",
                "explanation": "This example demonstrates the key concepts covered in this lesson.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following Security best practices",
                  "solution": "Review official documentation and established patterns for Security",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling in implementation",
                  "solution": "Always implement proper error handling and validation",
                  "severity": "high"
                },
                {
                  "mistake": "Ignoring performance implications",
                  "solution": "Consider performance impact of your implementation choices",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice Optimization Methods",
                  "description": "Apply the concepts learned in this lesson through hands-on practice.",
                  "checkpoints": [
                    "Complete the basic implementation",
                    "Test your solution",
                    "Identify areas for improvement"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Advanced",
              "tags": [
                "Security",
                "Authentication",
                "Authorization"
              ],
              "lastUpdated": "2025-10-01T06:42:16.318Z",
              "version": "1.0.0"
            },
            {
              "id": "security-fundamentals-lesson-12",
              "moduleSlug": "security-fundamentals",
              "title": "Quality Standards",
              "order": 12,
              "objectives": [
                "Apply advanced Security techniques",
                "Optimize performance and efficiency",
                "Integrate with external systems"
              ],
              "intro": "Welcome to Quality Standards in the Security Best Practices module. \n\nThis lesson is part of the quality tier, designed for advanced level learners. Throughout this lesson, you'll explore essential concepts and practical applications that form the foundation of modern security development.\n\nAuthentication, authorization, and security patterns This lesson builds upon previous concepts while introducing new techniques that will enhance your understanding and practical skills.\n\nBy the end of this lesson, you'll have hands-on experience with Security and Authentication, along with best practices for implementing these technologies in real-world scenarios. The knowledge gained here will prepare you for more advanced topics in subsequent lessons.\n\nKey areas we'll cover include practical implementation techniques, common challenges developers face, and proven solutions that industry professionals use daily. This lesson balances theoretical understanding with practical application, ensuring you can immediately apply what you learn.",
              "code": {
                "example": "// Example Security implementation\n// TODO: Add specific code example for Security Best Practices\n\npublic class Example\n{\n    public void DemonstrateCoreSecurityConcepts()\n    {\n        // Placeholder implementation\n        Console.WriteLine(\"Security Best Practices example\");\n    }\n}",
                "explanation": "This example demonstrates the key concepts covered in this lesson.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following Security best practices",
                  "solution": "Review official documentation and established patterns for Security",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling in implementation",
                  "solution": "Always implement proper error handling and validation",
                  "severity": "high"
                },
                {
                  "mistake": "Ignoring performance implications",
                  "solution": "Consider performance impact of your implementation choices",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice Quality Standards",
                  "description": "Apply the concepts learned in this lesson through hands-on practice.",
                  "checkpoints": [
                    "Complete the basic implementation",
                    "Test your solution",
                    "Identify areas for improvement"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Advanced",
              "tags": [
                "Security",
                "Authentication",
                "Authorization"
              ],
              "lastUpdated": "2025-10-01T06:42:16.318Z",
              "version": "1.0.0"
            },
            {
              "id": "security-fundamentals-lesson-13",
              "moduleSlug": "security-fundamentals",
              "title": "Lesson 13",
              "order": 13,
              "objectives": [
                "Apply advanced Security techniques",
                "Optimize performance and efficiency",
                "Integrate with external systems"
              ],
              "intro": "Welcome to Lesson 13 in the Security Best Practices module. \n\nThis lesson is part of the quality tier, designed for advanced level learners. Throughout this lesson, you'll explore essential concepts and practical applications that form the foundation of modern security development.\n\nAuthentication, authorization, and security patterns This lesson builds upon previous concepts while introducing new techniques that will enhance your understanding and practical skills.\n\nBy the end of this lesson, you'll have hands-on experience with Security and Authentication, along with best practices for implementing these technologies in real-world scenarios. The knowledge gained here will prepare you for more advanced topics in subsequent lessons.\n\nKey areas we'll cover include practical implementation techniques, common challenges developers face, and proven solutions that industry professionals use daily. This lesson balances theoretical understanding with practical application, ensuring you can immediately apply what you learn.",
              "code": {
                "example": "// Example Security implementation\n// TODO: Add specific code example for Security Best Practices\n\npublic class Example\n{\n    public void DemonstrateCoreSecurityConcepts()\n    {\n        // Placeholder implementation\n        Console.WriteLine(\"Security Best Practices example\");\n    }\n}",
                "explanation": "This example demonstrates the key concepts covered in this lesson.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following Security best practices",
                  "solution": "Review official documentation and established patterns for Security",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling in implementation",
                  "solution": "Always implement proper error handling and validation",
                  "severity": "high"
                },
                {
                  "mistake": "Ignoring performance implications",
                  "solution": "Consider performance impact of your implementation choices",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice Lesson 13",
                  "description": "Apply the concepts learned in this lesson through hands-on practice.",
                  "checkpoints": [
                    "Complete the basic implementation",
                    "Test your solution",
                    "Identify areas for improvement"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Advanced",
              "tags": [
                "Security",
                "Authentication",
                "Authorization"
              ],
              "lastUpdated": "2025-10-01T06:42:16.318Z",
              "version": "1.0.0"
            },
            {
              "id": "security-fundamentals-lesson-14",
              "moduleSlug": "security-fundamentals",
              "title": "Lesson 14",
              "order": 14,
              "objectives": [
                "Apply advanced Security techniques",
                "Optimize performance and efficiency",
                "Integrate with external systems"
              ],
              "intro": "Welcome to Lesson 14 in the Security Best Practices module. \n\nThis lesson is part of the quality tier, designed for advanced level learners. Throughout this lesson, you'll explore essential concepts and practical applications that form the foundation of modern security development.\n\nAuthentication, authorization, and security patterns This lesson builds upon previous concepts while introducing new techniques that will enhance your understanding and practical skills.\n\nBy the end of this lesson, you'll have hands-on experience with Security and Authentication, along with best practices for implementing these technologies in real-world scenarios. The knowledge gained here will prepare you for more advanced topics in subsequent lessons.\n\nKey areas we'll cover include practical implementation techniques, common challenges developers face, and proven solutions that industry professionals use daily. This lesson balances theoretical understanding with practical application, ensuring you can immediately apply what you learn.",
              "code": {
                "example": "// Example Security implementation\n// TODO: Add specific code example for Security Best Practices\n\npublic class Example\n{\n    public void DemonstrateCoreSecurityConcepts()\n    {\n        // Placeholder implementation\n        Console.WriteLine(\"Security Best Practices example\");\n    }\n}",
                "explanation": "This example demonstrates the key concepts covered in this lesson.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following Security best practices",
                  "solution": "Review official documentation and established patterns for Security",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling in implementation",
                  "solution": "Always implement proper error handling and validation",
                  "severity": "high"
                },
                {
                  "mistake": "Ignoring performance implications",
                  "solution": "Consider performance impact of your implementation choices",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice Lesson 14",
                  "description": "Apply the concepts learned in this lesson through hands-on practice.",
                  "checkpoints": [
                    "Complete the basic implementation",
                    "Test your solution",
                    "Identify areas for improvement"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Advanced",
              "tags": [
                "Security",
                "Authentication",
                "Authorization"
              ],
              "lastUpdated": "2025-10-01T06:42:16.318Z",
              "version": "1.0.0"
            },
            {
              "id": "security-fundamentals-lesson-15",
              "moduleSlug": "security-fundamentals",
              "title": "Lesson 15",
              "order": 15,
              "objectives": [
                "Apply advanced Security techniques",
                "Optimize performance and efficiency",
                "Integrate with external systems"
              ],
              "intro": "Welcome to Lesson 15 in the Security Best Practices module. \n\nThis lesson is part of the quality tier, designed for advanced level learners. Throughout this lesson, you'll explore essential concepts and practical applications that form the foundation of modern security development.\n\nAuthentication, authorization, and security patterns This lesson builds upon previous concepts while introducing new techniques that will enhance your understanding and practical skills.\n\nBy the end of this lesson, you'll have hands-on experience with Security and Authentication, along with best practices for implementing these technologies in real-world scenarios. The knowledge gained here will prepare you for more advanced topics in subsequent lessons.\n\nKey areas we'll cover include practical implementation techniques, common challenges developers face, and proven solutions that industry professionals use daily. This lesson balances theoretical understanding with practical application, ensuring you can immediately apply what you learn.",
              "code": {
                "example": "// Example Security implementation\n// TODO: Add specific code example for Security Best Practices\n\npublic class Example\n{\n    public void DemonstrateCoreSecurityConcepts()\n    {\n        // Placeholder implementation\n        Console.WriteLine(\"Security Best Practices example\");\n    }\n}",
                "explanation": "This example demonstrates the key concepts covered in this lesson.",
                "language": "javascript"
              },
              "pitfalls": [
                {
                  "mistake": "Not following Security best practices",
                  "solution": "Review official documentation and established patterns for Security",
                  "severity": "medium"
                },
                {
                  "mistake": "Skipping error handling in implementation",
                  "solution": "Always implement proper error handling and validation",
                  "severity": "high"
                },
                {
                  "mistake": "Ignoring performance implications",
                  "solution": "Consider performance impact of your implementation choices",
                  "severity": "low"
                }
              ],
              "exercises": [
                {
                  "title": "Practice Lesson 15",
                  "description": "Apply the concepts learned in this lesson through hands-on practice.",
                  "checkpoints": [
                    "Complete the basic implementation",
                    "Test your solution",
                    "Identify areas for improvement"
                  ]
                }
              ],
              "next": [],
              "estimatedMinutes": 30,
              "difficulty": "Advanced",
              "tags": [
                "Security",
                "Authentication",
                "Authorization"
              ],
              "lastUpdated": "2025-10-01T06:42:16.318Z",
              "version": "1.0.0"
            }
          ],
          "issues": []
        },
        "quiz": {
          "exists": true,
          "count": 20,
          "questions": [
            {
              "id": "security-fundamentals-q1",
              "question": "What are the performance considerations when using Security?",
              "topic": "Authentication",
              "difficulty": "Intermediate",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of Security concepts. The correct answer demonstrates proper implementation of Security Best Practices principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding Security is crucial for building scalable and maintainable applications.",
              "tags": [
                "quality",
                "intermediate"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "security-fundamentals-q2",
              "question": "How do you troubleshoot complex Security issues?",
              "topic": "Authorization",
              "difficulty": "Advanced",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of Security concepts. The correct answer demonstrates proper implementation of Security Best Practices principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding Security is crucial for building scalable and maintainable applications.",
              "tags": [
                "quality",
                "advanced"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "security-fundamentals-q3",
              "question": "How would you optimize Security for large-scale applications?",
              "topic": "Security",
              "difficulty": "Advanced",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of Security concepts. The correct answer demonstrates proper implementation of Security Best Practices principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding Security is crucial for building scalable and maintainable applications.",
              "tags": [
                "quality",
                "advanced"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "security-fundamentals-q4",
              "question": "Your web application stores user passwords. Which approach provides the BEST security?",
              "topic": "Authentication",
              "difficulty": "Beginner",
              "choices": [
                "Hash passwords using bcrypt with a salt and appropriate work factor",
                "Encrypt passwords using AES-256 with a secret key",
                "Store passwords in plain text but use HTTPS for transmission",
                "Use MD5 hashing for fast password verification"
              ],
              "correctIndex": 0,
              "explanation": "bcrypt with salt and appropriate work factor (cost parameter) is the gold standard for password storage. It's designed to be slow and resistant to rainbow table attacks. AES encryption is reversible (not suitable for passwords), plain text is never acceptable, and MD5 is cryptographically broken and too fast for password hashing.",
              "industryContext": "Password security breaches are among the most common and damaging security incidents. Proper password hashing is a fundamental requirement for any application handling user credentials.",
              "tags": [
                "authentication",
                "password-security",
                "beginner"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "security-fundamentals-q5",
              "question": "A security audit reveals that your API is vulnerable to SQL injection attacks. You need to fix this immediately. What's the MOST effective solution?",
              "topic": "Authorization",
              "difficulty": "Advanced",
              "choices": [
                "Replace all SQL queries with parameterized queries/prepared statements",
                "Add input validation to reject special characters like quotes",
                "Implement rate limiting to slow down potential attacks",
                "Use stored procedures exclusively for all database operations"
              ],
              "correctIndex": 0,
              "explanation": "Parameterized queries (prepared statements) completely separate SQL code from user data, making SQL injection impossible regardless of input content. Input validation can be bypassed, rate limiting doesn't prevent the vulnerability, and while stored procedures can help, they don't automatically prevent SQL injection if used incorrectly.",
              "industryContext": "SQL injection consistently ranks as one of the top web application security risks (OWASP Top 10). A single SQL injection vulnerability can lead to complete database compromise, making this knowledge critical for any developer working with databases.",
              "tags": [
                "sql-injection",
                "database-security",
                "advanced"
              ],
              "estimatedTime": 120,
              "questionType": "multiple-choice"
            },
            {
              "id": "security-fundamentals-q6",
              "question": "Your e-commerce application handles credit card payments. Which security implementation approach is MOST critical for PCI DSS compliance?",
              "topic": "Security",
              "difficulty": "Intermediate",
              "choices": [
                "Use a certified payment processor (like Stripe/PayPal) and never store card data",
                "Encrypt all card data with AES-256 and store it securely",
                "Hash credit card numbers using bcrypt before storing",
                "Store card data in a separate database with limited access"
              ],
              "correctIndex": 0,
              "explanation": "The safest and most compliant approach is to never store sensitive card data yourself. Use certified payment processors that handle PCI DSS compliance. This reduces your compliance scope from Level 1 (most stringent) to Level 4 (least stringent) and eliminates the risk of card data breaches from your systems.",
              "industryContext": "PCI DSS compliance is legally required for businesses processing credit cards. Non-compliance can result in fines up to $500,000 per incident, plus liability for fraud losses. Using certified processors is the industry standard approach.",
              "tags": [
                "pci-dss",
                "payment-security",
                "intermediate"
              ],
              "estimatedTime": 120,
              "questionType": "multiple-choice"
            },
            {
              "id": "security-fundamentals-q7",
              "question": "Which of the following is a key feature of Security Best Practices?",
              "topic": "Authentication",
              "difficulty": "Beginner",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of Security concepts. The correct answer demonstrates proper implementation of Security Best Practices principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding Security is crucial for building scalable and maintainable applications.",
              "tags": [
                "quality",
                "beginner"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "security-fundamentals-q8",
              "question": "How do you troubleshoot complex Security issues?",
              "topic": "Authorization",
              "difficulty": "Advanced",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of Security concepts. The correct answer demonstrates proper implementation of Security Best Practices principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding Security is crucial for building scalable and maintainable applications.",
              "tags": [
                "quality",
                "advanced"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "security-fundamentals-q9",
              "question": "How do you implement Security in a production environment?",
              "topic": "Security",
              "difficulty": "Intermediate",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of Security concepts. The correct answer demonstrates proper implementation of Security Best Practices principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding Security is crucial for building scalable and maintainable applications.",
              "tags": [
                "quality",
                "intermediate"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "security-fundamentals-q10",
              "question": "What are the trade-offs between different Security approaches?",
              "topic": "Authentication",
              "difficulty": "Advanced",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of Security concepts. The correct answer demonstrates proper implementation of Security Best Practices principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding Security is crucial for building scalable and maintainable applications.",
              "tags": [
                "quality",
                "advanced"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "security-fundamentals-q11",
              "question": "Which pattern is most effective for Security architecture?",
              "topic": "Authorization",
              "difficulty": "Intermediate",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of Security concepts. The correct answer demonstrates proper implementation of Security Best Practices principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding Security is crucial for building scalable and maintainable applications.",
              "tags": [
                "quality",
                "intermediate"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "security-fundamentals-q12",
              "question": "How would you optimize Security for large-scale applications?",
              "topic": "Security",
              "difficulty": "Advanced",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of Security concepts. The correct answer demonstrates proper implementation of Security Best Practices principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding Security is crucial for building scalable and maintainable applications.",
              "tags": [
                "quality",
                "advanced"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "security-fundamentals-q13",
              "question": "What are the trade-offs between different Security approaches?",
              "topic": "Authentication",
              "difficulty": "Advanced",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of Security concepts. The correct answer demonstrates proper implementation of Security Best Practices principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding Security is crucial for building scalable and maintainable applications.",
              "tags": [
                "quality",
                "advanced"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "security-fundamentals-q14",
              "question": "When should you use Security in development?",
              "topic": "Authorization",
              "difficulty": "Beginner",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of Security concepts. The correct answer demonstrates proper implementation of Security Best Practices principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding Security is crucial for building scalable and maintainable applications.",
              "tags": [
                "quality",
                "beginner"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "security-fundamentals-q15",
              "question": "What is the primary purpose of Security?",
              "topic": "Security",
              "difficulty": "Beginner",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of Security concepts. The correct answer demonstrates proper implementation of Security Best Practices principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding Security is crucial for building scalable and maintainable applications.",
              "tags": [
                "quality",
                "beginner"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "security-fundamentals-q16",
              "question": "Which of the following is a key feature of Security Best Practices?",
              "topic": "Authentication",
              "difficulty": "Beginner",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of Security concepts. The correct answer demonstrates proper implementation of Security Best Practices principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding Security is crucial for building scalable and maintainable applications.",
              "tags": [
                "quality",
                "beginner"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "security-fundamentals-q17",
              "question": "When should you use Security in development?",
              "topic": "Authorization",
              "difficulty": "Beginner",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of Security concepts. The correct answer demonstrates proper implementation of Security Best Practices principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding Security is crucial for building scalable and maintainable applications.",
              "tags": [
                "quality",
                "beginner"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "security-fundamentals-q18",
              "question": "What is the primary purpose of Security?",
              "topic": "Security",
              "difficulty": "Beginner",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of Security concepts. The correct answer demonstrates proper implementation of Security Best Practices principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding Security is crucial for building scalable and maintainable applications.",
              "tags": [
                "quality",
                "beginner"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "security-fundamentals-q19",
              "question": "Which of the following is a key feature of Security Best Practices?",
              "topic": "Authentication",
              "difficulty": "Beginner",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of Security concepts. The correct answer demonstrates proper implementation of Security Best Practices principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding Security is crucial for building scalable and maintainable applications.",
              "tags": [
                "quality",
                "beginner"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            },
            {
              "id": "security-fundamentals-q20",
              "question": "When should you use Security in development?",
              "topic": "Authorization",
              "difficulty": "Beginner",
              "choices": [
                "Option A - Placeholder answer",
                "Option B - Placeholder answer",
                "Option C - Placeholder answer",
                "Option D - Placeholder answer"
              ],
              "correctIndex": 0,
              "explanation": "This question tests understanding of Security concepts. The correct answer demonstrates proper implementation of Security Best Practices principles. Review the lesson materials for detailed explanations of these concepts.",
              "industryContext": "In professional development, understanding Security is crucial for building scalable and maintainable applications.",
              "tags": [
                "quality",
                "beginner"
              ],
              "estimatedTime": 90,
              "questionType": "multiple-choice"
            }
          ],
          "issues": []
        },
        "meetsThresholds": true,
        "issues": []
      }
    },
    "summary": {
      "totalModules": 18,
      "modulesWithSufficientLessons": 18,
      "modulesWithSufficientQuestions": 18,
      "totalLessons": 251,
      "totalQuestions": 346,
      "modulesMeetingThresholds": 18
    },
    "issues": [],
    "recommendations": [
      {
        "priority": "medium",
        "category": "content-quality",
        "title": "Address content quality issues",
        "description": "1 modules have quality issues that need attention",
        "modules": [
          "nextjs-advanced"
        ]
      }
    ]
  },
  "summary": {
    "totalModules": 18,
    "modulesWithSufficientLessons": 18,
    "modulesWithSufficientQuestions": 18,
    "totalLessons": 251,
    "totalQuestions": 346,
    "modulesMeetingThresholds": 18,
    "completionRate": "100.0",
    "averageLessonsPerModule": "13.9",
    "averageQuestionsPerModule": "19.2"
  }
}